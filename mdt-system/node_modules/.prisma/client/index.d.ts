
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ExpertProfile
 * 
 */
export type ExpertProfile = $Result.DefaultSelection<Prisma.$ExpertProfilePayload>
/**
 * Model ConsultationTask
 * 
 */
export type ConsultationTask = $Result.DefaultSelection<Prisma.$ConsultationTaskPayload>
/**
 * Model TaskExpert
 * 
 */
export type TaskExpert = $Result.DefaultSelection<Prisma.$TaskExpertPayload>
/**
 * Model PreConsultationDoc
 * 
 */
export type PreConsultationDoc = $Result.DefaultSelection<Prisma.$PreConsultationDocPayload>
/**
 * Model ConsultationDialog
 * 
 */
export type ConsultationDialog = $Result.DefaultSelection<Prisma.$ConsultationDialogPayload>
/**
 * Model PostConsultationDoc
 * 
 */
export type PostConsultationDoc = $Result.DefaultSelection<Prisma.$PostConsultationDocPayload>
/**
 * Model ExpertOpinion
 * 
 */
export type ExpertOpinion = $Result.DefaultSelection<Prisma.$ExpertOpinionPayload>
/**
 * Model ConsultationReport
 * 
 */
export type ConsultationReport = $Result.DefaultSelection<Prisma.$ConsultationReportPayload>
/**
 * Model TaskLog
 * 
 */
export type TaskLog = $Result.DefaultSelection<Prisma.$TaskLogPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.expertProfile`: Exposes CRUD operations for the **ExpertProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpertProfiles
    * const expertProfiles = await prisma.expertProfile.findMany()
    * ```
    */
  get expertProfile(): Prisma.ExpertProfileDelegate<ExtArgs>;

  /**
   * `prisma.consultationTask`: Exposes CRUD operations for the **ConsultationTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsultationTasks
    * const consultationTasks = await prisma.consultationTask.findMany()
    * ```
    */
  get consultationTask(): Prisma.ConsultationTaskDelegate<ExtArgs>;

  /**
   * `prisma.taskExpert`: Exposes CRUD operations for the **TaskExpert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskExperts
    * const taskExperts = await prisma.taskExpert.findMany()
    * ```
    */
  get taskExpert(): Prisma.TaskExpertDelegate<ExtArgs>;

  /**
   * `prisma.preConsultationDoc`: Exposes CRUD operations for the **PreConsultationDoc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PreConsultationDocs
    * const preConsultationDocs = await prisma.preConsultationDoc.findMany()
    * ```
    */
  get preConsultationDoc(): Prisma.PreConsultationDocDelegate<ExtArgs>;

  /**
   * `prisma.consultationDialog`: Exposes CRUD operations for the **ConsultationDialog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsultationDialogs
    * const consultationDialogs = await prisma.consultationDialog.findMany()
    * ```
    */
  get consultationDialog(): Prisma.ConsultationDialogDelegate<ExtArgs>;

  /**
   * `prisma.postConsultationDoc`: Exposes CRUD operations for the **PostConsultationDoc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostConsultationDocs
    * const postConsultationDocs = await prisma.postConsultationDoc.findMany()
    * ```
    */
  get postConsultationDoc(): Prisma.PostConsultationDocDelegate<ExtArgs>;

  /**
   * `prisma.expertOpinion`: Exposes CRUD operations for the **ExpertOpinion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpertOpinions
    * const expertOpinions = await prisma.expertOpinion.findMany()
    * ```
    */
  get expertOpinion(): Prisma.ExpertOpinionDelegate<ExtArgs>;

  /**
   * `prisma.consultationReport`: Exposes CRUD operations for the **ConsultationReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsultationReports
    * const consultationReports = await prisma.consultationReport.findMany()
    * ```
    */
  get consultationReport(): Prisma.ConsultationReportDelegate<ExtArgs>;

  /**
   * `prisma.taskLog`: Exposes CRUD operations for the **TaskLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskLogs
    * const taskLogs = await prisma.taskLog.findMany()
    * ```
    */
  get taskLog(): Prisma.TaskLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ExpertProfile: 'ExpertProfile',
    ConsultationTask: 'ConsultationTask',
    TaskExpert: 'TaskExpert',
    PreConsultationDoc: 'PreConsultationDoc',
    ConsultationDialog: 'ConsultationDialog',
    PostConsultationDoc: 'PostConsultationDoc',
    ExpertOpinion: 'ExpertOpinion',
    ConsultationReport: 'ConsultationReport',
    TaskLog: 'TaskLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "expertProfile" | "consultationTask" | "taskExpert" | "preConsultationDoc" | "consultationDialog" | "postConsultationDoc" | "expertOpinion" | "consultationReport" | "taskLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ExpertProfile: {
        payload: Prisma.$ExpertProfilePayload<ExtArgs>
        fields: Prisma.ExpertProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpertProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpertProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertProfilePayload>
          }
          findFirst: {
            args: Prisma.ExpertProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpertProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertProfilePayload>
          }
          findMany: {
            args: Prisma.ExpertProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertProfilePayload>[]
          }
          create: {
            args: Prisma.ExpertProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertProfilePayload>
          }
          createMany: {
            args: Prisma.ExpertProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpertProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertProfilePayload>[]
          }
          delete: {
            args: Prisma.ExpertProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertProfilePayload>
          }
          update: {
            args: Prisma.ExpertProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertProfilePayload>
          }
          deleteMany: {
            args: Prisma.ExpertProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpertProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpertProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertProfilePayload>
          }
          aggregate: {
            args: Prisma.ExpertProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpertProfile>
          }
          groupBy: {
            args: Prisma.ExpertProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpertProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpertProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ExpertProfileCountAggregateOutputType> | number
          }
        }
      }
      ConsultationTask: {
        payload: Prisma.$ConsultationTaskPayload<ExtArgs>
        fields: Prisma.ConsultationTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsultationTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsultationTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationTaskPayload>
          }
          findFirst: {
            args: Prisma.ConsultationTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsultationTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationTaskPayload>
          }
          findMany: {
            args: Prisma.ConsultationTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationTaskPayload>[]
          }
          create: {
            args: Prisma.ConsultationTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationTaskPayload>
          }
          createMany: {
            args: Prisma.ConsultationTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsultationTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationTaskPayload>[]
          }
          delete: {
            args: Prisma.ConsultationTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationTaskPayload>
          }
          update: {
            args: Prisma.ConsultationTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationTaskPayload>
          }
          deleteMany: {
            args: Prisma.ConsultationTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsultationTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConsultationTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationTaskPayload>
          }
          aggregate: {
            args: Prisma.ConsultationTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultationTask>
          }
          groupBy: {
            args: Prisma.ConsultationTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultationTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsultationTaskCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultationTaskCountAggregateOutputType> | number
          }
        }
      }
      TaskExpert: {
        payload: Prisma.$TaskExpertPayload<ExtArgs>
        fields: Prisma.TaskExpertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskExpertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExpertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskExpertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExpertPayload>
          }
          findFirst: {
            args: Prisma.TaskExpertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExpertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskExpertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExpertPayload>
          }
          findMany: {
            args: Prisma.TaskExpertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExpertPayload>[]
          }
          create: {
            args: Prisma.TaskExpertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExpertPayload>
          }
          createMany: {
            args: Prisma.TaskExpertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskExpertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExpertPayload>[]
          }
          delete: {
            args: Prisma.TaskExpertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExpertPayload>
          }
          update: {
            args: Prisma.TaskExpertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExpertPayload>
          }
          deleteMany: {
            args: Prisma.TaskExpertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskExpertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskExpertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExpertPayload>
          }
          aggregate: {
            args: Prisma.TaskExpertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskExpert>
          }
          groupBy: {
            args: Prisma.TaskExpertGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskExpertGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskExpertCountArgs<ExtArgs>
            result: $Utils.Optional<TaskExpertCountAggregateOutputType> | number
          }
        }
      }
      PreConsultationDoc: {
        payload: Prisma.$PreConsultationDocPayload<ExtArgs>
        fields: Prisma.PreConsultationDocFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PreConsultationDocFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreConsultationDocPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PreConsultationDocFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreConsultationDocPayload>
          }
          findFirst: {
            args: Prisma.PreConsultationDocFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreConsultationDocPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PreConsultationDocFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreConsultationDocPayload>
          }
          findMany: {
            args: Prisma.PreConsultationDocFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreConsultationDocPayload>[]
          }
          create: {
            args: Prisma.PreConsultationDocCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreConsultationDocPayload>
          }
          createMany: {
            args: Prisma.PreConsultationDocCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PreConsultationDocCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreConsultationDocPayload>[]
          }
          delete: {
            args: Prisma.PreConsultationDocDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreConsultationDocPayload>
          }
          update: {
            args: Prisma.PreConsultationDocUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreConsultationDocPayload>
          }
          deleteMany: {
            args: Prisma.PreConsultationDocDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PreConsultationDocUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PreConsultationDocUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreConsultationDocPayload>
          }
          aggregate: {
            args: Prisma.PreConsultationDocAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreConsultationDoc>
          }
          groupBy: {
            args: Prisma.PreConsultationDocGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreConsultationDocGroupByOutputType>[]
          }
          count: {
            args: Prisma.PreConsultationDocCountArgs<ExtArgs>
            result: $Utils.Optional<PreConsultationDocCountAggregateOutputType> | number
          }
        }
      }
      ConsultationDialog: {
        payload: Prisma.$ConsultationDialogPayload<ExtArgs>
        fields: Prisma.ConsultationDialogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsultationDialogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationDialogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsultationDialogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationDialogPayload>
          }
          findFirst: {
            args: Prisma.ConsultationDialogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationDialogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsultationDialogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationDialogPayload>
          }
          findMany: {
            args: Prisma.ConsultationDialogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationDialogPayload>[]
          }
          create: {
            args: Prisma.ConsultationDialogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationDialogPayload>
          }
          createMany: {
            args: Prisma.ConsultationDialogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsultationDialogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationDialogPayload>[]
          }
          delete: {
            args: Prisma.ConsultationDialogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationDialogPayload>
          }
          update: {
            args: Prisma.ConsultationDialogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationDialogPayload>
          }
          deleteMany: {
            args: Prisma.ConsultationDialogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsultationDialogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConsultationDialogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationDialogPayload>
          }
          aggregate: {
            args: Prisma.ConsultationDialogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultationDialog>
          }
          groupBy: {
            args: Prisma.ConsultationDialogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultationDialogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsultationDialogCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultationDialogCountAggregateOutputType> | number
          }
        }
      }
      PostConsultationDoc: {
        payload: Prisma.$PostConsultationDocPayload<ExtArgs>
        fields: Prisma.PostConsultationDocFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostConsultationDocFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostConsultationDocPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostConsultationDocFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostConsultationDocPayload>
          }
          findFirst: {
            args: Prisma.PostConsultationDocFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostConsultationDocPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostConsultationDocFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostConsultationDocPayload>
          }
          findMany: {
            args: Prisma.PostConsultationDocFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostConsultationDocPayload>[]
          }
          create: {
            args: Prisma.PostConsultationDocCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostConsultationDocPayload>
          }
          createMany: {
            args: Prisma.PostConsultationDocCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostConsultationDocCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostConsultationDocPayload>[]
          }
          delete: {
            args: Prisma.PostConsultationDocDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostConsultationDocPayload>
          }
          update: {
            args: Prisma.PostConsultationDocUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostConsultationDocPayload>
          }
          deleteMany: {
            args: Prisma.PostConsultationDocDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostConsultationDocUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostConsultationDocUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostConsultationDocPayload>
          }
          aggregate: {
            args: Prisma.PostConsultationDocAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostConsultationDoc>
          }
          groupBy: {
            args: Prisma.PostConsultationDocGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostConsultationDocGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostConsultationDocCountArgs<ExtArgs>
            result: $Utils.Optional<PostConsultationDocCountAggregateOutputType> | number
          }
        }
      }
      ExpertOpinion: {
        payload: Prisma.$ExpertOpinionPayload<ExtArgs>
        fields: Prisma.ExpertOpinionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpertOpinionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertOpinionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpertOpinionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertOpinionPayload>
          }
          findFirst: {
            args: Prisma.ExpertOpinionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertOpinionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpertOpinionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertOpinionPayload>
          }
          findMany: {
            args: Prisma.ExpertOpinionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertOpinionPayload>[]
          }
          create: {
            args: Prisma.ExpertOpinionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertOpinionPayload>
          }
          createMany: {
            args: Prisma.ExpertOpinionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpertOpinionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertOpinionPayload>[]
          }
          delete: {
            args: Prisma.ExpertOpinionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertOpinionPayload>
          }
          update: {
            args: Prisma.ExpertOpinionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertOpinionPayload>
          }
          deleteMany: {
            args: Prisma.ExpertOpinionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpertOpinionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpertOpinionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpertOpinionPayload>
          }
          aggregate: {
            args: Prisma.ExpertOpinionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpertOpinion>
          }
          groupBy: {
            args: Prisma.ExpertOpinionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpertOpinionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpertOpinionCountArgs<ExtArgs>
            result: $Utils.Optional<ExpertOpinionCountAggregateOutputType> | number
          }
        }
      }
      ConsultationReport: {
        payload: Prisma.$ConsultationReportPayload<ExtArgs>
        fields: Prisma.ConsultationReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsultationReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsultationReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationReportPayload>
          }
          findFirst: {
            args: Prisma.ConsultationReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsultationReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationReportPayload>
          }
          findMany: {
            args: Prisma.ConsultationReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationReportPayload>[]
          }
          create: {
            args: Prisma.ConsultationReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationReportPayload>
          }
          createMany: {
            args: Prisma.ConsultationReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsultationReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationReportPayload>[]
          }
          delete: {
            args: Prisma.ConsultationReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationReportPayload>
          }
          update: {
            args: Prisma.ConsultationReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationReportPayload>
          }
          deleteMany: {
            args: Prisma.ConsultationReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsultationReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConsultationReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationReportPayload>
          }
          aggregate: {
            args: Prisma.ConsultationReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultationReport>
          }
          groupBy: {
            args: Prisma.ConsultationReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultationReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsultationReportCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultationReportCountAggregateOutputType> | number
          }
        }
      }
      TaskLog: {
        payload: Prisma.$TaskLogPayload<ExtArgs>
        fields: Prisma.TaskLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload>
          }
          findFirst: {
            args: Prisma.TaskLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload>
          }
          findMany: {
            args: Prisma.TaskLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload>[]
          }
          create: {
            args: Prisma.TaskLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload>
          }
          createMany: {
            args: Prisma.TaskLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload>[]
          }
          delete: {
            args: Prisma.TaskLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload>
          }
          update: {
            args: Prisma.TaskLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload>
          }
          deleteMany: {
            args: Prisma.TaskLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskLogPayload>
          }
          aggregate: {
            args: Prisma.TaskLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskLog>
          }
          groupBy: {
            args: Prisma.TaskLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskLogCountArgs<ExtArgs>
            result: $Utils.Optional<TaskLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    expertTasks: number
    logs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expertTasks?: boolean | UserCountOutputTypeCountExpertTasksArgs
    logs?: boolean | UserCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExpertTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskExpertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLogWhereInput
  }


  /**
   * Count Type ExpertProfileCountOutputType
   */

  export type ExpertProfileCountOutputType = {
    opinions: number
  }

  export type ExpertProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opinions?: boolean | ExpertProfileCountOutputTypeCountOpinionsArgs
  }

  // Custom InputTypes
  /**
   * ExpertProfileCountOutputType without action
   */
  export type ExpertProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertProfileCountOutputType
     */
    select?: ExpertProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpertProfileCountOutputType without action
   */
  export type ExpertProfileCountOutputTypeCountOpinionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpertOpinionWhereInput
  }


  /**
   * Count Type ConsultationTaskCountOutputType
   */

  export type ConsultationTaskCountOutputType = {
    dialogs: number
    opinions: number
    experts: number
    logs: number
  }

  export type ConsultationTaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dialogs?: boolean | ConsultationTaskCountOutputTypeCountDialogsArgs
    opinions?: boolean | ConsultationTaskCountOutputTypeCountOpinionsArgs
    experts?: boolean | ConsultationTaskCountOutputTypeCountExpertsArgs
    logs?: boolean | ConsultationTaskCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * ConsultationTaskCountOutputType without action
   */
  export type ConsultationTaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationTaskCountOutputType
     */
    select?: ConsultationTaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConsultationTaskCountOutputType without action
   */
  export type ConsultationTaskCountOutputTypeCountDialogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationDialogWhereInput
  }

  /**
   * ConsultationTaskCountOutputType without action
   */
  export type ConsultationTaskCountOutputTypeCountOpinionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpertOpinionWhereInput
  }

  /**
   * ConsultationTaskCountOutputType without action
   */
  export type ConsultationTaskCountOutputTypeCountExpertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskExpertWhereInput
  }

  /**
   * ConsultationTaskCountOutputType without action
   */
  export type ConsultationTaskCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    realName: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    realName: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    realName: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    realName?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    realName?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    realName?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    password: string
    realName: string
    role: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    realName?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expertProfile?: boolean | User$expertProfileArgs<ExtArgs>
    expertTasks?: boolean | User$expertTasksArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    realName?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    realName?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expertProfile?: boolean | User$expertProfileArgs<ExtArgs>
    expertTasks?: boolean | User$expertTasksArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      expertProfile: Prisma.$ExpertProfilePayload<ExtArgs> | null
      expertTasks: Prisma.$TaskExpertPayload<ExtArgs>[]
      logs: Prisma.$TaskLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      password: string
      realName: string
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expertProfile<T extends User$expertProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$expertProfileArgs<ExtArgs>>): Prisma__ExpertProfileClient<$Result.GetResult<Prisma.$ExpertProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    expertTasks<T extends User$expertTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$expertTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskExpertPayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends User$logsArgs<ExtArgs> = {}>(args?: Subset<T, User$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly realName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.expertProfile
   */
  export type User$expertProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertProfile
     */
    select?: ExpertProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertProfileInclude<ExtArgs> | null
    where?: ExpertProfileWhereInput
  }

  /**
   * User.expertTasks
   */
  export type User$expertTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExpert
     */
    select?: TaskExpertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskExpertInclude<ExtArgs> | null
    where?: TaskExpertWhereInput
    orderBy?: TaskExpertOrderByWithRelationInput | TaskExpertOrderByWithRelationInput[]
    cursor?: TaskExpertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskExpertScalarFieldEnum | TaskExpertScalarFieldEnum[]
  }

  /**
   * User.logs
   */
  export type User$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    where?: TaskLogWhereInput
    orderBy?: TaskLogOrderByWithRelationInput | TaskLogOrderByWithRelationInput[]
    cursor?: TaskLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskLogScalarFieldEnum | TaskLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ExpertProfile
   */

  export type AggregateExpertProfile = {
    _count: ExpertProfileCountAggregateOutputType | null
    _min: ExpertProfileMinAggregateOutputType | null
    _max: ExpertProfileMaxAggregateOutputType | null
  }

  export type ExpertProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    department: string | null
    titles: string | null
    signatureUrl: string | null
  }

  export type ExpertProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    department: string | null
    titles: string | null
    signatureUrl: string | null
  }

  export type ExpertProfileCountAggregateOutputType = {
    id: number
    userId: number
    department: number
    titles: number
    signatureUrl: number
    _all: number
  }


  export type ExpertProfileMinAggregateInputType = {
    id?: true
    userId?: true
    department?: true
    titles?: true
    signatureUrl?: true
  }

  export type ExpertProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    department?: true
    titles?: true
    signatureUrl?: true
  }

  export type ExpertProfileCountAggregateInputType = {
    id?: true
    userId?: true
    department?: true
    titles?: true
    signatureUrl?: true
    _all?: true
  }

  export type ExpertProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpertProfile to aggregate.
     */
    where?: ExpertProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpertProfiles to fetch.
     */
    orderBy?: ExpertProfileOrderByWithRelationInput | ExpertProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpertProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpertProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpertProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpertProfiles
    **/
    _count?: true | ExpertProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpertProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpertProfileMaxAggregateInputType
  }

  export type GetExpertProfileAggregateType<T extends ExpertProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateExpertProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpertProfile[P]>
      : GetScalarType<T[P], AggregateExpertProfile[P]>
  }




  export type ExpertProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpertProfileWhereInput
    orderBy?: ExpertProfileOrderByWithAggregationInput | ExpertProfileOrderByWithAggregationInput[]
    by: ExpertProfileScalarFieldEnum[] | ExpertProfileScalarFieldEnum
    having?: ExpertProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpertProfileCountAggregateInputType | true
    _min?: ExpertProfileMinAggregateInputType
    _max?: ExpertProfileMaxAggregateInputType
  }

  export type ExpertProfileGroupByOutputType = {
    id: string
    userId: string
    department: string
    titles: string
    signatureUrl: string | null
    _count: ExpertProfileCountAggregateOutputType | null
    _min: ExpertProfileMinAggregateOutputType | null
    _max: ExpertProfileMaxAggregateOutputType | null
  }

  type GetExpertProfileGroupByPayload<T extends ExpertProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpertProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpertProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpertProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ExpertProfileGroupByOutputType[P]>
        }
      >
    >


  export type ExpertProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    department?: boolean
    titles?: boolean
    signatureUrl?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    opinions?: boolean | ExpertProfile$opinionsArgs<ExtArgs>
    _count?: boolean | ExpertProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expertProfile"]>

  export type ExpertProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    department?: boolean
    titles?: boolean
    signatureUrl?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expertProfile"]>

  export type ExpertProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    department?: boolean
    titles?: boolean
    signatureUrl?: boolean
  }

  export type ExpertProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    opinions?: boolean | ExpertProfile$opinionsArgs<ExtArgs>
    _count?: boolean | ExpertProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpertProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExpertProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpertProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      opinions: Prisma.$ExpertOpinionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      department: string
      titles: string
      signatureUrl: string | null
    }, ExtArgs["result"]["expertProfile"]>
    composites: {}
  }

  type ExpertProfileGetPayload<S extends boolean | null | undefined | ExpertProfileDefaultArgs> = $Result.GetResult<Prisma.$ExpertProfilePayload, S>

  type ExpertProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpertProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpertProfileCountAggregateInputType | true
    }

  export interface ExpertProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpertProfile'], meta: { name: 'ExpertProfile' } }
    /**
     * Find zero or one ExpertProfile that matches the filter.
     * @param {ExpertProfileFindUniqueArgs} args - Arguments to find a ExpertProfile
     * @example
     * // Get one ExpertProfile
     * const expertProfile = await prisma.expertProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpertProfileFindUniqueArgs>(args: SelectSubset<T, ExpertProfileFindUniqueArgs<ExtArgs>>): Prisma__ExpertProfileClient<$Result.GetResult<Prisma.$ExpertProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExpertProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpertProfileFindUniqueOrThrowArgs} args - Arguments to find a ExpertProfile
     * @example
     * // Get one ExpertProfile
     * const expertProfile = await prisma.expertProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpertProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpertProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpertProfileClient<$Result.GetResult<Prisma.$ExpertProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExpertProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertProfileFindFirstArgs} args - Arguments to find a ExpertProfile
     * @example
     * // Get one ExpertProfile
     * const expertProfile = await prisma.expertProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpertProfileFindFirstArgs>(args?: SelectSubset<T, ExpertProfileFindFirstArgs<ExtArgs>>): Prisma__ExpertProfileClient<$Result.GetResult<Prisma.$ExpertProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExpertProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertProfileFindFirstOrThrowArgs} args - Arguments to find a ExpertProfile
     * @example
     * // Get one ExpertProfile
     * const expertProfile = await prisma.expertProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpertProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpertProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpertProfileClient<$Result.GetResult<Prisma.$ExpertProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExpertProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpertProfiles
     * const expertProfiles = await prisma.expertProfile.findMany()
     * 
     * // Get first 10 ExpertProfiles
     * const expertProfiles = await prisma.expertProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expertProfileWithIdOnly = await prisma.expertProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpertProfileFindManyArgs>(args?: SelectSubset<T, ExpertProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpertProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExpertProfile.
     * @param {ExpertProfileCreateArgs} args - Arguments to create a ExpertProfile.
     * @example
     * // Create one ExpertProfile
     * const ExpertProfile = await prisma.expertProfile.create({
     *   data: {
     *     // ... data to create a ExpertProfile
     *   }
     * })
     * 
     */
    create<T extends ExpertProfileCreateArgs>(args: SelectSubset<T, ExpertProfileCreateArgs<ExtArgs>>): Prisma__ExpertProfileClient<$Result.GetResult<Prisma.$ExpertProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExpertProfiles.
     * @param {ExpertProfileCreateManyArgs} args - Arguments to create many ExpertProfiles.
     * @example
     * // Create many ExpertProfiles
     * const expertProfile = await prisma.expertProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpertProfileCreateManyArgs>(args?: SelectSubset<T, ExpertProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpertProfiles and returns the data saved in the database.
     * @param {ExpertProfileCreateManyAndReturnArgs} args - Arguments to create many ExpertProfiles.
     * @example
     * // Create many ExpertProfiles
     * const expertProfile = await prisma.expertProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpertProfiles and only return the `id`
     * const expertProfileWithIdOnly = await prisma.expertProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpertProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpertProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpertProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExpertProfile.
     * @param {ExpertProfileDeleteArgs} args - Arguments to delete one ExpertProfile.
     * @example
     * // Delete one ExpertProfile
     * const ExpertProfile = await prisma.expertProfile.delete({
     *   where: {
     *     // ... filter to delete one ExpertProfile
     *   }
     * })
     * 
     */
    delete<T extends ExpertProfileDeleteArgs>(args: SelectSubset<T, ExpertProfileDeleteArgs<ExtArgs>>): Prisma__ExpertProfileClient<$Result.GetResult<Prisma.$ExpertProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExpertProfile.
     * @param {ExpertProfileUpdateArgs} args - Arguments to update one ExpertProfile.
     * @example
     * // Update one ExpertProfile
     * const expertProfile = await prisma.expertProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpertProfileUpdateArgs>(args: SelectSubset<T, ExpertProfileUpdateArgs<ExtArgs>>): Prisma__ExpertProfileClient<$Result.GetResult<Prisma.$ExpertProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExpertProfiles.
     * @param {ExpertProfileDeleteManyArgs} args - Arguments to filter ExpertProfiles to delete.
     * @example
     * // Delete a few ExpertProfiles
     * const { count } = await prisma.expertProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpertProfileDeleteManyArgs>(args?: SelectSubset<T, ExpertProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpertProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpertProfiles
     * const expertProfile = await prisma.expertProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpertProfileUpdateManyArgs>(args: SelectSubset<T, ExpertProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExpertProfile.
     * @param {ExpertProfileUpsertArgs} args - Arguments to update or create a ExpertProfile.
     * @example
     * // Update or create a ExpertProfile
     * const expertProfile = await prisma.expertProfile.upsert({
     *   create: {
     *     // ... data to create a ExpertProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpertProfile we want to update
     *   }
     * })
     */
    upsert<T extends ExpertProfileUpsertArgs>(args: SelectSubset<T, ExpertProfileUpsertArgs<ExtArgs>>): Prisma__ExpertProfileClient<$Result.GetResult<Prisma.$ExpertProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExpertProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertProfileCountArgs} args - Arguments to filter ExpertProfiles to count.
     * @example
     * // Count the number of ExpertProfiles
     * const count = await prisma.expertProfile.count({
     *   where: {
     *     // ... the filter for the ExpertProfiles we want to count
     *   }
     * })
    **/
    count<T extends ExpertProfileCountArgs>(
      args?: Subset<T, ExpertProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpertProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpertProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpertProfileAggregateArgs>(args: Subset<T, ExpertProfileAggregateArgs>): Prisma.PrismaPromise<GetExpertProfileAggregateType<T>>

    /**
     * Group by ExpertProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpertProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpertProfileGroupByArgs['orderBy'] }
        : { orderBy?: ExpertProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpertProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpertProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpertProfile model
   */
  readonly fields: ExpertProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpertProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpertProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    opinions<T extends ExpertProfile$opinionsArgs<ExtArgs> = {}>(args?: Subset<T, ExpertProfile$opinionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpertOpinionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpertProfile model
   */ 
  interface ExpertProfileFieldRefs {
    readonly id: FieldRef<"ExpertProfile", 'String'>
    readonly userId: FieldRef<"ExpertProfile", 'String'>
    readonly department: FieldRef<"ExpertProfile", 'String'>
    readonly titles: FieldRef<"ExpertProfile", 'String'>
    readonly signatureUrl: FieldRef<"ExpertProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ExpertProfile findUnique
   */
  export type ExpertProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertProfile
     */
    select?: ExpertProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertProfileInclude<ExtArgs> | null
    /**
     * Filter, which ExpertProfile to fetch.
     */
    where: ExpertProfileWhereUniqueInput
  }

  /**
   * ExpertProfile findUniqueOrThrow
   */
  export type ExpertProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertProfile
     */
    select?: ExpertProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertProfileInclude<ExtArgs> | null
    /**
     * Filter, which ExpertProfile to fetch.
     */
    where: ExpertProfileWhereUniqueInput
  }

  /**
   * ExpertProfile findFirst
   */
  export type ExpertProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertProfile
     */
    select?: ExpertProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertProfileInclude<ExtArgs> | null
    /**
     * Filter, which ExpertProfile to fetch.
     */
    where?: ExpertProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpertProfiles to fetch.
     */
    orderBy?: ExpertProfileOrderByWithRelationInput | ExpertProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpertProfiles.
     */
    cursor?: ExpertProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpertProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpertProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpertProfiles.
     */
    distinct?: ExpertProfileScalarFieldEnum | ExpertProfileScalarFieldEnum[]
  }

  /**
   * ExpertProfile findFirstOrThrow
   */
  export type ExpertProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertProfile
     */
    select?: ExpertProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertProfileInclude<ExtArgs> | null
    /**
     * Filter, which ExpertProfile to fetch.
     */
    where?: ExpertProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpertProfiles to fetch.
     */
    orderBy?: ExpertProfileOrderByWithRelationInput | ExpertProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpertProfiles.
     */
    cursor?: ExpertProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpertProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpertProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpertProfiles.
     */
    distinct?: ExpertProfileScalarFieldEnum | ExpertProfileScalarFieldEnum[]
  }

  /**
   * ExpertProfile findMany
   */
  export type ExpertProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertProfile
     */
    select?: ExpertProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertProfileInclude<ExtArgs> | null
    /**
     * Filter, which ExpertProfiles to fetch.
     */
    where?: ExpertProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpertProfiles to fetch.
     */
    orderBy?: ExpertProfileOrderByWithRelationInput | ExpertProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpertProfiles.
     */
    cursor?: ExpertProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpertProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpertProfiles.
     */
    skip?: number
    distinct?: ExpertProfileScalarFieldEnum | ExpertProfileScalarFieldEnum[]
  }

  /**
   * ExpertProfile create
   */
  export type ExpertProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertProfile
     */
    select?: ExpertProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpertProfile.
     */
    data: XOR<ExpertProfileCreateInput, ExpertProfileUncheckedCreateInput>
  }

  /**
   * ExpertProfile createMany
   */
  export type ExpertProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpertProfiles.
     */
    data: ExpertProfileCreateManyInput | ExpertProfileCreateManyInput[]
  }

  /**
   * ExpertProfile createManyAndReturn
   */
  export type ExpertProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertProfile
     */
    select?: ExpertProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExpertProfiles.
     */
    data: ExpertProfileCreateManyInput | ExpertProfileCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpertProfile update
   */
  export type ExpertProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertProfile
     */
    select?: ExpertProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpertProfile.
     */
    data: XOR<ExpertProfileUpdateInput, ExpertProfileUncheckedUpdateInput>
    /**
     * Choose, which ExpertProfile to update.
     */
    where: ExpertProfileWhereUniqueInput
  }

  /**
   * ExpertProfile updateMany
   */
  export type ExpertProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpertProfiles.
     */
    data: XOR<ExpertProfileUpdateManyMutationInput, ExpertProfileUncheckedUpdateManyInput>
    /**
     * Filter which ExpertProfiles to update
     */
    where?: ExpertProfileWhereInput
  }

  /**
   * ExpertProfile upsert
   */
  export type ExpertProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertProfile
     */
    select?: ExpertProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpertProfile to update in case it exists.
     */
    where: ExpertProfileWhereUniqueInput
    /**
     * In case the ExpertProfile found by the `where` argument doesn't exist, create a new ExpertProfile with this data.
     */
    create: XOR<ExpertProfileCreateInput, ExpertProfileUncheckedCreateInput>
    /**
     * In case the ExpertProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpertProfileUpdateInput, ExpertProfileUncheckedUpdateInput>
  }

  /**
   * ExpertProfile delete
   */
  export type ExpertProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertProfile
     */
    select?: ExpertProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertProfileInclude<ExtArgs> | null
    /**
     * Filter which ExpertProfile to delete.
     */
    where: ExpertProfileWhereUniqueInput
  }

  /**
   * ExpertProfile deleteMany
   */
  export type ExpertProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpertProfiles to delete
     */
    where?: ExpertProfileWhereInput
  }

  /**
   * ExpertProfile.opinions
   */
  export type ExpertProfile$opinionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertOpinion
     */
    select?: ExpertOpinionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertOpinionInclude<ExtArgs> | null
    where?: ExpertOpinionWhereInput
    orderBy?: ExpertOpinionOrderByWithRelationInput | ExpertOpinionOrderByWithRelationInput[]
    cursor?: ExpertOpinionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpertOpinionScalarFieldEnum | ExpertOpinionScalarFieldEnum[]
  }

  /**
   * ExpertProfile without action
   */
  export type ExpertProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertProfile
     */
    select?: ExpertProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertProfileInclude<ExtArgs> | null
  }


  /**
   * Model ConsultationTask
   */

  export type AggregateConsultationTask = {
    _count: ConsultationTaskCountAggregateOutputType | null
    _avg: ConsultationTaskAvgAggregateOutputType | null
    _sum: ConsultationTaskSumAggregateOutputType | null
    _min: ConsultationTaskMinAggregateOutputType | null
    _max: ConsultationTaskMaxAggregateOutputType | null
  }

  export type ConsultationTaskAvgAggregateOutputType = {
    patientAge: number | null
  }

  export type ConsultationTaskSumAggregateOutputType = {
    patientAge: number | null
  }

  export type ConsultationTaskMinAggregateOutputType = {
    id: string | null
    status: string | null
    scheduledTime: Date | null
    patientName: string | null
    patientGender: string | null
    patientAge: number | null
    chiefComplaint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultationTaskMaxAggregateOutputType = {
    id: string | null
    status: string | null
    scheduledTime: Date | null
    patientName: string | null
    patientGender: string | null
    patientAge: number | null
    chiefComplaint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultationTaskCountAggregateOutputType = {
    id: number
    status: number
    scheduledTime: number
    patientName: number
    patientGender: number
    patientAge: number
    chiefComplaint: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConsultationTaskAvgAggregateInputType = {
    patientAge?: true
  }

  export type ConsultationTaskSumAggregateInputType = {
    patientAge?: true
  }

  export type ConsultationTaskMinAggregateInputType = {
    id?: true
    status?: true
    scheduledTime?: true
    patientName?: true
    patientGender?: true
    patientAge?: true
    chiefComplaint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultationTaskMaxAggregateInputType = {
    id?: true
    status?: true
    scheduledTime?: true
    patientName?: true
    patientGender?: true
    patientAge?: true
    chiefComplaint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultationTaskCountAggregateInputType = {
    id?: true
    status?: true
    scheduledTime?: true
    patientName?: true
    patientGender?: true
    patientAge?: true
    chiefComplaint?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConsultationTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsultationTask to aggregate.
     */
    where?: ConsultationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationTasks to fetch.
     */
    orderBy?: ConsultationTaskOrderByWithRelationInput | ConsultationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsultationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConsultationTasks
    **/
    _count?: true | ConsultationTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsultationTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsultationTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultationTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultationTaskMaxAggregateInputType
  }

  export type GetConsultationTaskAggregateType<T extends ConsultationTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultationTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultationTask[P]>
      : GetScalarType<T[P], AggregateConsultationTask[P]>
  }




  export type ConsultationTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationTaskWhereInput
    orderBy?: ConsultationTaskOrderByWithAggregationInput | ConsultationTaskOrderByWithAggregationInput[]
    by: ConsultationTaskScalarFieldEnum[] | ConsultationTaskScalarFieldEnum
    having?: ConsultationTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultationTaskCountAggregateInputType | true
    _avg?: ConsultationTaskAvgAggregateInputType
    _sum?: ConsultationTaskSumAggregateInputType
    _min?: ConsultationTaskMinAggregateInputType
    _max?: ConsultationTaskMaxAggregateInputType
  }

  export type ConsultationTaskGroupByOutputType = {
    id: string
    status: string
    scheduledTime: Date
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt: Date
    updatedAt: Date
    _count: ConsultationTaskCountAggregateOutputType | null
    _avg: ConsultationTaskAvgAggregateOutputType | null
    _sum: ConsultationTaskSumAggregateOutputType | null
    _min: ConsultationTaskMinAggregateOutputType | null
    _max: ConsultationTaskMaxAggregateOutputType | null
  }

  type GetConsultationTaskGroupByPayload<T extends ConsultationTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultationTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultationTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultationTaskGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultationTaskGroupByOutputType[P]>
        }
      >
    >


  export type ConsultationTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    scheduledTime?: boolean
    patientName?: boolean
    patientGender?: boolean
    patientAge?: boolean
    chiefComplaint?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preDoc?: boolean | ConsultationTask$preDocArgs<ExtArgs>
    dialogs?: boolean | ConsultationTask$dialogsArgs<ExtArgs>
    postDoc?: boolean | ConsultationTask$postDocArgs<ExtArgs>
    opinions?: boolean | ConsultationTask$opinionsArgs<ExtArgs>
    report?: boolean | ConsultationTask$reportArgs<ExtArgs>
    experts?: boolean | ConsultationTask$expertsArgs<ExtArgs>
    logs?: boolean | ConsultationTask$logsArgs<ExtArgs>
    _count?: boolean | ConsultationTaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultationTask"]>

  export type ConsultationTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    scheduledTime?: boolean
    patientName?: boolean
    patientGender?: boolean
    patientAge?: boolean
    chiefComplaint?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["consultationTask"]>

  export type ConsultationTaskSelectScalar = {
    id?: boolean
    status?: boolean
    scheduledTime?: boolean
    patientName?: boolean
    patientGender?: boolean
    patientAge?: boolean
    chiefComplaint?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConsultationTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    preDoc?: boolean | ConsultationTask$preDocArgs<ExtArgs>
    dialogs?: boolean | ConsultationTask$dialogsArgs<ExtArgs>
    postDoc?: boolean | ConsultationTask$postDocArgs<ExtArgs>
    opinions?: boolean | ConsultationTask$opinionsArgs<ExtArgs>
    report?: boolean | ConsultationTask$reportArgs<ExtArgs>
    experts?: boolean | ConsultationTask$expertsArgs<ExtArgs>
    logs?: boolean | ConsultationTask$logsArgs<ExtArgs>
    _count?: boolean | ConsultationTaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConsultationTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConsultationTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConsultationTask"
    objects: {
      preDoc: Prisma.$PreConsultationDocPayload<ExtArgs> | null
      dialogs: Prisma.$ConsultationDialogPayload<ExtArgs>[]
      postDoc: Prisma.$PostConsultationDocPayload<ExtArgs> | null
      opinions: Prisma.$ExpertOpinionPayload<ExtArgs>[]
      report: Prisma.$ConsultationReportPayload<ExtArgs> | null
      experts: Prisma.$TaskExpertPayload<ExtArgs>[]
      logs: Prisma.$TaskLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      scheduledTime: Date
      patientName: string
      patientGender: string
      patientAge: number
      chiefComplaint: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["consultationTask"]>
    composites: {}
  }

  type ConsultationTaskGetPayload<S extends boolean | null | undefined | ConsultationTaskDefaultArgs> = $Result.GetResult<Prisma.$ConsultationTaskPayload, S>

  type ConsultationTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConsultationTaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConsultationTaskCountAggregateInputType | true
    }

  export interface ConsultationTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConsultationTask'], meta: { name: 'ConsultationTask' } }
    /**
     * Find zero or one ConsultationTask that matches the filter.
     * @param {ConsultationTaskFindUniqueArgs} args - Arguments to find a ConsultationTask
     * @example
     * // Get one ConsultationTask
     * const consultationTask = await prisma.consultationTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsultationTaskFindUniqueArgs>(args: SelectSubset<T, ConsultationTaskFindUniqueArgs<ExtArgs>>): Prisma__ConsultationTaskClient<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConsultationTask that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConsultationTaskFindUniqueOrThrowArgs} args - Arguments to find a ConsultationTask
     * @example
     * // Get one ConsultationTask
     * const consultationTask = await prisma.consultationTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsultationTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsultationTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsultationTaskClient<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConsultationTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationTaskFindFirstArgs} args - Arguments to find a ConsultationTask
     * @example
     * // Get one ConsultationTask
     * const consultationTask = await prisma.consultationTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsultationTaskFindFirstArgs>(args?: SelectSubset<T, ConsultationTaskFindFirstArgs<ExtArgs>>): Prisma__ConsultationTaskClient<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConsultationTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationTaskFindFirstOrThrowArgs} args - Arguments to find a ConsultationTask
     * @example
     * // Get one ConsultationTask
     * const consultationTask = await prisma.consultationTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsultationTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsultationTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsultationTaskClient<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConsultationTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsultationTasks
     * const consultationTasks = await prisma.consultationTask.findMany()
     * 
     * // Get first 10 ConsultationTasks
     * const consultationTasks = await prisma.consultationTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultationTaskWithIdOnly = await prisma.consultationTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsultationTaskFindManyArgs>(args?: SelectSubset<T, ConsultationTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConsultationTask.
     * @param {ConsultationTaskCreateArgs} args - Arguments to create a ConsultationTask.
     * @example
     * // Create one ConsultationTask
     * const ConsultationTask = await prisma.consultationTask.create({
     *   data: {
     *     // ... data to create a ConsultationTask
     *   }
     * })
     * 
     */
    create<T extends ConsultationTaskCreateArgs>(args: SelectSubset<T, ConsultationTaskCreateArgs<ExtArgs>>): Prisma__ConsultationTaskClient<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConsultationTasks.
     * @param {ConsultationTaskCreateManyArgs} args - Arguments to create many ConsultationTasks.
     * @example
     * // Create many ConsultationTasks
     * const consultationTask = await prisma.consultationTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsultationTaskCreateManyArgs>(args?: SelectSubset<T, ConsultationTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConsultationTasks and returns the data saved in the database.
     * @param {ConsultationTaskCreateManyAndReturnArgs} args - Arguments to create many ConsultationTasks.
     * @example
     * // Create many ConsultationTasks
     * const consultationTask = await prisma.consultationTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConsultationTasks and only return the `id`
     * const consultationTaskWithIdOnly = await prisma.consultationTask.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsultationTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsultationTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConsultationTask.
     * @param {ConsultationTaskDeleteArgs} args - Arguments to delete one ConsultationTask.
     * @example
     * // Delete one ConsultationTask
     * const ConsultationTask = await prisma.consultationTask.delete({
     *   where: {
     *     // ... filter to delete one ConsultationTask
     *   }
     * })
     * 
     */
    delete<T extends ConsultationTaskDeleteArgs>(args: SelectSubset<T, ConsultationTaskDeleteArgs<ExtArgs>>): Prisma__ConsultationTaskClient<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConsultationTask.
     * @param {ConsultationTaskUpdateArgs} args - Arguments to update one ConsultationTask.
     * @example
     * // Update one ConsultationTask
     * const consultationTask = await prisma.consultationTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsultationTaskUpdateArgs>(args: SelectSubset<T, ConsultationTaskUpdateArgs<ExtArgs>>): Prisma__ConsultationTaskClient<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConsultationTasks.
     * @param {ConsultationTaskDeleteManyArgs} args - Arguments to filter ConsultationTasks to delete.
     * @example
     * // Delete a few ConsultationTasks
     * const { count } = await prisma.consultationTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsultationTaskDeleteManyArgs>(args?: SelectSubset<T, ConsultationTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsultationTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsultationTasks
     * const consultationTask = await prisma.consultationTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsultationTaskUpdateManyArgs>(args: SelectSubset<T, ConsultationTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConsultationTask.
     * @param {ConsultationTaskUpsertArgs} args - Arguments to update or create a ConsultationTask.
     * @example
     * // Update or create a ConsultationTask
     * const consultationTask = await prisma.consultationTask.upsert({
     *   create: {
     *     // ... data to create a ConsultationTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsultationTask we want to update
     *   }
     * })
     */
    upsert<T extends ConsultationTaskUpsertArgs>(args: SelectSubset<T, ConsultationTaskUpsertArgs<ExtArgs>>): Prisma__ConsultationTaskClient<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConsultationTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationTaskCountArgs} args - Arguments to filter ConsultationTasks to count.
     * @example
     * // Count the number of ConsultationTasks
     * const count = await prisma.consultationTask.count({
     *   where: {
     *     // ... the filter for the ConsultationTasks we want to count
     *   }
     * })
    **/
    count<T extends ConsultationTaskCountArgs>(
      args?: Subset<T, ConsultationTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultationTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsultationTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultationTaskAggregateArgs>(args: Subset<T, ConsultationTaskAggregateArgs>): Prisma.PrismaPromise<GetConsultationTaskAggregateType<T>>

    /**
     * Group by ConsultationTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultationTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultationTaskGroupByArgs['orderBy'] }
        : { orderBy?: ConsultationTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultationTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultationTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConsultationTask model
   */
  readonly fields: ConsultationTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConsultationTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsultationTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    preDoc<T extends ConsultationTask$preDocArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationTask$preDocArgs<ExtArgs>>): Prisma__PreConsultationDocClient<$Result.GetResult<Prisma.$PreConsultationDocPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    dialogs<T extends ConsultationTask$dialogsArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationTask$dialogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationDialogPayload<ExtArgs>, T, "findMany"> | Null>
    postDoc<T extends ConsultationTask$postDocArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationTask$postDocArgs<ExtArgs>>): Prisma__PostConsultationDocClient<$Result.GetResult<Prisma.$PostConsultationDocPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    opinions<T extends ConsultationTask$opinionsArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationTask$opinionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpertOpinionPayload<ExtArgs>, T, "findMany"> | Null>
    report<T extends ConsultationTask$reportArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationTask$reportArgs<ExtArgs>>): Prisma__ConsultationReportClient<$Result.GetResult<Prisma.$ConsultationReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    experts<T extends ConsultationTask$expertsArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationTask$expertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskExpertPayload<ExtArgs>, T, "findMany"> | Null>
    logs<T extends ConsultationTask$logsArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationTask$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConsultationTask model
   */ 
  interface ConsultationTaskFieldRefs {
    readonly id: FieldRef<"ConsultationTask", 'String'>
    readonly status: FieldRef<"ConsultationTask", 'String'>
    readonly scheduledTime: FieldRef<"ConsultationTask", 'DateTime'>
    readonly patientName: FieldRef<"ConsultationTask", 'String'>
    readonly patientGender: FieldRef<"ConsultationTask", 'String'>
    readonly patientAge: FieldRef<"ConsultationTask", 'Int'>
    readonly chiefComplaint: FieldRef<"ConsultationTask", 'String'>
    readonly createdAt: FieldRef<"ConsultationTask", 'DateTime'>
    readonly updatedAt: FieldRef<"ConsultationTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConsultationTask findUnique
   */
  export type ConsultationTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationTask
     */
    select?: ConsultationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationTaskInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationTask to fetch.
     */
    where: ConsultationTaskWhereUniqueInput
  }

  /**
   * ConsultationTask findUniqueOrThrow
   */
  export type ConsultationTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationTask
     */
    select?: ConsultationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationTaskInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationTask to fetch.
     */
    where: ConsultationTaskWhereUniqueInput
  }

  /**
   * ConsultationTask findFirst
   */
  export type ConsultationTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationTask
     */
    select?: ConsultationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationTaskInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationTask to fetch.
     */
    where?: ConsultationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationTasks to fetch.
     */
    orderBy?: ConsultationTaskOrderByWithRelationInput | ConsultationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultationTasks.
     */
    cursor?: ConsultationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultationTasks.
     */
    distinct?: ConsultationTaskScalarFieldEnum | ConsultationTaskScalarFieldEnum[]
  }

  /**
   * ConsultationTask findFirstOrThrow
   */
  export type ConsultationTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationTask
     */
    select?: ConsultationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationTaskInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationTask to fetch.
     */
    where?: ConsultationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationTasks to fetch.
     */
    orderBy?: ConsultationTaskOrderByWithRelationInput | ConsultationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultationTasks.
     */
    cursor?: ConsultationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultationTasks.
     */
    distinct?: ConsultationTaskScalarFieldEnum | ConsultationTaskScalarFieldEnum[]
  }

  /**
   * ConsultationTask findMany
   */
  export type ConsultationTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationTask
     */
    select?: ConsultationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationTaskInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationTasks to fetch.
     */
    where?: ConsultationTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationTasks to fetch.
     */
    orderBy?: ConsultationTaskOrderByWithRelationInput | ConsultationTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConsultationTasks.
     */
    cursor?: ConsultationTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationTasks.
     */
    skip?: number
    distinct?: ConsultationTaskScalarFieldEnum | ConsultationTaskScalarFieldEnum[]
  }

  /**
   * ConsultationTask create
   */
  export type ConsultationTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationTask
     */
    select?: ConsultationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a ConsultationTask.
     */
    data: XOR<ConsultationTaskCreateInput, ConsultationTaskUncheckedCreateInput>
  }

  /**
   * ConsultationTask createMany
   */
  export type ConsultationTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConsultationTasks.
     */
    data: ConsultationTaskCreateManyInput | ConsultationTaskCreateManyInput[]
  }

  /**
   * ConsultationTask createManyAndReturn
   */
  export type ConsultationTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationTask
     */
    select?: ConsultationTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConsultationTasks.
     */
    data: ConsultationTaskCreateManyInput | ConsultationTaskCreateManyInput[]
  }

  /**
   * ConsultationTask update
   */
  export type ConsultationTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationTask
     */
    select?: ConsultationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a ConsultationTask.
     */
    data: XOR<ConsultationTaskUpdateInput, ConsultationTaskUncheckedUpdateInput>
    /**
     * Choose, which ConsultationTask to update.
     */
    where: ConsultationTaskWhereUniqueInput
  }

  /**
   * ConsultationTask updateMany
   */
  export type ConsultationTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConsultationTasks.
     */
    data: XOR<ConsultationTaskUpdateManyMutationInput, ConsultationTaskUncheckedUpdateManyInput>
    /**
     * Filter which ConsultationTasks to update
     */
    where?: ConsultationTaskWhereInput
  }

  /**
   * ConsultationTask upsert
   */
  export type ConsultationTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationTask
     */
    select?: ConsultationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the ConsultationTask to update in case it exists.
     */
    where: ConsultationTaskWhereUniqueInput
    /**
     * In case the ConsultationTask found by the `where` argument doesn't exist, create a new ConsultationTask with this data.
     */
    create: XOR<ConsultationTaskCreateInput, ConsultationTaskUncheckedCreateInput>
    /**
     * In case the ConsultationTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsultationTaskUpdateInput, ConsultationTaskUncheckedUpdateInput>
  }

  /**
   * ConsultationTask delete
   */
  export type ConsultationTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationTask
     */
    select?: ConsultationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationTaskInclude<ExtArgs> | null
    /**
     * Filter which ConsultationTask to delete.
     */
    where: ConsultationTaskWhereUniqueInput
  }

  /**
   * ConsultationTask deleteMany
   */
  export type ConsultationTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsultationTasks to delete
     */
    where?: ConsultationTaskWhereInput
  }

  /**
   * ConsultationTask.preDoc
   */
  export type ConsultationTask$preDocArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreConsultationDoc
     */
    select?: PreConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreConsultationDocInclude<ExtArgs> | null
    where?: PreConsultationDocWhereInput
  }

  /**
   * ConsultationTask.dialogs
   */
  export type ConsultationTask$dialogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDialog
     */
    select?: ConsultationDialogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationDialogInclude<ExtArgs> | null
    where?: ConsultationDialogWhereInput
    orderBy?: ConsultationDialogOrderByWithRelationInput | ConsultationDialogOrderByWithRelationInput[]
    cursor?: ConsultationDialogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultationDialogScalarFieldEnum | ConsultationDialogScalarFieldEnum[]
  }

  /**
   * ConsultationTask.postDoc
   */
  export type ConsultationTask$postDocArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostConsultationDoc
     */
    select?: PostConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostConsultationDocInclude<ExtArgs> | null
    where?: PostConsultationDocWhereInput
  }

  /**
   * ConsultationTask.opinions
   */
  export type ConsultationTask$opinionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertOpinion
     */
    select?: ExpertOpinionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertOpinionInclude<ExtArgs> | null
    where?: ExpertOpinionWhereInput
    orderBy?: ExpertOpinionOrderByWithRelationInput | ExpertOpinionOrderByWithRelationInput[]
    cursor?: ExpertOpinionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpertOpinionScalarFieldEnum | ExpertOpinionScalarFieldEnum[]
  }

  /**
   * ConsultationTask.report
   */
  export type ConsultationTask$reportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationReport
     */
    select?: ConsultationReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationReportInclude<ExtArgs> | null
    where?: ConsultationReportWhereInput
  }

  /**
   * ConsultationTask.experts
   */
  export type ConsultationTask$expertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExpert
     */
    select?: TaskExpertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskExpertInclude<ExtArgs> | null
    where?: TaskExpertWhereInput
    orderBy?: TaskExpertOrderByWithRelationInput | TaskExpertOrderByWithRelationInput[]
    cursor?: TaskExpertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskExpertScalarFieldEnum | TaskExpertScalarFieldEnum[]
  }

  /**
   * ConsultationTask.logs
   */
  export type ConsultationTask$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    where?: TaskLogWhereInput
    orderBy?: TaskLogOrderByWithRelationInput | TaskLogOrderByWithRelationInput[]
    cursor?: TaskLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskLogScalarFieldEnum | TaskLogScalarFieldEnum[]
  }

  /**
   * ConsultationTask without action
   */
  export type ConsultationTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationTask
     */
    select?: ConsultationTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationTaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskExpert
   */

  export type AggregateTaskExpert = {
    _count: TaskExpertCountAggregateOutputType | null
    _min: TaskExpertMinAggregateOutputType | null
    _max: TaskExpertMaxAggregateOutputType | null
  }

  export type TaskExpertMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    expertId: string | null
    status: string | null
    isCore: boolean | null
    invitedAt: Date | null
    respondedAt: Date | null
  }

  export type TaskExpertMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    expertId: string | null
    status: string | null
    isCore: boolean | null
    invitedAt: Date | null
    respondedAt: Date | null
  }

  export type TaskExpertCountAggregateOutputType = {
    id: number
    taskId: number
    expertId: number
    status: number
    isCore: number
    invitedAt: number
    respondedAt: number
    _all: number
  }


  export type TaskExpertMinAggregateInputType = {
    id?: true
    taskId?: true
    expertId?: true
    status?: true
    isCore?: true
    invitedAt?: true
    respondedAt?: true
  }

  export type TaskExpertMaxAggregateInputType = {
    id?: true
    taskId?: true
    expertId?: true
    status?: true
    isCore?: true
    invitedAt?: true
    respondedAt?: true
  }

  export type TaskExpertCountAggregateInputType = {
    id?: true
    taskId?: true
    expertId?: true
    status?: true
    isCore?: true
    invitedAt?: true
    respondedAt?: true
    _all?: true
  }

  export type TaskExpertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskExpert to aggregate.
     */
    where?: TaskExpertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskExperts to fetch.
     */
    orderBy?: TaskExpertOrderByWithRelationInput | TaskExpertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskExpertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskExperts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskExperts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskExperts
    **/
    _count?: true | TaskExpertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskExpertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskExpertMaxAggregateInputType
  }

  export type GetTaskExpertAggregateType<T extends TaskExpertAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskExpert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskExpert[P]>
      : GetScalarType<T[P], AggregateTaskExpert[P]>
  }




  export type TaskExpertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskExpertWhereInput
    orderBy?: TaskExpertOrderByWithAggregationInput | TaskExpertOrderByWithAggregationInput[]
    by: TaskExpertScalarFieldEnum[] | TaskExpertScalarFieldEnum
    having?: TaskExpertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskExpertCountAggregateInputType | true
    _min?: TaskExpertMinAggregateInputType
    _max?: TaskExpertMaxAggregateInputType
  }

  export type TaskExpertGroupByOutputType = {
    id: string
    taskId: string
    expertId: string
    status: string
    isCore: boolean
    invitedAt: Date
    respondedAt: Date | null
    _count: TaskExpertCountAggregateOutputType | null
    _min: TaskExpertMinAggregateOutputType | null
    _max: TaskExpertMaxAggregateOutputType | null
  }

  type GetTaskExpertGroupByPayload<T extends TaskExpertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskExpertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskExpertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskExpertGroupByOutputType[P]>
            : GetScalarType<T[P], TaskExpertGroupByOutputType[P]>
        }
      >
    >


  export type TaskExpertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    expertId?: boolean
    status?: boolean
    isCore?: boolean
    invitedAt?: boolean
    respondedAt?: boolean
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
    expert?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskExpert"]>

  export type TaskExpertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    expertId?: boolean
    status?: boolean
    isCore?: boolean
    invitedAt?: boolean
    respondedAt?: boolean
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
    expert?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskExpert"]>

  export type TaskExpertSelectScalar = {
    id?: boolean
    taskId?: boolean
    expertId?: boolean
    status?: boolean
    isCore?: boolean
    invitedAt?: boolean
    respondedAt?: boolean
  }

  export type TaskExpertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
    expert?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TaskExpertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
    expert?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TaskExpertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskExpert"
    objects: {
      task: Prisma.$ConsultationTaskPayload<ExtArgs>
      expert: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      expertId: string
      status: string
      isCore: boolean
      invitedAt: Date
      respondedAt: Date | null
    }, ExtArgs["result"]["taskExpert"]>
    composites: {}
  }

  type TaskExpertGetPayload<S extends boolean | null | undefined | TaskExpertDefaultArgs> = $Result.GetResult<Prisma.$TaskExpertPayload, S>

  type TaskExpertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskExpertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskExpertCountAggregateInputType | true
    }

  export interface TaskExpertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskExpert'], meta: { name: 'TaskExpert' } }
    /**
     * Find zero or one TaskExpert that matches the filter.
     * @param {TaskExpertFindUniqueArgs} args - Arguments to find a TaskExpert
     * @example
     * // Get one TaskExpert
     * const taskExpert = await prisma.taskExpert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskExpertFindUniqueArgs>(args: SelectSubset<T, TaskExpertFindUniqueArgs<ExtArgs>>): Prisma__TaskExpertClient<$Result.GetResult<Prisma.$TaskExpertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskExpert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskExpertFindUniqueOrThrowArgs} args - Arguments to find a TaskExpert
     * @example
     * // Get one TaskExpert
     * const taskExpert = await prisma.taskExpert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskExpertFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskExpertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskExpertClient<$Result.GetResult<Prisma.$TaskExpertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskExpert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskExpertFindFirstArgs} args - Arguments to find a TaskExpert
     * @example
     * // Get one TaskExpert
     * const taskExpert = await prisma.taskExpert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskExpertFindFirstArgs>(args?: SelectSubset<T, TaskExpertFindFirstArgs<ExtArgs>>): Prisma__TaskExpertClient<$Result.GetResult<Prisma.$TaskExpertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskExpert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskExpertFindFirstOrThrowArgs} args - Arguments to find a TaskExpert
     * @example
     * // Get one TaskExpert
     * const taskExpert = await prisma.taskExpert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskExpertFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskExpertFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskExpertClient<$Result.GetResult<Prisma.$TaskExpertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskExperts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskExpertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskExperts
     * const taskExperts = await prisma.taskExpert.findMany()
     * 
     * // Get first 10 TaskExperts
     * const taskExperts = await prisma.taskExpert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskExpertWithIdOnly = await prisma.taskExpert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskExpertFindManyArgs>(args?: SelectSubset<T, TaskExpertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskExpertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskExpert.
     * @param {TaskExpertCreateArgs} args - Arguments to create a TaskExpert.
     * @example
     * // Create one TaskExpert
     * const TaskExpert = await prisma.taskExpert.create({
     *   data: {
     *     // ... data to create a TaskExpert
     *   }
     * })
     * 
     */
    create<T extends TaskExpertCreateArgs>(args: SelectSubset<T, TaskExpertCreateArgs<ExtArgs>>): Prisma__TaskExpertClient<$Result.GetResult<Prisma.$TaskExpertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskExperts.
     * @param {TaskExpertCreateManyArgs} args - Arguments to create many TaskExperts.
     * @example
     * // Create many TaskExperts
     * const taskExpert = await prisma.taskExpert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskExpertCreateManyArgs>(args?: SelectSubset<T, TaskExpertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskExperts and returns the data saved in the database.
     * @param {TaskExpertCreateManyAndReturnArgs} args - Arguments to create many TaskExperts.
     * @example
     * // Create many TaskExperts
     * const taskExpert = await prisma.taskExpert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskExperts and only return the `id`
     * const taskExpertWithIdOnly = await prisma.taskExpert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskExpertCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskExpertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskExpertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskExpert.
     * @param {TaskExpertDeleteArgs} args - Arguments to delete one TaskExpert.
     * @example
     * // Delete one TaskExpert
     * const TaskExpert = await prisma.taskExpert.delete({
     *   where: {
     *     // ... filter to delete one TaskExpert
     *   }
     * })
     * 
     */
    delete<T extends TaskExpertDeleteArgs>(args: SelectSubset<T, TaskExpertDeleteArgs<ExtArgs>>): Prisma__TaskExpertClient<$Result.GetResult<Prisma.$TaskExpertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskExpert.
     * @param {TaskExpertUpdateArgs} args - Arguments to update one TaskExpert.
     * @example
     * // Update one TaskExpert
     * const taskExpert = await prisma.taskExpert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskExpertUpdateArgs>(args: SelectSubset<T, TaskExpertUpdateArgs<ExtArgs>>): Prisma__TaskExpertClient<$Result.GetResult<Prisma.$TaskExpertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskExperts.
     * @param {TaskExpertDeleteManyArgs} args - Arguments to filter TaskExperts to delete.
     * @example
     * // Delete a few TaskExperts
     * const { count } = await prisma.taskExpert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskExpertDeleteManyArgs>(args?: SelectSubset<T, TaskExpertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskExperts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskExpertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskExperts
     * const taskExpert = await prisma.taskExpert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskExpertUpdateManyArgs>(args: SelectSubset<T, TaskExpertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskExpert.
     * @param {TaskExpertUpsertArgs} args - Arguments to update or create a TaskExpert.
     * @example
     * // Update or create a TaskExpert
     * const taskExpert = await prisma.taskExpert.upsert({
     *   create: {
     *     // ... data to create a TaskExpert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskExpert we want to update
     *   }
     * })
     */
    upsert<T extends TaskExpertUpsertArgs>(args: SelectSubset<T, TaskExpertUpsertArgs<ExtArgs>>): Prisma__TaskExpertClient<$Result.GetResult<Prisma.$TaskExpertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskExperts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskExpertCountArgs} args - Arguments to filter TaskExperts to count.
     * @example
     * // Count the number of TaskExperts
     * const count = await prisma.taskExpert.count({
     *   where: {
     *     // ... the filter for the TaskExperts we want to count
     *   }
     * })
    **/
    count<T extends TaskExpertCountArgs>(
      args?: Subset<T, TaskExpertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskExpertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskExpert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskExpertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskExpertAggregateArgs>(args: Subset<T, TaskExpertAggregateArgs>): Prisma.PrismaPromise<GetTaskExpertAggregateType<T>>

    /**
     * Group by TaskExpert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskExpertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskExpertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskExpertGroupByArgs['orderBy'] }
        : { orderBy?: TaskExpertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskExpertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskExpertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskExpert model
   */
  readonly fields: TaskExpertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskExpert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskExpertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends ConsultationTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationTaskDefaultArgs<ExtArgs>>): Prisma__ConsultationTaskClient<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    expert<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskExpert model
   */ 
  interface TaskExpertFieldRefs {
    readonly id: FieldRef<"TaskExpert", 'String'>
    readonly taskId: FieldRef<"TaskExpert", 'String'>
    readonly expertId: FieldRef<"TaskExpert", 'String'>
    readonly status: FieldRef<"TaskExpert", 'String'>
    readonly isCore: FieldRef<"TaskExpert", 'Boolean'>
    readonly invitedAt: FieldRef<"TaskExpert", 'DateTime'>
    readonly respondedAt: FieldRef<"TaskExpert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskExpert findUnique
   */
  export type TaskExpertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExpert
     */
    select?: TaskExpertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskExpertInclude<ExtArgs> | null
    /**
     * Filter, which TaskExpert to fetch.
     */
    where: TaskExpertWhereUniqueInput
  }

  /**
   * TaskExpert findUniqueOrThrow
   */
  export type TaskExpertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExpert
     */
    select?: TaskExpertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskExpertInclude<ExtArgs> | null
    /**
     * Filter, which TaskExpert to fetch.
     */
    where: TaskExpertWhereUniqueInput
  }

  /**
   * TaskExpert findFirst
   */
  export type TaskExpertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExpert
     */
    select?: TaskExpertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskExpertInclude<ExtArgs> | null
    /**
     * Filter, which TaskExpert to fetch.
     */
    where?: TaskExpertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskExperts to fetch.
     */
    orderBy?: TaskExpertOrderByWithRelationInput | TaskExpertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskExperts.
     */
    cursor?: TaskExpertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskExperts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskExperts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskExperts.
     */
    distinct?: TaskExpertScalarFieldEnum | TaskExpertScalarFieldEnum[]
  }

  /**
   * TaskExpert findFirstOrThrow
   */
  export type TaskExpertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExpert
     */
    select?: TaskExpertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskExpertInclude<ExtArgs> | null
    /**
     * Filter, which TaskExpert to fetch.
     */
    where?: TaskExpertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskExperts to fetch.
     */
    orderBy?: TaskExpertOrderByWithRelationInput | TaskExpertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskExperts.
     */
    cursor?: TaskExpertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskExperts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskExperts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskExperts.
     */
    distinct?: TaskExpertScalarFieldEnum | TaskExpertScalarFieldEnum[]
  }

  /**
   * TaskExpert findMany
   */
  export type TaskExpertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExpert
     */
    select?: TaskExpertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskExpertInclude<ExtArgs> | null
    /**
     * Filter, which TaskExperts to fetch.
     */
    where?: TaskExpertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskExperts to fetch.
     */
    orderBy?: TaskExpertOrderByWithRelationInput | TaskExpertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskExperts.
     */
    cursor?: TaskExpertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskExperts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskExperts.
     */
    skip?: number
    distinct?: TaskExpertScalarFieldEnum | TaskExpertScalarFieldEnum[]
  }

  /**
   * TaskExpert create
   */
  export type TaskExpertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExpert
     */
    select?: TaskExpertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskExpertInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskExpert.
     */
    data: XOR<TaskExpertCreateInput, TaskExpertUncheckedCreateInput>
  }

  /**
   * TaskExpert createMany
   */
  export type TaskExpertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskExperts.
     */
    data: TaskExpertCreateManyInput | TaskExpertCreateManyInput[]
  }

  /**
   * TaskExpert createManyAndReturn
   */
  export type TaskExpertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExpert
     */
    select?: TaskExpertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskExperts.
     */
    data: TaskExpertCreateManyInput | TaskExpertCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskExpertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskExpert update
   */
  export type TaskExpertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExpert
     */
    select?: TaskExpertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskExpertInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskExpert.
     */
    data: XOR<TaskExpertUpdateInput, TaskExpertUncheckedUpdateInput>
    /**
     * Choose, which TaskExpert to update.
     */
    where: TaskExpertWhereUniqueInput
  }

  /**
   * TaskExpert updateMany
   */
  export type TaskExpertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskExperts.
     */
    data: XOR<TaskExpertUpdateManyMutationInput, TaskExpertUncheckedUpdateManyInput>
    /**
     * Filter which TaskExperts to update
     */
    where?: TaskExpertWhereInput
  }

  /**
   * TaskExpert upsert
   */
  export type TaskExpertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExpert
     */
    select?: TaskExpertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskExpertInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskExpert to update in case it exists.
     */
    where: TaskExpertWhereUniqueInput
    /**
     * In case the TaskExpert found by the `where` argument doesn't exist, create a new TaskExpert with this data.
     */
    create: XOR<TaskExpertCreateInput, TaskExpertUncheckedCreateInput>
    /**
     * In case the TaskExpert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskExpertUpdateInput, TaskExpertUncheckedUpdateInput>
  }

  /**
   * TaskExpert delete
   */
  export type TaskExpertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExpert
     */
    select?: TaskExpertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskExpertInclude<ExtArgs> | null
    /**
     * Filter which TaskExpert to delete.
     */
    where: TaskExpertWhereUniqueInput
  }

  /**
   * TaskExpert deleteMany
   */
  export type TaskExpertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskExperts to delete
     */
    where?: TaskExpertWhereInput
  }

  /**
   * TaskExpert without action
   */
  export type TaskExpertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExpert
     */
    select?: TaskExpertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskExpertInclude<ExtArgs> | null
  }


  /**
   * Model PreConsultationDoc
   */

  export type AggregatePreConsultationDoc = {
    _count: PreConsultationDocCountAggregateOutputType | null
    _min: PreConsultationDocMinAggregateOutputType | null
    _max: PreConsultationDocMaxAggregateOutputType | null
  }

  export type PreConsultationDocMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    presentIllness: string | null
    pastHistory: string | null
    familyHistory: string | null
    extraInfo: string | null
  }

  export type PreConsultationDocMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    presentIllness: string | null
    pastHistory: string | null
    familyHistory: string | null
    extraInfo: string | null
  }

  export type PreConsultationDocCountAggregateOutputType = {
    id: number
    taskId: number
    presentIllness: number
    pastHistory: number
    familyHistory: number
    extraInfo: number
    _all: number
  }


  export type PreConsultationDocMinAggregateInputType = {
    id?: true
    taskId?: true
    presentIllness?: true
    pastHistory?: true
    familyHistory?: true
    extraInfo?: true
  }

  export type PreConsultationDocMaxAggregateInputType = {
    id?: true
    taskId?: true
    presentIllness?: true
    pastHistory?: true
    familyHistory?: true
    extraInfo?: true
  }

  export type PreConsultationDocCountAggregateInputType = {
    id?: true
    taskId?: true
    presentIllness?: true
    pastHistory?: true
    familyHistory?: true
    extraInfo?: true
    _all?: true
  }

  export type PreConsultationDocAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreConsultationDoc to aggregate.
     */
    where?: PreConsultationDocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreConsultationDocs to fetch.
     */
    orderBy?: PreConsultationDocOrderByWithRelationInput | PreConsultationDocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PreConsultationDocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreConsultationDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreConsultationDocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PreConsultationDocs
    **/
    _count?: true | PreConsultationDocCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreConsultationDocMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreConsultationDocMaxAggregateInputType
  }

  export type GetPreConsultationDocAggregateType<T extends PreConsultationDocAggregateArgs> = {
        [P in keyof T & keyof AggregatePreConsultationDoc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreConsultationDoc[P]>
      : GetScalarType<T[P], AggregatePreConsultationDoc[P]>
  }




  export type PreConsultationDocGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreConsultationDocWhereInput
    orderBy?: PreConsultationDocOrderByWithAggregationInput | PreConsultationDocOrderByWithAggregationInput[]
    by: PreConsultationDocScalarFieldEnum[] | PreConsultationDocScalarFieldEnum
    having?: PreConsultationDocScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreConsultationDocCountAggregateInputType | true
    _min?: PreConsultationDocMinAggregateInputType
    _max?: PreConsultationDocMaxAggregateInputType
  }

  export type PreConsultationDocGroupByOutputType = {
    id: string
    taskId: string
    presentIllness: string
    pastHistory: string | null
    familyHistory: string | null
    extraInfo: string | null
    _count: PreConsultationDocCountAggregateOutputType | null
    _min: PreConsultationDocMinAggregateOutputType | null
    _max: PreConsultationDocMaxAggregateOutputType | null
  }

  type GetPreConsultationDocGroupByPayload<T extends PreConsultationDocGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreConsultationDocGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreConsultationDocGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreConsultationDocGroupByOutputType[P]>
            : GetScalarType<T[P], PreConsultationDocGroupByOutputType[P]>
        }
      >
    >


  export type PreConsultationDocSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    presentIllness?: boolean
    pastHistory?: boolean
    familyHistory?: boolean
    extraInfo?: boolean
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preConsultationDoc"]>

  export type PreConsultationDocSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    presentIllness?: boolean
    pastHistory?: boolean
    familyHistory?: boolean
    extraInfo?: boolean
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preConsultationDoc"]>

  export type PreConsultationDocSelectScalar = {
    id?: boolean
    taskId?: boolean
    presentIllness?: boolean
    pastHistory?: boolean
    familyHistory?: boolean
    extraInfo?: boolean
  }

  export type PreConsultationDocInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
  }
  export type PreConsultationDocIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
  }

  export type $PreConsultationDocPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PreConsultationDoc"
    objects: {
      task: Prisma.$ConsultationTaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      presentIllness: string
      pastHistory: string | null
      familyHistory: string | null
      extraInfo: string | null
    }, ExtArgs["result"]["preConsultationDoc"]>
    composites: {}
  }

  type PreConsultationDocGetPayload<S extends boolean | null | undefined | PreConsultationDocDefaultArgs> = $Result.GetResult<Prisma.$PreConsultationDocPayload, S>

  type PreConsultationDocCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PreConsultationDocFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PreConsultationDocCountAggregateInputType | true
    }

  export interface PreConsultationDocDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PreConsultationDoc'], meta: { name: 'PreConsultationDoc' } }
    /**
     * Find zero or one PreConsultationDoc that matches the filter.
     * @param {PreConsultationDocFindUniqueArgs} args - Arguments to find a PreConsultationDoc
     * @example
     * // Get one PreConsultationDoc
     * const preConsultationDoc = await prisma.preConsultationDoc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PreConsultationDocFindUniqueArgs>(args: SelectSubset<T, PreConsultationDocFindUniqueArgs<ExtArgs>>): Prisma__PreConsultationDocClient<$Result.GetResult<Prisma.$PreConsultationDocPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PreConsultationDoc that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PreConsultationDocFindUniqueOrThrowArgs} args - Arguments to find a PreConsultationDoc
     * @example
     * // Get one PreConsultationDoc
     * const preConsultationDoc = await prisma.preConsultationDoc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PreConsultationDocFindUniqueOrThrowArgs>(args: SelectSubset<T, PreConsultationDocFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PreConsultationDocClient<$Result.GetResult<Prisma.$PreConsultationDocPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PreConsultationDoc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreConsultationDocFindFirstArgs} args - Arguments to find a PreConsultationDoc
     * @example
     * // Get one PreConsultationDoc
     * const preConsultationDoc = await prisma.preConsultationDoc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PreConsultationDocFindFirstArgs>(args?: SelectSubset<T, PreConsultationDocFindFirstArgs<ExtArgs>>): Prisma__PreConsultationDocClient<$Result.GetResult<Prisma.$PreConsultationDocPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PreConsultationDoc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreConsultationDocFindFirstOrThrowArgs} args - Arguments to find a PreConsultationDoc
     * @example
     * // Get one PreConsultationDoc
     * const preConsultationDoc = await prisma.preConsultationDoc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PreConsultationDocFindFirstOrThrowArgs>(args?: SelectSubset<T, PreConsultationDocFindFirstOrThrowArgs<ExtArgs>>): Prisma__PreConsultationDocClient<$Result.GetResult<Prisma.$PreConsultationDocPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PreConsultationDocs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreConsultationDocFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PreConsultationDocs
     * const preConsultationDocs = await prisma.preConsultationDoc.findMany()
     * 
     * // Get first 10 PreConsultationDocs
     * const preConsultationDocs = await prisma.preConsultationDoc.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preConsultationDocWithIdOnly = await prisma.preConsultationDoc.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PreConsultationDocFindManyArgs>(args?: SelectSubset<T, PreConsultationDocFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreConsultationDocPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PreConsultationDoc.
     * @param {PreConsultationDocCreateArgs} args - Arguments to create a PreConsultationDoc.
     * @example
     * // Create one PreConsultationDoc
     * const PreConsultationDoc = await prisma.preConsultationDoc.create({
     *   data: {
     *     // ... data to create a PreConsultationDoc
     *   }
     * })
     * 
     */
    create<T extends PreConsultationDocCreateArgs>(args: SelectSubset<T, PreConsultationDocCreateArgs<ExtArgs>>): Prisma__PreConsultationDocClient<$Result.GetResult<Prisma.$PreConsultationDocPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PreConsultationDocs.
     * @param {PreConsultationDocCreateManyArgs} args - Arguments to create many PreConsultationDocs.
     * @example
     * // Create many PreConsultationDocs
     * const preConsultationDoc = await prisma.preConsultationDoc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PreConsultationDocCreateManyArgs>(args?: SelectSubset<T, PreConsultationDocCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PreConsultationDocs and returns the data saved in the database.
     * @param {PreConsultationDocCreateManyAndReturnArgs} args - Arguments to create many PreConsultationDocs.
     * @example
     * // Create many PreConsultationDocs
     * const preConsultationDoc = await prisma.preConsultationDoc.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PreConsultationDocs and only return the `id`
     * const preConsultationDocWithIdOnly = await prisma.preConsultationDoc.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PreConsultationDocCreateManyAndReturnArgs>(args?: SelectSubset<T, PreConsultationDocCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreConsultationDocPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PreConsultationDoc.
     * @param {PreConsultationDocDeleteArgs} args - Arguments to delete one PreConsultationDoc.
     * @example
     * // Delete one PreConsultationDoc
     * const PreConsultationDoc = await prisma.preConsultationDoc.delete({
     *   where: {
     *     // ... filter to delete one PreConsultationDoc
     *   }
     * })
     * 
     */
    delete<T extends PreConsultationDocDeleteArgs>(args: SelectSubset<T, PreConsultationDocDeleteArgs<ExtArgs>>): Prisma__PreConsultationDocClient<$Result.GetResult<Prisma.$PreConsultationDocPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PreConsultationDoc.
     * @param {PreConsultationDocUpdateArgs} args - Arguments to update one PreConsultationDoc.
     * @example
     * // Update one PreConsultationDoc
     * const preConsultationDoc = await prisma.preConsultationDoc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PreConsultationDocUpdateArgs>(args: SelectSubset<T, PreConsultationDocUpdateArgs<ExtArgs>>): Prisma__PreConsultationDocClient<$Result.GetResult<Prisma.$PreConsultationDocPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PreConsultationDocs.
     * @param {PreConsultationDocDeleteManyArgs} args - Arguments to filter PreConsultationDocs to delete.
     * @example
     * // Delete a few PreConsultationDocs
     * const { count } = await prisma.preConsultationDoc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PreConsultationDocDeleteManyArgs>(args?: SelectSubset<T, PreConsultationDocDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PreConsultationDocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreConsultationDocUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PreConsultationDocs
     * const preConsultationDoc = await prisma.preConsultationDoc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PreConsultationDocUpdateManyArgs>(args: SelectSubset<T, PreConsultationDocUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PreConsultationDoc.
     * @param {PreConsultationDocUpsertArgs} args - Arguments to update or create a PreConsultationDoc.
     * @example
     * // Update or create a PreConsultationDoc
     * const preConsultationDoc = await prisma.preConsultationDoc.upsert({
     *   create: {
     *     // ... data to create a PreConsultationDoc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PreConsultationDoc we want to update
     *   }
     * })
     */
    upsert<T extends PreConsultationDocUpsertArgs>(args: SelectSubset<T, PreConsultationDocUpsertArgs<ExtArgs>>): Prisma__PreConsultationDocClient<$Result.GetResult<Prisma.$PreConsultationDocPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PreConsultationDocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreConsultationDocCountArgs} args - Arguments to filter PreConsultationDocs to count.
     * @example
     * // Count the number of PreConsultationDocs
     * const count = await prisma.preConsultationDoc.count({
     *   where: {
     *     // ... the filter for the PreConsultationDocs we want to count
     *   }
     * })
    **/
    count<T extends PreConsultationDocCountArgs>(
      args?: Subset<T, PreConsultationDocCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreConsultationDocCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PreConsultationDoc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreConsultationDocAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreConsultationDocAggregateArgs>(args: Subset<T, PreConsultationDocAggregateArgs>): Prisma.PrismaPromise<GetPreConsultationDocAggregateType<T>>

    /**
     * Group by PreConsultationDoc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreConsultationDocGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreConsultationDocGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreConsultationDocGroupByArgs['orderBy'] }
        : { orderBy?: PreConsultationDocGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreConsultationDocGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreConsultationDocGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PreConsultationDoc model
   */
  readonly fields: PreConsultationDocFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PreConsultationDoc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreConsultationDocClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends ConsultationTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationTaskDefaultArgs<ExtArgs>>): Prisma__ConsultationTaskClient<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PreConsultationDoc model
   */ 
  interface PreConsultationDocFieldRefs {
    readonly id: FieldRef<"PreConsultationDoc", 'String'>
    readonly taskId: FieldRef<"PreConsultationDoc", 'String'>
    readonly presentIllness: FieldRef<"PreConsultationDoc", 'String'>
    readonly pastHistory: FieldRef<"PreConsultationDoc", 'String'>
    readonly familyHistory: FieldRef<"PreConsultationDoc", 'String'>
    readonly extraInfo: FieldRef<"PreConsultationDoc", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PreConsultationDoc findUnique
   */
  export type PreConsultationDocFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreConsultationDoc
     */
    select?: PreConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreConsultationDocInclude<ExtArgs> | null
    /**
     * Filter, which PreConsultationDoc to fetch.
     */
    where: PreConsultationDocWhereUniqueInput
  }

  /**
   * PreConsultationDoc findUniqueOrThrow
   */
  export type PreConsultationDocFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreConsultationDoc
     */
    select?: PreConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreConsultationDocInclude<ExtArgs> | null
    /**
     * Filter, which PreConsultationDoc to fetch.
     */
    where: PreConsultationDocWhereUniqueInput
  }

  /**
   * PreConsultationDoc findFirst
   */
  export type PreConsultationDocFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreConsultationDoc
     */
    select?: PreConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreConsultationDocInclude<ExtArgs> | null
    /**
     * Filter, which PreConsultationDoc to fetch.
     */
    where?: PreConsultationDocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreConsultationDocs to fetch.
     */
    orderBy?: PreConsultationDocOrderByWithRelationInput | PreConsultationDocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreConsultationDocs.
     */
    cursor?: PreConsultationDocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreConsultationDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreConsultationDocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreConsultationDocs.
     */
    distinct?: PreConsultationDocScalarFieldEnum | PreConsultationDocScalarFieldEnum[]
  }

  /**
   * PreConsultationDoc findFirstOrThrow
   */
  export type PreConsultationDocFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreConsultationDoc
     */
    select?: PreConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreConsultationDocInclude<ExtArgs> | null
    /**
     * Filter, which PreConsultationDoc to fetch.
     */
    where?: PreConsultationDocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreConsultationDocs to fetch.
     */
    orderBy?: PreConsultationDocOrderByWithRelationInput | PreConsultationDocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PreConsultationDocs.
     */
    cursor?: PreConsultationDocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreConsultationDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreConsultationDocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PreConsultationDocs.
     */
    distinct?: PreConsultationDocScalarFieldEnum | PreConsultationDocScalarFieldEnum[]
  }

  /**
   * PreConsultationDoc findMany
   */
  export type PreConsultationDocFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreConsultationDoc
     */
    select?: PreConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreConsultationDocInclude<ExtArgs> | null
    /**
     * Filter, which PreConsultationDocs to fetch.
     */
    where?: PreConsultationDocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PreConsultationDocs to fetch.
     */
    orderBy?: PreConsultationDocOrderByWithRelationInput | PreConsultationDocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PreConsultationDocs.
     */
    cursor?: PreConsultationDocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PreConsultationDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PreConsultationDocs.
     */
    skip?: number
    distinct?: PreConsultationDocScalarFieldEnum | PreConsultationDocScalarFieldEnum[]
  }

  /**
   * PreConsultationDoc create
   */
  export type PreConsultationDocCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreConsultationDoc
     */
    select?: PreConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreConsultationDocInclude<ExtArgs> | null
    /**
     * The data needed to create a PreConsultationDoc.
     */
    data: XOR<PreConsultationDocCreateInput, PreConsultationDocUncheckedCreateInput>
  }

  /**
   * PreConsultationDoc createMany
   */
  export type PreConsultationDocCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PreConsultationDocs.
     */
    data: PreConsultationDocCreateManyInput | PreConsultationDocCreateManyInput[]
  }

  /**
   * PreConsultationDoc createManyAndReturn
   */
  export type PreConsultationDocCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreConsultationDoc
     */
    select?: PreConsultationDocSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PreConsultationDocs.
     */
    data: PreConsultationDocCreateManyInput | PreConsultationDocCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreConsultationDocIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PreConsultationDoc update
   */
  export type PreConsultationDocUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreConsultationDoc
     */
    select?: PreConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreConsultationDocInclude<ExtArgs> | null
    /**
     * The data needed to update a PreConsultationDoc.
     */
    data: XOR<PreConsultationDocUpdateInput, PreConsultationDocUncheckedUpdateInput>
    /**
     * Choose, which PreConsultationDoc to update.
     */
    where: PreConsultationDocWhereUniqueInput
  }

  /**
   * PreConsultationDoc updateMany
   */
  export type PreConsultationDocUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PreConsultationDocs.
     */
    data: XOR<PreConsultationDocUpdateManyMutationInput, PreConsultationDocUncheckedUpdateManyInput>
    /**
     * Filter which PreConsultationDocs to update
     */
    where?: PreConsultationDocWhereInput
  }

  /**
   * PreConsultationDoc upsert
   */
  export type PreConsultationDocUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreConsultationDoc
     */
    select?: PreConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreConsultationDocInclude<ExtArgs> | null
    /**
     * The filter to search for the PreConsultationDoc to update in case it exists.
     */
    where: PreConsultationDocWhereUniqueInput
    /**
     * In case the PreConsultationDoc found by the `where` argument doesn't exist, create a new PreConsultationDoc with this data.
     */
    create: XOR<PreConsultationDocCreateInput, PreConsultationDocUncheckedCreateInput>
    /**
     * In case the PreConsultationDoc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreConsultationDocUpdateInput, PreConsultationDocUncheckedUpdateInput>
  }

  /**
   * PreConsultationDoc delete
   */
  export type PreConsultationDocDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreConsultationDoc
     */
    select?: PreConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreConsultationDocInclude<ExtArgs> | null
    /**
     * Filter which PreConsultationDoc to delete.
     */
    where: PreConsultationDocWhereUniqueInput
  }

  /**
   * PreConsultationDoc deleteMany
   */
  export type PreConsultationDocDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PreConsultationDocs to delete
     */
    where?: PreConsultationDocWhereInput
  }

  /**
   * PreConsultationDoc without action
   */
  export type PreConsultationDocDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PreConsultationDoc
     */
    select?: PreConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreConsultationDocInclude<ExtArgs> | null
  }


  /**
   * Model ConsultationDialog
   */

  export type AggregateConsultationDialog = {
    _count: ConsultationDialogCountAggregateOutputType | null
    _avg: ConsultationDialogAvgAggregateOutputType | null
    _sum: ConsultationDialogSumAggregateOutputType | null
    _min: ConsultationDialogMinAggregateOutputType | null
    _max: ConsultationDialogMaxAggregateOutputType | null
  }

  export type ConsultationDialogAvgAggregateOutputType = {
    startTime: number | null
  }

  export type ConsultationDialogSumAggregateOutputType = {
    startTime: number | null
  }

  export type ConsultationDialogMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    role: string | null
    content: string | null
    original: string | null
    startTime: number | null
    createdAt: Date | null
  }

  export type ConsultationDialogMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    role: string | null
    content: string | null
    original: string | null
    startTime: number | null
    createdAt: Date | null
  }

  export type ConsultationDialogCountAggregateOutputType = {
    id: number
    taskId: number
    role: number
    content: number
    original: number
    startTime: number
    createdAt: number
    _all: number
  }


  export type ConsultationDialogAvgAggregateInputType = {
    startTime?: true
  }

  export type ConsultationDialogSumAggregateInputType = {
    startTime?: true
  }

  export type ConsultationDialogMinAggregateInputType = {
    id?: true
    taskId?: true
    role?: true
    content?: true
    original?: true
    startTime?: true
    createdAt?: true
  }

  export type ConsultationDialogMaxAggregateInputType = {
    id?: true
    taskId?: true
    role?: true
    content?: true
    original?: true
    startTime?: true
    createdAt?: true
  }

  export type ConsultationDialogCountAggregateInputType = {
    id?: true
    taskId?: true
    role?: true
    content?: true
    original?: true
    startTime?: true
    createdAt?: true
    _all?: true
  }

  export type ConsultationDialogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsultationDialog to aggregate.
     */
    where?: ConsultationDialogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationDialogs to fetch.
     */
    orderBy?: ConsultationDialogOrderByWithRelationInput | ConsultationDialogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsultationDialogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationDialogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationDialogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConsultationDialogs
    **/
    _count?: true | ConsultationDialogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsultationDialogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsultationDialogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultationDialogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultationDialogMaxAggregateInputType
  }

  export type GetConsultationDialogAggregateType<T extends ConsultationDialogAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultationDialog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultationDialog[P]>
      : GetScalarType<T[P], AggregateConsultationDialog[P]>
  }




  export type ConsultationDialogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationDialogWhereInput
    orderBy?: ConsultationDialogOrderByWithAggregationInput | ConsultationDialogOrderByWithAggregationInput[]
    by: ConsultationDialogScalarFieldEnum[] | ConsultationDialogScalarFieldEnum
    having?: ConsultationDialogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultationDialogCountAggregateInputType | true
    _avg?: ConsultationDialogAvgAggregateInputType
    _sum?: ConsultationDialogSumAggregateInputType
    _min?: ConsultationDialogMinAggregateInputType
    _max?: ConsultationDialogMaxAggregateInputType
  }

  export type ConsultationDialogGroupByOutputType = {
    id: string
    taskId: string
    role: string
    content: string
    original: string | null
    startTime: number | null
    createdAt: Date
    _count: ConsultationDialogCountAggregateOutputType | null
    _avg: ConsultationDialogAvgAggregateOutputType | null
    _sum: ConsultationDialogSumAggregateOutputType | null
    _min: ConsultationDialogMinAggregateOutputType | null
    _max: ConsultationDialogMaxAggregateOutputType | null
  }

  type GetConsultationDialogGroupByPayload<T extends ConsultationDialogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultationDialogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultationDialogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultationDialogGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultationDialogGroupByOutputType[P]>
        }
      >
    >


  export type ConsultationDialogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    role?: boolean
    content?: boolean
    original?: boolean
    startTime?: boolean
    createdAt?: boolean
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultationDialog"]>

  export type ConsultationDialogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    role?: boolean
    content?: boolean
    original?: boolean
    startTime?: boolean
    createdAt?: boolean
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultationDialog"]>

  export type ConsultationDialogSelectScalar = {
    id?: boolean
    taskId?: boolean
    role?: boolean
    content?: boolean
    original?: boolean
    startTime?: boolean
    createdAt?: boolean
  }

  export type ConsultationDialogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
  }
  export type ConsultationDialogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
  }

  export type $ConsultationDialogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConsultationDialog"
    objects: {
      task: Prisma.$ConsultationTaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      role: string
      content: string
      original: string | null
      startTime: number | null
      createdAt: Date
    }, ExtArgs["result"]["consultationDialog"]>
    composites: {}
  }

  type ConsultationDialogGetPayload<S extends boolean | null | undefined | ConsultationDialogDefaultArgs> = $Result.GetResult<Prisma.$ConsultationDialogPayload, S>

  type ConsultationDialogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConsultationDialogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConsultationDialogCountAggregateInputType | true
    }

  export interface ConsultationDialogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConsultationDialog'], meta: { name: 'ConsultationDialog' } }
    /**
     * Find zero or one ConsultationDialog that matches the filter.
     * @param {ConsultationDialogFindUniqueArgs} args - Arguments to find a ConsultationDialog
     * @example
     * // Get one ConsultationDialog
     * const consultationDialog = await prisma.consultationDialog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsultationDialogFindUniqueArgs>(args: SelectSubset<T, ConsultationDialogFindUniqueArgs<ExtArgs>>): Prisma__ConsultationDialogClient<$Result.GetResult<Prisma.$ConsultationDialogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConsultationDialog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConsultationDialogFindUniqueOrThrowArgs} args - Arguments to find a ConsultationDialog
     * @example
     * // Get one ConsultationDialog
     * const consultationDialog = await prisma.consultationDialog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsultationDialogFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsultationDialogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsultationDialogClient<$Result.GetResult<Prisma.$ConsultationDialogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConsultationDialog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationDialogFindFirstArgs} args - Arguments to find a ConsultationDialog
     * @example
     * // Get one ConsultationDialog
     * const consultationDialog = await prisma.consultationDialog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsultationDialogFindFirstArgs>(args?: SelectSubset<T, ConsultationDialogFindFirstArgs<ExtArgs>>): Prisma__ConsultationDialogClient<$Result.GetResult<Prisma.$ConsultationDialogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConsultationDialog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationDialogFindFirstOrThrowArgs} args - Arguments to find a ConsultationDialog
     * @example
     * // Get one ConsultationDialog
     * const consultationDialog = await prisma.consultationDialog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsultationDialogFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsultationDialogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsultationDialogClient<$Result.GetResult<Prisma.$ConsultationDialogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConsultationDialogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationDialogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsultationDialogs
     * const consultationDialogs = await prisma.consultationDialog.findMany()
     * 
     * // Get first 10 ConsultationDialogs
     * const consultationDialogs = await prisma.consultationDialog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultationDialogWithIdOnly = await prisma.consultationDialog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsultationDialogFindManyArgs>(args?: SelectSubset<T, ConsultationDialogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationDialogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConsultationDialog.
     * @param {ConsultationDialogCreateArgs} args - Arguments to create a ConsultationDialog.
     * @example
     * // Create one ConsultationDialog
     * const ConsultationDialog = await prisma.consultationDialog.create({
     *   data: {
     *     // ... data to create a ConsultationDialog
     *   }
     * })
     * 
     */
    create<T extends ConsultationDialogCreateArgs>(args: SelectSubset<T, ConsultationDialogCreateArgs<ExtArgs>>): Prisma__ConsultationDialogClient<$Result.GetResult<Prisma.$ConsultationDialogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConsultationDialogs.
     * @param {ConsultationDialogCreateManyArgs} args - Arguments to create many ConsultationDialogs.
     * @example
     * // Create many ConsultationDialogs
     * const consultationDialog = await prisma.consultationDialog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsultationDialogCreateManyArgs>(args?: SelectSubset<T, ConsultationDialogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConsultationDialogs and returns the data saved in the database.
     * @param {ConsultationDialogCreateManyAndReturnArgs} args - Arguments to create many ConsultationDialogs.
     * @example
     * // Create many ConsultationDialogs
     * const consultationDialog = await prisma.consultationDialog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConsultationDialogs and only return the `id`
     * const consultationDialogWithIdOnly = await prisma.consultationDialog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsultationDialogCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsultationDialogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationDialogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConsultationDialog.
     * @param {ConsultationDialogDeleteArgs} args - Arguments to delete one ConsultationDialog.
     * @example
     * // Delete one ConsultationDialog
     * const ConsultationDialog = await prisma.consultationDialog.delete({
     *   where: {
     *     // ... filter to delete one ConsultationDialog
     *   }
     * })
     * 
     */
    delete<T extends ConsultationDialogDeleteArgs>(args: SelectSubset<T, ConsultationDialogDeleteArgs<ExtArgs>>): Prisma__ConsultationDialogClient<$Result.GetResult<Prisma.$ConsultationDialogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConsultationDialog.
     * @param {ConsultationDialogUpdateArgs} args - Arguments to update one ConsultationDialog.
     * @example
     * // Update one ConsultationDialog
     * const consultationDialog = await prisma.consultationDialog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsultationDialogUpdateArgs>(args: SelectSubset<T, ConsultationDialogUpdateArgs<ExtArgs>>): Prisma__ConsultationDialogClient<$Result.GetResult<Prisma.$ConsultationDialogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConsultationDialogs.
     * @param {ConsultationDialogDeleteManyArgs} args - Arguments to filter ConsultationDialogs to delete.
     * @example
     * // Delete a few ConsultationDialogs
     * const { count } = await prisma.consultationDialog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsultationDialogDeleteManyArgs>(args?: SelectSubset<T, ConsultationDialogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsultationDialogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationDialogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsultationDialogs
     * const consultationDialog = await prisma.consultationDialog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsultationDialogUpdateManyArgs>(args: SelectSubset<T, ConsultationDialogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConsultationDialog.
     * @param {ConsultationDialogUpsertArgs} args - Arguments to update or create a ConsultationDialog.
     * @example
     * // Update or create a ConsultationDialog
     * const consultationDialog = await prisma.consultationDialog.upsert({
     *   create: {
     *     // ... data to create a ConsultationDialog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsultationDialog we want to update
     *   }
     * })
     */
    upsert<T extends ConsultationDialogUpsertArgs>(args: SelectSubset<T, ConsultationDialogUpsertArgs<ExtArgs>>): Prisma__ConsultationDialogClient<$Result.GetResult<Prisma.$ConsultationDialogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConsultationDialogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationDialogCountArgs} args - Arguments to filter ConsultationDialogs to count.
     * @example
     * // Count the number of ConsultationDialogs
     * const count = await prisma.consultationDialog.count({
     *   where: {
     *     // ... the filter for the ConsultationDialogs we want to count
     *   }
     * })
    **/
    count<T extends ConsultationDialogCountArgs>(
      args?: Subset<T, ConsultationDialogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultationDialogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsultationDialog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationDialogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultationDialogAggregateArgs>(args: Subset<T, ConsultationDialogAggregateArgs>): Prisma.PrismaPromise<GetConsultationDialogAggregateType<T>>

    /**
     * Group by ConsultationDialog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationDialogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultationDialogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultationDialogGroupByArgs['orderBy'] }
        : { orderBy?: ConsultationDialogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultationDialogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultationDialogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConsultationDialog model
   */
  readonly fields: ConsultationDialogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConsultationDialog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsultationDialogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends ConsultationTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationTaskDefaultArgs<ExtArgs>>): Prisma__ConsultationTaskClient<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConsultationDialog model
   */ 
  interface ConsultationDialogFieldRefs {
    readonly id: FieldRef<"ConsultationDialog", 'String'>
    readonly taskId: FieldRef<"ConsultationDialog", 'String'>
    readonly role: FieldRef<"ConsultationDialog", 'String'>
    readonly content: FieldRef<"ConsultationDialog", 'String'>
    readonly original: FieldRef<"ConsultationDialog", 'String'>
    readonly startTime: FieldRef<"ConsultationDialog", 'Float'>
    readonly createdAt: FieldRef<"ConsultationDialog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConsultationDialog findUnique
   */
  export type ConsultationDialogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDialog
     */
    select?: ConsultationDialogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationDialogInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationDialog to fetch.
     */
    where: ConsultationDialogWhereUniqueInput
  }

  /**
   * ConsultationDialog findUniqueOrThrow
   */
  export type ConsultationDialogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDialog
     */
    select?: ConsultationDialogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationDialogInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationDialog to fetch.
     */
    where: ConsultationDialogWhereUniqueInput
  }

  /**
   * ConsultationDialog findFirst
   */
  export type ConsultationDialogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDialog
     */
    select?: ConsultationDialogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationDialogInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationDialog to fetch.
     */
    where?: ConsultationDialogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationDialogs to fetch.
     */
    orderBy?: ConsultationDialogOrderByWithRelationInput | ConsultationDialogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultationDialogs.
     */
    cursor?: ConsultationDialogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationDialogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationDialogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultationDialogs.
     */
    distinct?: ConsultationDialogScalarFieldEnum | ConsultationDialogScalarFieldEnum[]
  }

  /**
   * ConsultationDialog findFirstOrThrow
   */
  export type ConsultationDialogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDialog
     */
    select?: ConsultationDialogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationDialogInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationDialog to fetch.
     */
    where?: ConsultationDialogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationDialogs to fetch.
     */
    orderBy?: ConsultationDialogOrderByWithRelationInput | ConsultationDialogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultationDialogs.
     */
    cursor?: ConsultationDialogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationDialogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationDialogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultationDialogs.
     */
    distinct?: ConsultationDialogScalarFieldEnum | ConsultationDialogScalarFieldEnum[]
  }

  /**
   * ConsultationDialog findMany
   */
  export type ConsultationDialogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDialog
     */
    select?: ConsultationDialogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationDialogInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationDialogs to fetch.
     */
    where?: ConsultationDialogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationDialogs to fetch.
     */
    orderBy?: ConsultationDialogOrderByWithRelationInput | ConsultationDialogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConsultationDialogs.
     */
    cursor?: ConsultationDialogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationDialogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationDialogs.
     */
    skip?: number
    distinct?: ConsultationDialogScalarFieldEnum | ConsultationDialogScalarFieldEnum[]
  }

  /**
   * ConsultationDialog create
   */
  export type ConsultationDialogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDialog
     */
    select?: ConsultationDialogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationDialogInclude<ExtArgs> | null
    /**
     * The data needed to create a ConsultationDialog.
     */
    data: XOR<ConsultationDialogCreateInput, ConsultationDialogUncheckedCreateInput>
  }

  /**
   * ConsultationDialog createMany
   */
  export type ConsultationDialogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConsultationDialogs.
     */
    data: ConsultationDialogCreateManyInput | ConsultationDialogCreateManyInput[]
  }

  /**
   * ConsultationDialog createManyAndReturn
   */
  export type ConsultationDialogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDialog
     */
    select?: ConsultationDialogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConsultationDialogs.
     */
    data: ConsultationDialogCreateManyInput | ConsultationDialogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationDialogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConsultationDialog update
   */
  export type ConsultationDialogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDialog
     */
    select?: ConsultationDialogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationDialogInclude<ExtArgs> | null
    /**
     * The data needed to update a ConsultationDialog.
     */
    data: XOR<ConsultationDialogUpdateInput, ConsultationDialogUncheckedUpdateInput>
    /**
     * Choose, which ConsultationDialog to update.
     */
    where: ConsultationDialogWhereUniqueInput
  }

  /**
   * ConsultationDialog updateMany
   */
  export type ConsultationDialogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConsultationDialogs.
     */
    data: XOR<ConsultationDialogUpdateManyMutationInput, ConsultationDialogUncheckedUpdateManyInput>
    /**
     * Filter which ConsultationDialogs to update
     */
    where?: ConsultationDialogWhereInput
  }

  /**
   * ConsultationDialog upsert
   */
  export type ConsultationDialogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDialog
     */
    select?: ConsultationDialogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationDialogInclude<ExtArgs> | null
    /**
     * The filter to search for the ConsultationDialog to update in case it exists.
     */
    where: ConsultationDialogWhereUniqueInput
    /**
     * In case the ConsultationDialog found by the `where` argument doesn't exist, create a new ConsultationDialog with this data.
     */
    create: XOR<ConsultationDialogCreateInput, ConsultationDialogUncheckedCreateInput>
    /**
     * In case the ConsultationDialog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsultationDialogUpdateInput, ConsultationDialogUncheckedUpdateInput>
  }

  /**
   * ConsultationDialog delete
   */
  export type ConsultationDialogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDialog
     */
    select?: ConsultationDialogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationDialogInclude<ExtArgs> | null
    /**
     * Filter which ConsultationDialog to delete.
     */
    where: ConsultationDialogWhereUniqueInput
  }

  /**
   * ConsultationDialog deleteMany
   */
  export type ConsultationDialogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsultationDialogs to delete
     */
    where?: ConsultationDialogWhereInput
  }

  /**
   * ConsultationDialog without action
   */
  export type ConsultationDialogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationDialog
     */
    select?: ConsultationDialogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationDialogInclude<ExtArgs> | null
  }


  /**
   * Model PostConsultationDoc
   */

  export type AggregatePostConsultationDoc = {
    _count: PostConsultationDocCountAggregateOutputType | null
    _avg: PostConsultationDocAvgAggregateOutputType | null
    _sum: PostConsultationDocSumAggregateOutputType | null
    _min: PostConsultationDocMinAggregateOutputType | null
    _max: PostConsultationDocMaxAggregateOutputType | null
  }

  export type PostConsultationDocAvgAggregateOutputType = {
    version: number | null
  }

  export type PostConsultationDocSumAggregateOutputType = {
    version: number | null
  }

  export type PostConsultationDocMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    aiContent: string | null
    finalContent: string | null
    isSubmitted: boolean | null
    version: number | null
    updatedAt: Date | null
  }

  export type PostConsultationDocMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    aiContent: string | null
    finalContent: string | null
    isSubmitted: boolean | null
    version: number | null
    updatedAt: Date | null
  }

  export type PostConsultationDocCountAggregateOutputType = {
    id: number
    taskId: number
    aiContent: number
    finalContent: number
    isSubmitted: number
    version: number
    updatedAt: number
    _all: number
  }


  export type PostConsultationDocAvgAggregateInputType = {
    version?: true
  }

  export type PostConsultationDocSumAggregateInputType = {
    version?: true
  }

  export type PostConsultationDocMinAggregateInputType = {
    id?: true
    taskId?: true
    aiContent?: true
    finalContent?: true
    isSubmitted?: true
    version?: true
    updatedAt?: true
  }

  export type PostConsultationDocMaxAggregateInputType = {
    id?: true
    taskId?: true
    aiContent?: true
    finalContent?: true
    isSubmitted?: true
    version?: true
    updatedAt?: true
  }

  export type PostConsultationDocCountAggregateInputType = {
    id?: true
    taskId?: true
    aiContent?: true
    finalContent?: true
    isSubmitted?: true
    version?: true
    updatedAt?: true
    _all?: true
  }

  export type PostConsultationDocAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostConsultationDoc to aggregate.
     */
    where?: PostConsultationDocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostConsultationDocs to fetch.
     */
    orderBy?: PostConsultationDocOrderByWithRelationInput | PostConsultationDocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostConsultationDocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostConsultationDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostConsultationDocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostConsultationDocs
    **/
    _count?: true | PostConsultationDocCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostConsultationDocAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostConsultationDocSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostConsultationDocMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostConsultationDocMaxAggregateInputType
  }

  export type GetPostConsultationDocAggregateType<T extends PostConsultationDocAggregateArgs> = {
        [P in keyof T & keyof AggregatePostConsultationDoc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostConsultationDoc[P]>
      : GetScalarType<T[P], AggregatePostConsultationDoc[P]>
  }




  export type PostConsultationDocGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostConsultationDocWhereInput
    orderBy?: PostConsultationDocOrderByWithAggregationInput | PostConsultationDocOrderByWithAggregationInput[]
    by: PostConsultationDocScalarFieldEnum[] | PostConsultationDocScalarFieldEnum
    having?: PostConsultationDocScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostConsultationDocCountAggregateInputType | true
    _avg?: PostConsultationDocAvgAggregateInputType
    _sum?: PostConsultationDocSumAggregateInputType
    _min?: PostConsultationDocMinAggregateInputType
    _max?: PostConsultationDocMaxAggregateInputType
  }

  export type PostConsultationDocGroupByOutputType = {
    id: string
    taskId: string
    aiContent: string | null
    finalContent: string | null
    isSubmitted: boolean
    version: number
    updatedAt: Date
    _count: PostConsultationDocCountAggregateOutputType | null
    _avg: PostConsultationDocAvgAggregateOutputType | null
    _sum: PostConsultationDocSumAggregateOutputType | null
    _min: PostConsultationDocMinAggregateOutputType | null
    _max: PostConsultationDocMaxAggregateOutputType | null
  }

  type GetPostConsultationDocGroupByPayload<T extends PostConsultationDocGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostConsultationDocGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostConsultationDocGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostConsultationDocGroupByOutputType[P]>
            : GetScalarType<T[P], PostConsultationDocGroupByOutputType[P]>
        }
      >
    >


  export type PostConsultationDocSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    aiContent?: boolean
    finalContent?: boolean
    isSubmitted?: boolean
    version?: boolean
    updatedAt?: boolean
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postConsultationDoc"]>

  export type PostConsultationDocSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    aiContent?: boolean
    finalContent?: boolean
    isSubmitted?: boolean
    version?: boolean
    updatedAt?: boolean
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postConsultationDoc"]>

  export type PostConsultationDocSelectScalar = {
    id?: boolean
    taskId?: boolean
    aiContent?: boolean
    finalContent?: boolean
    isSubmitted?: boolean
    version?: boolean
    updatedAt?: boolean
  }

  export type PostConsultationDocInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
  }
  export type PostConsultationDocIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
  }

  export type $PostConsultationDocPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostConsultationDoc"
    objects: {
      task: Prisma.$ConsultationTaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      aiContent: string | null
      finalContent: string | null
      isSubmitted: boolean
      version: number
      updatedAt: Date
    }, ExtArgs["result"]["postConsultationDoc"]>
    composites: {}
  }

  type PostConsultationDocGetPayload<S extends boolean | null | undefined | PostConsultationDocDefaultArgs> = $Result.GetResult<Prisma.$PostConsultationDocPayload, S>

  type PostConsultationDocCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostConsultationDocFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostConsultationDocCountAggregateInputType | true
    }

  export interface PostConsultationDocDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostConsultationDoc'], meta: { name: 'PostConsultationDoc' } }
    /**
     * Find zero or one PostConsultationDoc that matches the filter.
     * @param {PostConsultationDocFindUniqueArgs} args - Arguments to find a PostConsultationDoc
     * @example
     * // Get one PostConsultationDoc
     * const postConsultationDoc = await prisma.postConsultationDoc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostConsultationDocFindUniqueArgs>(args: SelectSubset<T, PostConsultationDocFindUniqueArgs<ExtArgs>>): Prisma__PostConsultationDocClient<$Result.GetResult<Prisma.$PostConsultationDocPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostConsultationDoc that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostConsultationDocFindUniqueOrThrowArgs} args - Arguments to find a PostConsultationDoc
     * @example
     * // Get one PostConsultationDoc
     * const postConsultationDoc = await prisma.postConsultationDoc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostConsultationDocFindUniqueOrThrowArgs>(args: SelectSubset<T, PostConsultationDocFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostConsultationDocClient<$Result.GetResult<Prisma.$PostConsultationDocPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostConsultationDoc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostConsultationDocFindFirstArgs} args - Arguments to find a PostConsultationDoc
     * @example
     * // Get one PostConsultationDoc
     * const postConsultationDoc = await prisma.postConsultationDoc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostConsultationDocFindFirstArgs>(args?: SelectSubset<T, PostConsultationDocFindFirstArgs<ExtArgs>>): Prisma__PostConsultationDocClient<$Result.GetResult<Prisma.$PostConsultationDocPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostConsultationDoc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostConsultationDocFindFirstOrThrowArgs} args - Arguments to find a PostConsultationDoc
     * @example
     * // Get one PostConsultationDoc
     * const postConsultationDoc = await prisma.postConsultationDoc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostConsultationDocFindFirstOrThrowArgs>(args?: SelectSubset<T, PostConsultationDocFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostConsultationDocClient<$Result.GetResult<Prisma.$PostConsultationDocPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostConsultationDocs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostConsultationDocFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostConsultationDocs
     * const postConsultationDocs = await prisma.postConsultationDoc.findMany()
     * 
     * // Get first 10 PostConsultationDocs
     * const postConsultationDocs = await prisma.postConsultationDoc.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postConsultationDocWithIdOnly = await prisma.postConsultationDoc.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostConsultationDocFindManyArgs>(args?: SelectSubset<T, PostConsultationDocFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostConsultationDocPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostConsultationDoc.
     * @param {PostConsultationDocCreateArgs} args - Arguments to create a PostConsultationDoc.
     * @example
     * // Create one PostConsultationDoc
     * const PostConsultationDoc = await prisma.postConsultationDoc.create({
     *   data: {
     *     // ... data to create a PostConsultationDoc
     *   }
     * })
     * 
     */
    create<T extends PostConsultationDocCreateArgs>(args: SelectSubset<T, PostConsultationDocCreateArgs<ExtArgs>>): Prisma__PostConsultationDocClient<$Result.GetResult<Prisma.$PostConsultationDocPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostConsultationDocs.
     * @param {PostConsultationDocCreateManyArgs} args - Arguments to create many PostConsultationDocs.
     * @example
     * // Create many PostConsultationDocs
     * const postConsultationDoc = await prisma.postConsultationDoc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostConsultationDocCreateManyArgs>(args?: SelectSubset<T, PostConsultationDocCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostConsultationDocs and returns the data saved in the database.
     * @param {PostConsultationDocCreateManyAndReturnArgs} args - Arguments to create many PostConsultationDocs.
     * @example
     * // Create many PostConsultationDocs
     * const postConsultationDoc = await prisma.postConsultationDoc.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostConsultationDocs and only return the `id`
     * const postConsultationDocWithIdOnly = await prisma.postConsultationDoc.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostConsultationDocCreateManyAndReturnArgs>(args?: SelectSubset<T, PostConsultationDocCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostConsultationDocPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostConsultationDoc.
     * @param {PostConsultationDocDeleteArgs} args - Arguments to delete one PostConsultationDoc.
     * @example
     * // Delete one PostConsultationDoc
     * const PostConsultationDoc = await prisma.postConsultationDoc.delete({
     *   where: {
     *     // ... filter to delete one PostConsultationDoc
     *   }
     * })
     * 
     */
    delete<T extends PostConsultationDocDeleteArgs>(args: SelectSubset<T, PostConsultationDocDeleteArgs<ExtArgs>>): Prisma__PostConsultationDocClient<$Result.GetResult<Prisma.$PostConsultationDocPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostConsultationDoc.
     * @param {PostConsultationDocUpdateArgs} args - Arguments to update one PostConsultationDoc.
     * @example
     * // Update one PostConsultationDoc
     * const postConsultationDoc = await prisma.postConsultationDoc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostConsultationDocUpdateArgs>(args: SelectSubset<T, PostConsultationDocUpdateArgs<ExtArgs>>): Prisma__PostConsultationDocClient<$Result.GetResult<Prisma.$PostConsultationDocPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostConsultationDocs.
     * @param {PostConsultationDocDeleteManyArgs} args - Arguments to filter PostConsultationDocs to delete.
     * @example
     * // Delete a few PostConsultationDocs
     * const { count } = await prisma.postConsultationDoc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostConsultationDocDeleteManyArgs>(args?: SelectSubset<T, PostConsultationDocDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostConsultationDocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostConsultationDocUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostConsultationDocs
     * const postConsultationDoc = await prisma.postConsultationDoc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostConsultationDocUpdateManyArgs>(args: SelectSubset<T, PostConsultationDocUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostConsultationDoc.
     * @param {PostConsultationDocUpsertArgs} args - Arguments to update or create a PostConsultationDoc.
     * @example
     * // Update or create a PostConsultationDoc
     * const postConsultationDoc = await prisma.postConsultationDoc.upsert({
     *   create: {
     *     // ... data to create a PostConsultationDoc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostConsultationDoc we want to update
     *   }
     * })
     */
    upsert<T extends PostConsultationDocUpsertArgs>(args: SelectSubset<T, PostConsultationDocUpsertArgs<ExtArgs>>): Prisma__PostConsultationDocClient<$Result.GetResult<Prisma.$PostConsultationDocPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostConsultationDocs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostConsultationDocCountArgs} args - Arguments to filter PostConsultationDocs to count.
     * @example
     * // Count the number of PostConsultationDocs
     * const count = await prisma.postConsultationDoc.count({
     *   where: {
     *     // ... the filter for the PostConsultationDocs we want to count
     *   }
     * })
    **/
    count<T extends PostConsultationDocCountArgs>(
      args?: Subset<T, PostConsultationDocCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostConsultationDocCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostConsultationDoc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostConsultationDocAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostConsultationDocAggregateArgs>(args: Subset<T, PostConsultationDocAggregateArgs>): Prisma.PrismaPromise<GetPostConsultationDocAggregateType<T>>

    /**
     * Group by PostConsultationDoc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostConsultationDocGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostConsultationDocGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostConsultationDocGroupByArgs['orderBy'] }
        : { orderBy?: PostConsultationDocGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostConsultationDocGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostConsultationDocGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostConsultationDoc model
   */
  readonly fields: PostConsultationDocFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostConsultationDoc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostConsultationDocClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends ConsultationTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationTaskDefaultArgs<ExtArgs>>): Prisma__ConsultationTaskClient<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostConsultationDoc model
   */ 
  interface PostConsultationDocFieldRefs {
    readonly id: FieldRef<"PostConsultationDoc", 'String'>
    readonly taskId: FieldRef<"PostConsultationDoc", 'String'>
    readonly aiContent: FieldRef<"PostConsultationDoc", 'String'>
    readonly finalContent: FieldRef<"PostConsultationDoc", 'String'>
    readonly isSubmitted: FieldRef<"PostConsultationDoc", 'Boolean'>
    readonly version: FieldRef<"PostConsultationDoc", 'Int'>
    readonly updatedAt: FieldRef<"PostConsultationDoc", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostConsultationDoc findUnique
   */
  export type PostConsultationDocFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostConsultationDoc
     */
    select?: PostConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostConsultationDocInclude<ExtArgs> | null
    /**
     * Filter, which PostConsultationDoc to fetch.
     */
    where: PostConsultationDocWhereUniqueInput
  }

  /**
   * PostConsultationDoc findUniqueOrThrow
   */
  export type PostConsultationDocFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostConsultationDoc
     */
    select?: PostConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostConsultationDocInclude<ExtArgs> | null
    /**
     * Filter, which PostConsultationDoc to fetch.
     */
    where: PostConsultationDocWhereUniqueInput
  }

  /**
   * PostConsultationDoc findFirst
   */
  export type PostConsultationDocFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostConsultationDoc
     */
    select?: PostConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostConsultationDocInclude<ExtArgs> | null
    /**
     * Filter, which PostConsultationDoc to fetch.
     */
    where?: PostConsultationDocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostConsultationDocs to fetch.
     */
    orderBy?: PostConsultationDocOrderByWithRelationInput | PostConsultationDocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostConsultationDocs.
     */
    cursor?: PostConsultationDocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostConsultationDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostConsultationDocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostConsultationDocs.
     */
    distinct?: PostConsultationDocScalarFieldEnum | PostConsultationDocScalarFieldEnum[]
  }

  /**
   * PostConsultationDoc findFirstOrThrow
   */
  export type PostConsultationDocFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostConsultationDoc
     */
    select?: PostConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostConsultationDocInclude<ExtArgs> | null
    /**
     * Filter, which PostConsultationDoc to fetch.
     */
    where?: PostConsultationDocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostConsultationDocs to fetch.
     */
    orderBy?: PostConsultationDocOrderByWithRelationInput | PostConsultationDocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostConsultationDocs.
     */
    cursor?: PostConsultationDocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostConsultationDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostConsultationDocs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostConsultationDocs.
     */
    distinct?: PostConsultationDocScalarFieldEnum | PostConsultationDocScalarFieldEnum[]
  }

  /**
   * PostConsultationDoc findMany
   */
  export type PostConsultationDocFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostConsultationDoc
     */
    select?: PostConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostConsultationDocInclude<ExtArgs> | null
    /**
     * Filter, which PostConsultationDocs to fetch.
     */
    where?: PostConsultationDocWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostConsultationDocs to fetch.
     */
    orderBy?: PostConsultationDocOrderByWithRelationInput | PostConsultationDocOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostConsultationDocs.
     */
    cursor?: PostConsultationDocWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostConsultationDocs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostConsultationDocs.
     */
    skip?: number
    distinct?: PostConsultationDocScalarFieldEnum | PostConsultationDocScalarFieldEnum[]
  }

  /**
   * PostConsultationDoc create
   */
  export type PostConsultationDocCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostConsultationDoc
     */
    select?: PostConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostConsultationDocInclude<ExtArgs> | null
    /**
     * The data needed to create a PostConsultationDoc.
     */
    data: XOR<PostConsultationDocCreateInput, PostConsultationDocUncheckedCreateInput>
  }

  /**
   * PostConsultationDoc createMany
   */
  export type PostConsultationDocCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostConsultationDocs.
     */
    data: PostConsultationDocCreateManyInput | PostConsultationDocCreateManyInput[]
  }

  /**
   * PostConsultationDoc createManyAndReturn
   */
  export type PostConsultationDocCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostConsultationDoc
     */
    select?: PostConsultationDocSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostConsultationDocs.
     */
    data: PostConsultationDocCreateManyInput | PostConsultationDocCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostConsultationDocIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostConsultationDoc update
   */
  export type PostConsultationDocUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostConsultationDoc
     */
    select?: PostConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostConsultationDocInclude<ExtArgs> | null
    /**
     * The data needed to update a PostConsultationDoc.
     */
    data: XOR<PostConsultationDocUpdateInput, PostConsultationDocUncheckedUpdateInput>
    /**
     * Choose, which PostConsultationDoc to update.
     */
    where: PostConsultationDocWhereUniqueInput
  }

  /**
   * PostConsultationDoc updateMany
   */
  export type PostConsultationDocUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostConsultationDocs.
     */
    data: XOR<PostConsultationDocUpdateManyMutationInput, PostConsultationDocUncheckedUpdateManyInput>
    /**
     * Filter which PostConsultationDocs to update
     */
    where?: PostConsultationDocWhereInput
  }

  /**
   * PostConsultationDoc upsert
   */
  export type PostConsultationDocUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostConsultationDoc
     */
    select?: PostConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostConsultationDocInclude<ExtArgs> | null
    /**
     * The filter to search for the PostConsultationDoc to update in case it exists.
     */
    where: PostConsultationDocWhereUniqueInput
    /**
     * In case the PostConsultationDoc found by the `where` argument doesn't exist, create a new PostConsultationDoc with this data.
     */
    create: XOR<PostConsultationDocCreateInput, PostConsultationDocUncheckedCreateInput>
    /**
     * In case the PostConsultationDoc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostConsultationDocUpdateInput, PostConsultationDocUncheckedUpdateInput>
  }

  /**
   * PostConsultationDoc delete
   */
  export type PostConsultationDocDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostConsultationDoc
     */
    select?: PostConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostConsultationDocInclude<ExtArgs> | null
    /**
     * Filter which PostConsultationDoc to delete.
     */
    where: PostConsultationDocWhereUniqueInput
  }

  /**
   * PostConsultationDoc deleteMany
   */
  export type PostConsultationDocDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostConsultationDocs to delete
     */
    where?: PostConsultationDocWhereInput
  }

  /**
   * PostConsultationDoc without action
   */
  export type PostConsultationDocDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostConsultationDoc
     */
    select?: PostConsultationDocSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostConsultationDocInclude<ExtArgs> | null
  }


  /**
   * Model ExpertOpinion
   */

  export type AggregateExpertOpinion = {
    _count: ExpertOpinionCountAggregateOutputType | null
    _min: ExpertOpinionMinAggregateOutputType | null
    _max: ExpertOpinionMaxAggregateOutputType | null
  }

  export type ExpertOpinionMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    expertProfileId: string | null
    audioUrl: string | null
    asrText: string | null
    aiStructured: string | null
    isAiAdopted: boolean | null
    finalText: string | null
    isSubmitted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpertOpinionMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    expertProfileId: string | null
    audioUrl: string | null
    asrText: string | null
    aiStructured: string | null
    isAiAdopted: boolean | null
    finalText: string | null
    isSubmitted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpertOpinionCountAggregateOutputType = {
    id: number
    taskId: number
    expertProfileId: number
    audioUrl: number
    asrText: number
    aiStructured: number
    isAiAdopted: number
    finalText: number
    isSubmitted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpertOpinionMinAggregateInputType = {
    id?: true
    taskId?: true
    expertProfileId?: true
    audioUrl?: true
    asrText?: true
    aiStructured?: true
    isAiAdopted?: true
    finalText?: true
    isSubmitted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpertOpinionMaxAggregateInputType = {
    id?: true
    taskId?: true
    expertProfileId?: true
    audioUrl?: true
    asrText?: true
    aiStructured?: true
    isAiAdopted?: true
    finalText?: true
    isSubmitted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpertOpinionCountAggregateInputType = {
    id?: true
    taskId?: true
    expertProfileId?: true
    audioUrl?: true
    asrText?: true
    aiStructured?: true
    isAiAdopted?: true
    finalText?: true
    isSubmitted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpertOpinionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpertOpinion to aggregate.
     */
    where?: ExpertOpinionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpertOpinions to fetch.
     */
    orderBy?: ExpertOpinionOrderByWithRelationInput | ExpertOpinionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpertOpinionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpertOpinions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpertOpinions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpertOpinions
    **/
    _count?: true | ExpertOpinionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpertOpinionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpertOpinionMaxAggregateInputType
  }

  export type GetExpertOpinionAggregateType<T extends ExpertOpinionAggregateArgs> = {
        [P in keyof T & keyof AggregateExpertOpinion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpertOpinion[P]>
      : GetScalarType<T[P], AggregateExpertOpinion[P]>
  }




  export type ExpertOpinionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpertOpinionWhereInput
    orderBy?: ExpertOpinionOrderByWithAggregationInput | ExpertOpinionOrderByWithAggregationInput[]
    by: ExpertOpinionScalarFieldEnum[] | ExpertOpinionScalarFieldEnum
    having?: ExpertOpinionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpertOpinionCountAggregateInputType | true
    _min?: ExpertOpinionMinAggregateInputType
    _max?: ExpertOpinionMaxAggregateInputType
  }

  export type ExpertOpinionGroupByOutputType = {
    id: string
    taskId: string
    expertProfileId: string
    audioUrl: string | null
    asrText: string | null
    aiStructured: string | null
    isAiAdopted: boolean
    finalText: string | null
    isSubmitted: boolean
    createdAt: Date
    updatedAt: Date
    _count: ExpertOpinionCountAggregateOutputType | null
    _min: ExpertOpinionMinAggregateOutputType | null
    _max: ExpertOpinionMaxAggregateOutputType | null
  }

  type GetExpertOpinionGroupByPayload<T extends ExpertOpinionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpertOpinionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpertOpinionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpertOpinionGroupByOutputType[P]>
            : GetScalarType<T[P], ExpertOpinionGroupByOutputType[P]>
        }
      >
    >


  export type ExpertOpinionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    expertProfileId?: boolean
    audioUrl?: boolean
    asrText?: boolean
    aiStructured?: boolean
    isAiAdopted?: boolean
    finalText?: boolean
    isSubmitted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
    expert?: boolean | ExpertProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expertOpinion"]>

  export type ExpertOpinionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    expertProfileId?: boolean
    audioUrl?: boolean
    asrText?: boolean
    aiStructured?: boolean
    isAiAdopted?: boolean
    finalText?: boolean
    isSubmitted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
    expert?: boolean | ExpertProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expertOpinion"]>

  export type ExpertOpinionSelectScalar = {
    id?: boolean
    taskId?: boolean
    expertProfileId?: boolean
    audioUrl?: boolean
    asrText?: boolean
    aiStructured?: boolean
    isAiAdopted?: boolean
    finalText?: boolean
    isSubmitted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpertOpinionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
    expert?: boolean | ExpertProfileDefaultArgs<ExtArgs>
  }
  export type ExpertOpinionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
    expert?: boolean | ExpertProfileDefaultArgs<ExtArgs>
  }

  export type $ExpertOpinionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpertOpinion"
    objects: {
      task: Prisma.$ConsultationTaskPayload<ExtArgs>
      expert: Prisma.$ExpertProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      expertProfileId: string
      audioUrl: string | null
      asrText: string | null
      aiStructured: string | null
      isAiAdopted: boolean
      finalText: string | null
      isSubmitted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expertOpinion"]>
    composites: {}
  }

  type ExpertOpinionGetPayload<S extends boolean | null | undefined | ExpertOpinionDefaultArgs> = $Result.GetResult<Prisma.$ExpertOpinionPayload, S>

  type ExpertOpinionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpertOpinionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpertOpinionCountAggregateInputType | true
    }

  export interface ExpertOpinionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpertOpinion'], meta: { name: 'ExpertOpinion' } }
    /**
     * Find zero or one ExpertOpinion that matches the filter.
     * @param {ExpertOpinionFindUniqueArgs} args - Arguments to find a ExpertOpinion
     * @example
     * // Get one ExpertOpinion
     * const expertOpinion = await prisma.expertOpinion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpertOpinionFindUniqueArgs>(args: SelectSubset<T, ExpertOpinionFindUniqueArgs<ExtArgs>>): Prisma__ExpertOpinionClient<$Result.GetResult<Prisma.$ExpertOpinionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExpertOpinion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpertOpinionFindUniqueOrThrowArgs} args - Arguments to find a ExpertOpinion
     * @example
     * // Get one ExpertOpinion
     * const expertOpinion = await prisma.expertOpinion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpertOpinionFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpertOpinionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpertOpinionClient<$Result.GetResult<Prisma.$ExpertOpinionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExpertOpinion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertOpinionFindFirstArgs} args - Arguments to find a ExpertOpinion
     * @example
     * // Get one ExpertOpinion
     * const expertOpinion = await prisma.expertOpinion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpertOpinionFindFirstArgs>(args?: SelectSubset<T, ExpertOpinionFindFirstArgs<ExtArgs>>): Prisma__ExpertOpinionClient<$Result.GetResult<Prisma.$ExpertOpinionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExpertOpinion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertOpinionFindFirstOrThrowArgs} args - Arguments to find a ExpertOpinion
     * @example
     * // Get one ExpertOpinion
     * const expertOpinion = await prisma.expertOpinion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpertOpinionFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpertOpinionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpertOpinionClient<$Result.GetResult<Prisma.$ExpertOpinionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExpertOpinions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertOpinionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpertOpinions
     * const expertOpinions = await prisma.expertOpinion.findMany()
     * 
     * // Get first 10 ExpertOpinions
     * const expertOpinions = await prisma.expertOpinion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expertOpinionWithIdOnly = await prisma.expertOpinion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpertOpinionFindManyArgs>(args?: SelectSubset<T, ExpertOpinionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpertOpinionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExpertOpinion.
     * @param {ExpertOpinionCreateArgs} args - Arguments to create a ExpertOpinion.
     * @example
     * // Create one ExpertOpinion
     * const ExpertOpinion = await prisma.expertOpinion.create({
     *   data: {
     *     // ... data to create a ExpertOpinion
     *   }
     * })
     * 
     */
    create<T extends ExpertOpinionCreateArgs>(args: SelectSubset<T, ExpertOpinionCreateArgs<ExtArgs>>): Prisma__ExpertOpinionClient<$Result.GetResult<Prisma.$ExpertOpinionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExpertOpinions.
     * @param {ExpertOpinionCreateManyArgs} args - Arguments to create many ExpertOpinions.
     * @example
     * // Create many ExpertOpinions
     * const expertOpinion = await prisma.expertOpinion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpertOpinionCreateManyArgs>(args?: SelectSubset<T, ExpertOpinionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpertOpinions and returns the data saved in the database.
     * @param {ExpertOpinionCreateManyAndReturnArgs} args - Arguments to create many ExpertOpinions.
     * @example
     * // Create many ExpertOpinions
     * const expertOpinion = await prisma.expertOpinion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpertOpinions and only return the `id`
     * const expertOpinionWithIdOnly = await prisma.expertOpinion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpertOpinionCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpertOpinionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpertOpinionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExpertOpinion.
     * @param {ExpertOpinionDeleteArgs} args - Arguments to delete one ExpertOpinion.
     * @example
     * // Delete one ExpertOpinion
     * const ExpertOpinion = await prisma.expertOpinion.delete({
     *   where: {
     *     // ... filter to delete one ExpertOpinion
     *   }
     * })
     * 
     */
    delete<T extends ExpertOpinionDeleteArgs>(args: SelectSubset<T, ExpertOpinionDeleteArgs<ExtArgs>>): Prisma__ExpertOpinionClient<$Result.GetResult<Prisma.$ExpertOpinionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExpertOpinion.
     * @param {ExpertOpinionUpdateArgs} args - Arguments to update one ExpertOpinion.
     * @example
     * // Update one ExpertOpinion
     * const expertOpinion = await prisma.expertOpinion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpertOpinionUpdateArgs>(args: SelectSubset<T, ExpertOpinionUpdateArgs<ExtArgs>>): Prisma__ExpertOpinionClient<$Result.GetResult<Prisma.$ExpertOpinionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExpertOpinions.
     * @param {ExpertOpinionDeleteManyArgs} args - Arguments to filter ExpertOpinions to delete.
     * @example
     * // Delete a few ExpertOpinions
     * const { count } = await prisma.expertOpinion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpertOpinionDeleteManyArgs>(args?: SelectSubset<T, ExpertOpinionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpertOpinions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertOpinionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpertOpinions
     * const expertOpinion = await prisma.expertOpinion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpertOpinionUpdateManyArgs>(args: SelectSubset<T, ExpertOpinionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExpertOpinion.
     * @param {ExpertOpinionUpsertArgs} args - Arguments to update or create a ExpertOpinion.
     * @example
     * // Update or create a ExpertOpinion
     * const expertOpinion = await prisma.expertOpinion.upsert({
     *   create: {
     *     // ... data to create a ExpertOpinion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpertOpinion we want to update
     *   }
     * })
     */
    upsert<T extends ExpertOpinionUpsertArgs>(args: SelectSubset<T, ExpertOpinionUpsertArgs<ExtArgs>>): Prisma__ExpertOpinionClient<$Result.GetResult<Prisma.$ExpertOpinionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExpertOpinions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertOpinionCountArgs} args - Arguments to filter ExpertOpinions to count.
     * @example
     * // Count the number of ExpertOpinions
     * const count = await prisma.expertOpinion.count({
     *   where: {
     *     // ... the filter for the ExpertOpinions we want to count
     *   }
     * })
    **/
    count<T extends ExpertOpinionCountArgs>(
      args?: Subset<T, ExpertOpinionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpertOpinionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpertOpinion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertOpinionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpertOpinionAggregateArgs>(args: Subset<T, ExpertOpinionAggregateArgs>): Prisma.PrismaPromise<GetExpertOpinionAggregateType<T>>

    /**
     * Group by ExpertOpinion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpertOpinionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpertOpinionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpertOpinionGroupByArgs['orderBy'] }
        : { orderBy?: ExpertOpinionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpertOpinionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpertOpinionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpertOpinion model
   */
  readonly fields: ExpertOpinionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpertOpinion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpertOpinionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends ConsultationTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationTaskDefaultArgs<ExtArgs>>): Prisma__ConsultationTaskClient<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    expert<T extends ExpertProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExpertProfileDefaultArgs<ExtArgs>>): Prisma__ExpertProfileClient<$Result.GetResult<Prisma.$ExpertProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpertOpinion model
   */ 
  interface ExpertOpinionFieldRefs {
    readonly id: FieldRef<"ExpertOpinion", 'String'>
    readonly taskId: FieldRef<"ExpertOpinion", 'String'>
    readonly expertProfileId: FieldRef<"ExpertOpinion", 'String'>
    readonly audioUrl: FieldRef<"ExpertOpinion", 'String'>
    readonly asrText: FieldRef<"ExpertOpinion", 'String'>
    readonly aiStructured: FieldRef<"ExpertOpinion", 'String'>
    readonly isAiAdopted: FieldRef<"ExpertOpinion", 'Boolean'>
    readonly finalText: FieldRef<"ExpertOpinion", 'String'>
    readonly isSubmitted: FieldRef<"ExpertOpinion", 'Boolean'>
    readonly createdAt: FieldRef<"ExpertOpinion", 'DateTime'>
    readonly updatedAt: FieldRef<"ExpertOpinion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpertOpinion findUnique
   */
  export type ExpertOpinionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertOpinion
     */
    select?: ExpertOpinionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertOpinionInclude<ExtArgs> | null
    /**
     * Filter, which ExpertOpinion to fetch.
     */
    where: ExpertOpinionWhereUniqueInput
  }

  /**
   * ExpertOpinion findUniqueOrThrow
   */
  export type ExpertOpinionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertOpinion
     */
    select?: ExpertOpinionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertOpinionInclude<ExtArgs> | null
    /**
     * Filter, which ExpertOpinion to fetch.
     */
    where: ExpertOpinionWhereUniqueInput
  }

  /**
   * ExpertOpinion findFirst
   */
  export type ExpertOpinionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertOpinion
     */
    select?: ExpertOpinionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertOpinionInclude<ExtArgs> | null
    /**
     * Filter, which ExpertOpinion to fetch.
     */
    where?: ExpertOpinionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpertOpinions to fetch.
     */
    orderBy?: ExpertOpinionOrderByWithRelationInput | ExpertOpinionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpertOpinions.
     */
    cursor?: ExpertOpinionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpertOpinions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpertOpinions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpertOpinions.
     */
    distinct?: ExpertOpinionScalarFieldEnum | ExpertOpinionScalarFieldEnum[]
  }

  /**
   * ExpertOpinion findFirstOrThrow
   */
  export type ExpertOpinionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertOpinion
     */
    select?: ExpertOpinionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertOpinionInclude<ExtArgs> | null
    /**
     * Filter, which ExpertOpinion to fetch.
     */
    where?: ExpertOpinionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpertOpinions to fetch.
     */
    orderBy?: ExpertOpinionOrderByWithRelationInput | ExpertOpinionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpertOpinions.
     */
    cursor?: ExpertOpinionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpertOpinions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpertOpinions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpertOpinions.
     */
    distinct?: ExpertOpinionScalarFieldEnum | ExpertOpinionScalarFieldEnum[]
  }

  /**
   * ExpertOpinion findMany
   */
  export type ExpertOpinionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertOpinion
     */
    select?: ExpertOpinionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertOpinionInclude<ExtArgs> | null
    /**
     * Filter, which ExpertOpinions to fetch.
     */
    where?: ExpertOpinionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpertOpinions to fetch.
     */
    orderBy?: ExpertOpinionOrderByWithRelationInput | ExpertOpinionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpertOpinions.
     */
    cursor?: ExpertOpinionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpertOpinions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpertOpinions.
     */
    skip?: number
    distinct?: ExpertOpinionScalarFieldEnum | ExpertOpinionScalarFieldEnum[]
  }

  /**
   * ExpertOpinion create
   */
  export type ExpertOpinionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertOpinion
     */
    select?: ExpertOpinionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertOpinionInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpertOpinion.
     */
    data: XOR<ExpertOpinionCreateInput, ExpertOpinionUncheckedCreateInput>
  }

  /**
   * ExpertOpinion createMany
   */
  export type ExpertOpinionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpertOpinions.
     */
    data: ExpertOpinionCreateManyInput | ExpertOpinionCreateManyInput[]
  }

  /**
   * ExpertOpinion createManyAndReturn
   */
  export type ExpertOpinionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertOpinion
     */
    select?: ExpertOpinionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExpertOpinions.
     */
    data: ExpertOpinionCreateManyInput | ExpertOpinionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertOpinionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExpertOpinion update
   */
  export type ExpertOpinionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertOpinion
     */
    select?: ExpertOpinionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertOpinionInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpertOpinion.
     */
    data: XOR<ExpertOpinionUpdateInput, ExpertOpinionUncheckedUpdateInput>
    /**
     * Choose, which ExpertOpinion to update.
     */
    where: ExpertOpinionWhereUniqueInput
  }

  /**
   * ExpertOpinion updateMany
   */
  export type ExpertOpinionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpertOpinions.
     */
    data: XOR<ExpertOpinionUpdateManyMutationInput, ExpertOpinionUncheckedUpdateManyInput>
    /**
     * Filter which ExpertOpinions to update
     */
    where?: ExpertOpinionWhereInput
  }

  /**
   * ExpertOpinion upsert
   */
  export type ExpertOpinionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertOpinion
     */
    select?: ExpertOpinionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertOpinionInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpertOpinion to update in case it exists.
     */
    where: ExpertOpinionWhereUniqueInput
    /**
     * In case the ExpertOpinion found by the `where` argument doesn't exist, create a new ExpertOpinion with this data.
     */
    create: XOR<ExpertOpinionCreateInput, ExpertOpinionUncheckedCreateInput>
    /**
     * In case the ExpertOpinion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpertOpinionUpdateInput, ExpertOpinionUncheckedUpdateInput>
  }

  /**
   * ExpertOpinion delete
   */
  export type ExpertOpinionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertOpinion
     */
    select?: ExpertOpinionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertOpinionInclude<ExtArgs> | null
    /**
     * Filter which ExpertOpinion to delete.
     */
    where: ExpertOpinionWhereUniqueInput
  }

  /**
   * ExpertOpinion deleteMany
   */
  export type ExpertOpinionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpertOpinions to delete
     */
    where?: ExpertOpinionWhereInput
  }

  /**
   * ExpertOpinion without action
   */
  export type ExpertOpinionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpertOpinion
     */
    select?: ExpertOpinionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpertOpinionInclude<ExtArgs> | null
  }


  /**
   * Model ConsultationReport
   */

  export type AggregateConsultationReport = {
    _count: ConsultationReportCountAggregateOutputType | null
    _min: ConsultationReportMinAggregateOutputType | null
    _max: ConsultationReportMaxAggregateOutputType | null
  }

  export type ConsultationReportMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    aiSummary: string | null
    finalSummary: string | null
    aiEducation: string | null
    finalEducation: string | null
    pdfUrl: string | null
    isSigned: boolean | null
    completedAt: Date | null
  }

  export type ConsultationReportMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    aiSummary: string | null
    finalSummary: string | null
    aiEducation: string | null
    finalEducation: string | null
    pdfUrl: string | null
    isSigned: boolean | null
    completedAt: Date | null
  }

  export type ConsultationReportCountAggregateOutputType = {
    id: number
    taskId: number
    aiSummary: number
    finalSummary: number
    aiEducation: number
    finalEducation: number
    pdfUrl: number
    isSigned: number
    completedAt: number
    _all: number
  }


  export type ConsultationReportMinAggregateInputType = {
    id?: true
    taskId?: true
    aiSummary?: true
    finalSummary?: true
    aiEducation?: true
    finalEducation?: true
    pdfUrl?: true
    isSigned?: true
    completedAt?: true
  }

  export type ConsultationReportMaxAggregateInputType = {
    id?: true
    taskId?: true
    aiSummary?: true
    finalSummary?: true
    aiEducation?: true
    finalEducation?: true
    pdfUrl?: true
    isSigned?: true
    completedAt?: true
  }

  export type ConsultationReportCountAggregateInputType = {
    id?: true
    taskId?: true
    aiSummary?: true
    finalSummary?: true
    aiEducation?: true
    finalEducation?: true
    pdfUrl?: true
    isSigned?: true
    completedAt?: true
    _all?: true
  }

  export type ConsultationReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsultationReport to aggregate.
     */
    where?: ConsultationReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationReports to fetch.
     */
    orderBy?: ConsultationReportOrderByWithRelationInput | ConsultationReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsultationReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConsultationReports
    **/
    _count?: true | ConsultationReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultationReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultationReportMaxAggregateInputType
  }

  export type GetConsultationReportAggregateType<T extends ConsultationReportAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultationReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultationReport[P]>
      : GetScalarType<T[P], AggregateConsultationReport[P]>
  }




  export type ConsultationReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationReportWhereInput
    orderBy?: ConsultationReportOrderByWithAggregationInput | ConsultationReportOrderByWithAggregationInput[]
    by: ConsultationReportScalarFieldEnum[] | ConsultationReportScalarFieldEnum
    having?: ConsultationReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultationReportCountAggregateInputType | true
    _min?: ConsultationReportMinAggregateInputType
    _max?: ConsultationReportMaxAggregateInputType
  }

  export type ConsultationReportGroupByOutputType = {
    id: string
    taskId: string
    aiSummary: string | null
    finalSummary: string
    aiEducation: string | null
    finalEducation: string
    pdfUrl: string | null
    isSigned: boolean
    completedAt: Date
    _count: ConsultationReportCountAggregateOutputType | null
    _min: ConsultationReportMinAggregateOutputType | null
    _max: ConsultationReportMaxAggregateOutputType | null
  }

  type GetConsultationReportGroupByPayload<T extends ConsultationReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultationReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultationReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultationReportGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultationReportGroupByOutputType[P]>
        }
      >
    >


  export type ConsultationReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    aiSummary?: boolean
    finalSummary?: boolean
    aiEducation?: boolean
    finalEducation?: boolean
    pdfUrl?: boolean
    isSigned?: boolean
    completedAt?: boolean
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultationReport"]>

  export type ConsultationReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    aiSummary?: boolean
    finalSummary?: boolean
    aiEducation?: boolean
    finalEducation?: boolean
    pdfUrl?: boolean
    isSigned?: boolean
    completedAt?: boolean
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultationReport"]>

  export type ConsultationReportSelectScalar = {
    id?: boolean
    taskId?: boolean
    aiSummary?: boolean
    finalSummary?: boolean
    aiEducation?: boolean
    finalEducation?: boolean
    pdfUrl?: boolean
    isSigned?: boolean
    completedAt?: boolean
  }

  export type ConsultationReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
  }
  export type ConsultationReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
  }

  export type $ConsultationReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConsultationReport"
    objects: {
      task: Prisma.$ConsultationTaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      aiSummary: string | null
      finalSummary: string
      aiEducation: string | null
      finalEducation: string
      pdfUrl: string | null
      isSigned: boolean
      completedAt: Date
    }, ExtArgs["result"]["consultationReport"]>
    composites: {}
  }

  type ConsultationReportGetPayload<S extends boolean | null | undefined | ConsultationReportDefaultArgs> = $Result.GetResult<Prisma.$ConsultationReportPayload, S>

  type ConsultationReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConsultationReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConsultationReportCountAggregateInputType | true
    }

  export interface ConsultationReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConsultationReport'], meta: { name: 'ConsultationReport' } }
    /**
     * Find zero or one ConsultationReport that matches the filter.
     * @param {ConsultationReportFindUniqueArgs} args - Arguments to find a ConsultationReport
     * @example
     * // Get one ConsultationReport
     * const consultationReport = await prisma.consultationReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsultationReportFindUniqueArgs>(args: SelectSubset<T, ConsultationReportFindUniqueArgs<ExtArgs>>): Prisma__ConsultationReportClient<$Result.GetResult<Prisma.$ConsultationReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConsultationReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConsultationReportFindUniqueOrThrowArgs} args - Arguments to find a ConsultationReport
     * @example
     * // Get one ConsultationReport
     * const consultationReport = await prisma.consultationReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsultationReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsultationReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsultationReportClient<$Result.GetResult<Prisma.$ConsultationReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConsultationReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationReportFindFirstArgs} args - Arguments to find a ConsultationReport
     * @example
     * // Get one ConsultationReport
     * const consultationReport = await prisma.consultationReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsultationReportFindFirstArgs>(args?: SelectSubset<T, ConsultationReportFindFirstArgs<ExtArgs>>): Prisma__ConsultationReportClient<$Result.GetResult<Prisma.$ConsultationReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConsultationReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationReportFindFirstOrThrowArgs} args - Arguments to find a ConsultationReport
     * @example
     * // Get one ConsultationReport
     * const consultationReport = await prisma.consultationReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsultationReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsultationReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsultationReportClient<$Result.GetResult<Prisma.$ConsultationReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConsultationReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsultationReports
     * const consultationReports = await prisma.consultationReport.findMany()
     * 
     * // Get first 10 ConsultationReports
     * const consultationReports = await prisma.consultationReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultationReportWithIdOnly = await prisma.consultationReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsultationReportFindManyArgs>(args?: SelectSubset<T, ConsultationReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConsultationReport.
     * @param {ConsultationReportCreateArgs} args - Arguments to create a ConsultationReport.
     * @example
     * // Create one ConsultationReport
     * const ConsultationReport = await prisma.consultationReport.create({
     *   data: {
     *     // ... data to create a ConsultationReport
     *   }
     * })
     * 
     */
    create<T extends ConsultationReportCreateArgs>(args: SelectSubset<T, ConsultationReportCreateArgs<ExtArgs>>): Prisma__ConsultationReportClient<$Result.GetResult<Prisma.$ConsultationReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConsultationReports.
     * @param {ConsultationReportCreateManyArgs} args - Arguments to create many ConsultationReports.
     * @example
     * // Create many ConsultationReports
     * const consultationReport = await prisma.consultationReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsultationReportCreateManyArgs>(args?: SelectSubset<T, ConsultationReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConsultationReports and returns the data saved in the database.
     * @param {ConsultationReportCreateManyAndReturnArgs} args - Arguments to create many ConsultationReports.
     * @example
     * // Create many ConsultationReports
     * const consultationReport = await prisma.consultationReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConsultationReports and only return the `id`
     * const consultationReportWithIdOnly = await prisma.consultationReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsultationReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsultationReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConsultationReport.
     * @param {ConsultationReportDeleteArgs} args - Arguments to delete one ConsultationReport.
     * @example
     * // Delete one ConsultationReport
     * const ConsultationReport = await prisma.consultationReport.delete({
     *   where: {
     *     // ... filter to delete one ConsultationReport
     *   }
     * })
     * 
     */
    delete<T extends ConsultationReportDeleteArgs>(args: SelectSubset<T, ConsultationReportDeleteArgs<ExtArgs>>): Prisma__ConsultationReportClient<$Result.GetResult<Prisma.$ConsultationReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConsultationReport.
     * @param {ConsultationReportUpdateArgs} args - Arguments to update one ConsultationReport.
     * @example
     * // Update one ConsultationReport
     * const consultationReport = await prisma.consultationReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsultationReportUpdateArgs>(args: SelectSubset<T, ConsultationReportUpdateArgs<ExtArgs>>): Prisma__ConsultationReportClient<$Result.GetResult<Prisma.$ConsultationReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConsultationReports.
     * @param {ConsultationReportDeleteManyArgs} args - Arguments to filter ConsultationReports to delete.
     * @example
     * // Delete a few ConsultationReports
     * const { count } = await prisma.consultationReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsultationReportDeleteManyArgs>(args?: SelectSubset<T, ConsultationReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsultationReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsultationReports
     * const consultationReport = await prisma.consultationReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsultationReportUpdateManyArgs>(args: SelectSubset<T, ConsultationReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConsultationReport.
     * @param {ConsultationReportUpsertArgs} args - Arguments to update or create a ConsultationReport.
     * @example
     * // Update or create a ConsultationReport
     * const consultationReport = await prisma.consultationReport.upsert({
     *   create: {
     *     // ... data to create a ConsultationReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsultationReport we want to update
     *   }
     * })
     */
    upsert<T extends ConsultationReportUpsertArgs>(args: SelectSubset<T, ConsultationReportUpsertArgs<ExtArgs>>): Prisma__ConsultationReportClient<$Result.GetResult<Prisma.$ConsultationReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConsultationReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationReportCountArgs} args - Arguments to filter ConsultationReports to count.
     * @example
     * // Count the number of ConsultationReports
     * const count = await prisma.consultationReport.count({
     *   where: {
     *     // ... the filter for the ConsultationReports we want to count
     *   }
     * })
    **/
    count<T extends ConsultationReportCountArgs>(
      args?: Subset<T, ConsultationReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultationReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsultationReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultationReportAggregateArgs>(args: Subset<T, ConsultationReportAggregateArgs>): Prisma.PrismaPromise<GetConsultationReportAggregateType<T>>

    /**
     * Group by ConsultationReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultationReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultationReportGroupByArgs['orderBy'] }
        : { orderBy?: ConsultationReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultationReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultationReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConsultationReport model
   */
  readonly fields: ConsultationReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConsultationReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsultationReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends ConsultationTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationTaskDefaultArgs<ExtArgs>>): Prisma__ConsultationTaskClient<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConsultationReport model
   */ 
  interface ConsultationReportFieldRefs {
    readonly id: FieldRef<"ConsultationReport", 'String'>
    readonly taskId: FieldRef<"ConsultationReport", 'String'>
    readonly aiSummary: FieldRef<"ConsultationReport", 'String'>
    readonly finalSummary: FieldRef<"ConsultationReport", 'String'>
    readonly aiEducation: FieldRef<"ConsultationReport", 'String'>
    readonly finalEducation: FieldRef<"ConsultationReport", 'String'>
    readonly pdfUrl: FieldRef<"ConsultationReport", 'String'>
    readonly isSigned: FieldRef<"ConsultationReport", 'Boolean'>
    readonly completedAt: FieldRef<"ConsultationReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConsultationReport findUnique
   */
  export type ConsultationReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationReport
     */
    select?: ConsultationReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationReportInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationReport to fetch.
     */
    where: ConsultationReportWhereUniqueInput
  }

  /**
   * ConsultationReport findUniqueOrThrow
   */
  export type ConsultationReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationReport
     */
    select?: ConsultationReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationReportInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationReport to fetch.
     */
    where: ConsultationReportWhereUniqueInput
  }

  /**
   * ConsultationReport findFirst
   */
  export type ConsultationReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationReport
     */
    select?: ConsultationReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationReportInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationReport to fetch.
     */
    where?: ConsultationReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationReports to fetch.
     */
    orderBy?: ConsultationReportOrderByWithRelationInput | ConsultationReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultationReports.
     */
    cursor?: ConsultationReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultationReports.
     */
    distinct?: ConsultationReportScalarFieldEnum | ConsultationReportScalarFieldEnum[]
  }

  /**
   * ConsultationReport findFirstOrThrow
   */
  export type ConsultationReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationReport
     */
    select?: ConsultationReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationReportInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationReport to fetch.
     */
    where?: ConsultationReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationReports to fetch.
     */
    orderBy?: ConsultationReportOrderByWithRelationInput | ConsultationReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultationReports.
     */
    cursor?: ConsultationReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultationReports.
     */
    distinct?: ConsultationReportScalarFieldEnum | ConsultationReportScalarFieldEnum[]
  }

  /**
   * ConsultationReport findMany
   */
  export type ConsultationReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationReport
     */
    select?: ConsultationReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationReportInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationReports to fetch.
     */
    where?: ConsultationReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationReports to fetch.
     */
    orderBy?: ConsultationReportOrderByWithRelationInput | ConsultationReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConsultationReports.
     */
    cursor?: ConsultationReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationReports.
     */
    skip?: number
    distinct?: ConsultationReportScalarFieldEnum | ConsultationReportScalarFieldEnum[]
  }

  /**
   * ConsultationReport create
   */
  export type ConsultationReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationReport
     */
    select?: ConsultationReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ConsultationReport.
     */
    data: XOR<ConsultationReportCreateInput, ConsultationReportUncheckedCreateInput>
  }

  /**
   * ConsultationReport createMany
   */
  export type ConsultationReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConsultationReports.
     */
    data: ConsultationReportCreateManyInput | ConsultationReportCreateManyInput[]
  }

  /**
   * ConsultationReport createManyAndReturn
   */
  export type ConsultationReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationReport
     */
    select?: ConsultationReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConsultationReports.
     */
    data: ConsultationReportCreateManyInput | ConsultationReportCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConsultationReport update
   */
  export type ConsultationReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationReport
     */
    select?: ConsultationReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ConsultationReport.
     */
    data: XOR<ConsultationReportUpdateInput, ConsultationReportUncheckedUpdateInput>
    /**
     * Choose, which ConsultationReport to update.
     */
    where: ConsultationReportWhereUniqueInput
  }

  /**
   * ConsultationReport updateMany
   */
  export type ConsultationReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConsultationReports.
     */
    data: XOR<ConsultationReportUpdateManyMutationInput, ConsultationReportUncheckedUpdateManyInput>
    /**
     * Filter which ConsultationReports to update
     */
    where?: ConsultationReportWhereInput
  }

  /**
   * ConsultationReport upsert
   */
  export type ConsultationReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationReport
     */
    select?: ConsultationReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ConsultationReport to update in case it exists.
     */
    where: ConsultationReportWhereUniqueInput
    /**
     * In case the ConsultationReport found by the `where` argument doesn't exist, create a new ConsultationReport with this data.
     */
    create: XOR<ConsultationReportCreateInput, ConsultationReportUncheckedCreateInput>
    /**
     * In case the ConsultationReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsultationReportUpdateInput, ConsultationReportUncheckedUpdateInput>
  }

  /**
   * ConsultationReport delete
   */
  export type ConsultationReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationReport
     */
    select?: ConsultationReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationReportInclude<ExtArgs> | null
    /**
     * Filter which ConsultationReport to delete.
     */
    where: ConsultationReportWhereUniqueInput
  }

  /**
   * ConsultationReport deleteMany
   */
  export type ConsultationReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsultationReports to delete
     */
    where?: ConsultationReportWhereInput
  }

  /**
   * ConsultationReport without action
   */
  export type ConsultationReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationReport
     */
    select?: ConsultationReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationReportInclude<ExtArgs> | null
  }


  /**
   * Model TaskLog
   */

  export type AggregateTaskLog = {
    _count: TaskLogCountAggregateOutputType | null
    _min: TaskLogMinAggregateOutputType | null
    _max: TaskLogMaxAggregateOutputType | null
  }

  export type TaskLogMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    operatorId: string | null
    action: string | null
    details: string | null
    createdAt: Date | null
  }

  export type TaskLogMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    operatorId: string | null
    action: string | null
    details: string | null
    createdAt: Date | null
  }

  export type TaskLogCountAggregateOutputType = {
    id: number
    taskId: number
    operatorId: number
    action: number
    details: number
    createdAt: number
    _all: number
  }


  export type TaskLogMinAggregateInputType = {
    id?: true
    taskId?: true
    operatorId?: true
    action?: true
    details?: true
    createdAt?: true
  }

  export type TaskLogMaxAggregateInputType = {
    id?: true
    taskId?: true
    operatorId?: true
    action?: true
    details?: true
    createdAt?: true
  }

  export type TaskLogCountAggregateInputType = {
    id?: true
    taskId?: true
    operatorId?: true
    action?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type TaskLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskLog to aggregate.
     */
    where?: TaskLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLogs to fetch.
     */
    orderBy?: TaskLogOrderByWithRelationInput | TaskLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskLogs
    **/
    _count?: true | TaskLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskLogMaxAggregateInputType
  }

  export type GetTaskLogAggregateType<T extends TaskLogAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskLog[P]>
      : GetScalarType<T[P], AggregateTaskLog[P]>
  }




  export type TaskLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskLogWhereInput
    orderBy?: TaskLogOrderByWithAggregationInput | TaskLogOrderByWithAggregationInput[]
    by: TaskLogScalarFieldEnum[] | TaskLogScalarFieldEnum
    having?: TaskLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskLogCountAggregateInputType | true
    _min?: TaskLogMinAggregateInputType
    _max?: TaskLogMaxAggregateInputType
  }

  export type TaskLogGroupByOutputType = {
    id: string
    taskId: string
    operatorId: string | null
    action: string
    details: string | null
    createdAt: Date
    _count: TaskLogCountAggregateOutputType | null
    _min: TaskLogMinAggregateOutputType | null
    _max: TaskLogMaxAggregateOutputType | null
  }

  type GetTaskLogGroupByPayload<T extends TaskLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskLogGroupByOutputType[P]>
            : GetScalarType<T[P], TaskLogGroupByOutputType[P]>
        }
      >
    >


  export type TaskLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    operatorId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
    operator?: boolean | TaskLog$operatorArgs<ExtArgs>
  }, ExtArgs["result"]["taskLog"]>

  export type TaskLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    operatorId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
    operator?: boolean | TaskLog$operatorArgs<ExtArgs>
  }, ExtArgs["result"]["taskLog"]>

  export type TaskLogSelectScalar = {
    id?: boolean
    taskId?: boolean
    operatorId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type TaskLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
    operator?: boolean | TaskLog$operatorArgs<ExtArgs>
  }
  export type TaskLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | ConsultationTaskDefaultArgs<ExtArgs>
    operator?: boolean | TaskLog$operatorArgs<ExtArgs>
  }

  export type $TaskLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskLog"
    objects: {
      task: Prisma.$ConsultationTaskPayload<ExtArgs>
      operator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      operatorId: string | null
      action: string
      details: string | null
      createdAt: Date
    }, ExtArgs["result"]["taskLog"]>
    composites: {}
  }

  type TaskLogGetPayload<S extends boolean | null | undefined | TaskLogDefaultArgs> = $Result.GetResult<Prisma.$TaskLogPayload, S>

  type TaskLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskLogCountAggregateInputType | true
    }

  export interface TaskLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskLog'], meta: { name: 'TaskLog' } }
    /**
     * Find zero or one TaskLog that matches the filter.
     * @param {TaskLogFindUniqueArgs} args - Arguments to find a TaskLog
     * @example
     * // Get one TaskLog
     * const taskLog = await prisma.taskLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskLogFindUniqueArgs>(args: SelectSubset<T, TaskLogFindUniqueArgs<ExtArgs>>): Prisma__TaskLogClient<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskLogFindUniqueOrThrowArgs} args - Arguments to find a TaskLog
     * @example
     * // Get one TaskLog
     * const taskLog = await prisma.taskLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskLogFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskLogClient<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLogFindFirstArgs} args - Arguments to find a TaskLog
     * @example
     * // Get one TaskLog
     * const taskLog = await prisma.taskLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskLogFindFirstArgs>(args?: SelectSubset<T, TaskLogFindFirstArgs<ExtArgs>>): Prisma__TaskLogClient<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLogFindFirstOrThrowArgs} args - Arguments to find a TaskLog
     * @example
     * // Get one TaskLog
     * const taskLog = await prisma.taskLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskLogFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskLogClient<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskLogs
     * const taskLogs = await prisma.taskLog.findMany()
     * 
     * // Get first 10 TaskLogs
     * const taskLogs = await prisma.taskLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskLogWithIdOnly = await prisma.taskLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskLogFindManyArgs>(args?: SelectSubset<T, TaskLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskLog.
     * @param {TaskLogCreateArgs} args - Arguments to create a TaskLog.
     * @example
     * // Create one TaskLog
     * const TaskLog = await prisma.taskLog.create({
     *   data: {
     *     // ... data to create a TaskLog
     *   }
     * })
     * 
     */
    create<T extends TaskLogCreateArgs>(args: SelectSubset<T, TaskLogCreateArgs<ExtArgs>>): Prisma__TaskLogClient<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskLogs.
     * @param {TaskLogCreateManyArgs} args - Arguments to create many TaskLogs.
     * @example
     * // Create many TaskLogs
     * const taskLog = await prisma.taskLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskLogCreateManyArgs>(args?: SelectSubset<T, TaskLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskLogs and returns the data saved in the database.
     * @param {TaskLogCreateManyAndReturnArgs} args - Arguments to create many TaskLogs.
     * @example
     * // Create many TaskLogs
     * const taskLog = await prisma.taskLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskLogs and only return the `id`
     * const taskLogWithIdOnly = await prisma.taskLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskLogCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskLog.
     * @param {TaskLogDeleteArgs} args - Arguments to delete one TaskLog.
     * @example
     * // Delete one TaskLog
     * const TaskLog = await prisma.taskLog.delete({
     *   where: {
     *     // ... filter to delete one TaskLog
     *   }
     * })
     * 
     */
    delete<T extends TaskLogDeleteArgs>(args: SelectSubset<T, TaskLogDeleteArgs<ExtArgs>>): Prisma__TaskLogClient<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskLog.
     * @param {TaskLogUpdateArgs} args - Arguments to update one TaskLog.
     * @example
     * // Update one TaskLog
     * const taskLog = await prisma.taskLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskLogUpdateArgs>(args: SelectSubset<T, TaskLogUpdateArgs<ExtArgs>>): Prisma__TaskLogClient<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskLogs.
     * @param {TaskLogDeleteManyArgs} args - Arguments to filter TaskLogs to delete.
     * @example
     * // Delete a few TaskLogs
     * const { count } = await prisma.taskLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskLogDeleteManyArgs>(args?: SelectSubset<T, TaskLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskLogs
     * const taskLog = await prisma.taskLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskLogUpdateManyArgs>(args: SelectSubset<T, TaskLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskLog.
     * @param {TaskLogUpsertArgs} args - Arguments to update or create a TaskLog.
     * @example
     * // Update or create a TaskLog
     * const taskLog = await prisma.taskLog.upsert({
     *   create: {
     *     // ... data to create a TaskLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskLog we want to update
     *   }
     * })
     */
    upsert<T extends TaskLogUpsertArgs>(args: SelectSubset<T, TaskLogUpsertArgs<ExtArgs>>): Prisma__TaskLogClient<$Result.GetResult<Prisma.$TaskLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLogCountArgs} args - Arguments to filter TaskLogs to count.
     * @example
     * // Count the number of TaskLogs
     * const count = await prisma.taskLog.count({
     *   where: {
     *     // ... the filter for the TaskLogs we want to count
     *   }
     * })
    **/
    count<T extends TaskLogCountArgs>(
      args?: Subset<T, TaskLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskLogAggregateArgs>(args: Subset<T, TaskLogAggregateArgs>): Prisma.PrismaPromise<GetTaskLogAggregateType<T>>

    /**
     * Group by TaskLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskLogGroupByArgs['orderBy'] }
        : { orderBy?: TaskLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskLog model
   */
  readonly fields: TaskLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends ConsultationTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationTaskDefaultArgs<ExtArgs>>): Prisma__ConsultationTaskClient<$Result.GetResult<Prisma.$ConsultationTaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    operator<T extends TaskLog$operatorArgs<ExtArgs> = {}>(args?: Subset<T, TaskLog$operatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskLog model
   */ 
  interface TaskLogFieldRefs {
    readonly id: FieldRef<"TaskLog", 'String'>
    readonly taskId: FieldRef<"TaskLog", 'String'>
    readonly operatorId: FieldRef<"TaskLog", 'String'>
    readonly action: FieldRef<"TaskLog", 'String'>
    readonly details: FieldRef<"TaskLog", 'String'>
    readonly createdAt: FieldRef<"TaskLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskLog findUnique
   */
  export type TaskLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskLog to fetch.
     */
    where: TaskLogWhereUniqueInput
  }

  /**
   * TaskLog findUniqueOrThrow
   */
  export type TaskLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskLog to fetch.
     */
    where: TaskLogWhereUniqueInput
  }

  /**
   * TaskLog findFirst
   */
  export type TaskLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskLog to fetch.
     */
    where?: TaskLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLogs to fetch.
     */
    orderBy?: TaskLogOrderByWithRelationInput | TaskLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskLogs.
     */
    cursor?: TaskLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskLogs.
     */
    distinct?: TaskLogScalarFieldEnum | TaskLogScalarFieldEnum[]
  }

  /**
   * TaskLog findFirstOrThrow
   */
  export type TaskLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskLog to fetch.
     */
    where?: TaskLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLogs to fetch.
     */
    orderBy?: TaskLogOrderByWithRelationInput | TaskLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskLogs.
     */
    cursor?: TaskLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskLogs.
     */
    distinct?: TaskLogScalarFieldEnum | TaskLogScalarFieldEnum[]
  }

  /**
   * TaskLog findMany
   */
  export type TaskLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * Filter, which TaskLogs to fetch.
     */
    where?: TaskLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskLogs to fetch.
     */
    orderBy?: TaskLogOrderByWithRelationInput | TaskLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskLogs.
     */
    cursor?: TaskLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskLogs.
     */
    skip?: number
    distinct?: TaskLogScalarFieldEnum | TaskLogScalarFieldEnum[]
  }

  /**
   * TaskLog create
   */
  export type TaskLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskLog.
     */
    data: XOR<TaskLogCreateInput, TaskLogUncheckedCreateInput>
  }

  /**
   * TaskLog createMany
   */
  export type TaskLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskLogs.
     */
    data: TaskLogCreateManyInput | TaskLogCreateManyInput[]
  }

  /**
   * TaskLog createManyAndReturn
   */
  export type TaskLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskLogs.
     */
    data: TaskLogCreateManyInput | TaskLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskLog update
   */
  export type TaskLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskLog.
     */
    data: XOR<TaskLogUpdateInput, TaskLogUncheckedUpdateInput>
    /**
     * Choose, which TaskLog to update.
     */
    where: TaskLogWhereUniqueInput
  }

  /**
   * TaskLog updateMany
   */
  export type TaskLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskLogs.
     */
    data: XOR<TaskLogUpdateManyMutationInput, TaskLogUncheckedUpdateManyInput>
    /**
     * Filter which TaskLogs to update
     */
    where?: TaskLogWhereInput
  }

  /**
   * TaskLog upsert
   */
  export type TaskLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskLog to update in case it exists.
     */
    where: TaskLogWhereUniqueInput
    /**
     * In case the TaskLog found by the `where` argument doesn't exist, create a new TaskLog with this data.
     */
    create: XOR<TaskLogCreateInput, TaskLogUncheckedCreateInput>
    /**
     * In case the TaskLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskLogUpdateInput, TaskLogUncheckedUpdateInput>
  }

  /**
   * TaskLog delete
   */
  export type TaskLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
    /**
     * Filter which TaskLog to delete.
     */
    where: TaskLogWhereUniqueInput
  }

  /**
   * TaskLog deleteMany
   */
  export type TaskLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskLogs to delete
     */
    where?: TaskLogWhereInput
  }

  /**
   * TaskLog.operator
   */
  export type TaskLog$operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TaskLog without action
   */
  export type TaskLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskLog
     */
    select?: TaskLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    realName: 'realName',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ExpertProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    department: 'department',
    titles: 'titles',
    signatureUrl: 'signatureUrl'
  };

  export type ExpertProfileScalarFieldEnum = (typeof ExpertProfileScalarFieldEnum)[keyof typeof ExpertProfileScalarFieldEnum]


  export const ConsultationTaskScalarFieldEnum: {
    id: 'id',
    status: 'status',
    scheduledTime: 'scheduledTime',
    patientName: 'patientName',
    patientGender: 'patientGender',
    patientAge: 'patientAge',
    chiefComplaint: 'chiefComplaint',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConsultationTaskScalarFieldEnum = (typeof ConsultationTaskScalarFieldEnum)[keyof typeof ConsultationTaskScalarFieldEnum]


  export const TaskExpertScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    expertId: 'expertId',
    status: 'status',
    isCore: 'isCore',
    invitedAt: 'invitedAt',
    respondedAt: 'respondedAt'
  };

  export type TaskExpertScalarFieldEnum = (typeof TaskExpertScalarFieldEnum)[keyof typeof TaskExpertScalarFieldEnum]


  export const PreConsultationDocScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    presentIllness: 'presentIllness',
    pastHistory: 'pastHistory',
    familyHistory: 'familyHistory',
    extraInfo: 'extraInfo'
  };

  export type PreConsultationDocScalarFieldEnum = (typeof PreConsultationDocScalarFieldEnum)[keyof typeof PreConsultationDocScalarFieldEnum]


  export const ConsultationDialogScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    role: 'role',
    content: 'content',
    original: 'original',
    startTime: 'startTime',
    createdAt: 'createdAt'
  };

  export type ConsultationDialogScalarFieldEnum = (typeof ConsultationDialogScalarFieldEnum)[keyof typeof ConsultationDialogScalarFieldEnum]


  export const PostConsultationDocScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    aiContent: 'aiContent',
    finalContent: 'finalContent',
    isSubmitted: 'isSubmitted',
    version: 'version',
    updatedAt: 'updatedAt'
  };

  export type PostConsultationDocScalarFieldEnum = (typeof PostConsultationDocScalarFieldEnum)[keyof typeof PostConsultationDocScalarFieldEnum]


  export const ExpertOpinionScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    expertProfileId: 'expertProfileId',
    audioUrl: 'audioUrl',
    asrText: 'asrText',
    aiStructured: 'aiStructured',
    isAiAdopted: 'isAiAdopted',
    finalText: 'finalText',
    isSubmitted: 'isSubmitted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpertOpinionScalarFieldEnum = (typeof ExpertOpinionScalarFieldEnum)[keyof typeof ExpertOpinionScalarFieldEnum]


  export const ConsultationReportScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    aiSummary: 'aiSummary',
    finalSummary: 'finalSummary',
    aiEducation: 'aiEducation',
    finalEducation: 'finalEducation',
    pdfUrl: 'pdfUrl',
    isSigned: 'isSigned',
    completedAt: 'completedAt'
  };

  export type ConsultationReportScalarFieldEnum = (typeof ConsultationReportScalarFieldEnum)[keyof typeof ConsultationReportScalarFieldEnum]


  export const TaskLogScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    operatorId: 'operatorId',
    action: 'action',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type TaskLogScalarFieldEnum = (typeof TaskLogScalarFieldEnum)[keyof typeof TaskLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    realName?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    expertProfile?: XOR<ExpertProfileNullableRelationFilter, ExpertProfileWhereInput> | null
    expertTasks?: TaskExpertListRelationFilter
    logs?: TaskLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    realName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expertProfile?: ExpertProfileOrderByWithRelationInput
    expertTasks?: TaskExpertOrderByRelationAggregateInput
    logs?: TaskLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    realName?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    expertProfile?: XOR<ExpertProfileNullableRelationFilter, ExpertProfileWhereInput> | null
    expertTasks?: TaskExpertListRelationFilter
    logs?: TaskLogListRelationFilter
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    realName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    realName?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ExpertProfileWhereInput = {
    AND?: ExpertProfileWhereInput | ExpertProfileWhereInput[]
    OR?: ExpertProfileWhereInput[]
    NOT?: ExpertProfileWhereInput | ExpertProfileWhereInput[]
    id?: StringFilter<"ExpertProfile"> | string
    userId?: StringFilter<"ExpertProfile"> | string
    department?: StringFilter<"ExpertProfile"> | string
    titles?: StringFilter<"ExpertProfile"> | string
    signatureUrl?: StringNullableFilter<"ExpertProfile"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    opinions?: ExpertOpinionListRelationFilter
  }

  export type ExpertProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    titles?: SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    opinions?: ExpertOpinionOrderByRelationAggregateInput
  }

  export type ExpertProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ExpertProfileWhereInput | ExpertProfileWhereInput[]
    OR?: ExpertProfileWhereInput[]
    NOT?: ExpertProfileWhereInput | ExpertProfileWhereInput[]
    department?: StringFilter<"ExpertProfile"> | string
    titles?: StringFilter<"ExpertProfile"> | string
    signatureUrl?: StringNullableFilter<"ExpertProfile"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    opinions?: ExpertOpinionListRelationFilter
  }, "id" | "userId">

  export type ExpertProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    titles?: SortOrder
    signatureUrl?: SortOrderInput | SortOrder
    _count?: ExpertProfileCountOrderByAggregateInput
    _max?: ExpertProfileMaxOrderByAggregateInput
    _min?: ExpertProfileMinOrderByAggregateInput
  }

  export type ExpertProfileScalarWhereWithAggregatesInput = {
    AND?: ExpertProfileScalarWhereWithAggregatesInput | ExpertProfileScalarWhereWithAggregatesInput[]
    OR?: ExpertProfileScalarWhereWithAggregatesInput[]
    NOT?: ExpertProfileScalarWhereWithAggregatesInput | ExpertProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExpertProfile"> | string
    userId?: StringWithAggregatesFilter<"ExpertProfile"> | string
    department?: StringWithAggregatesFilter<"ExpertProfile"> | string
    titles?: StringWithAggregatesFilter<"ExpertProfile"> | string
    signatureUrl?: StringNullableWithAggregatesFilter<"ExpertProfile"> | string | null
  }

  export type ConsultationTaskWhereInput = {
    AND?: ConsultationTaskWhereInput | ConsultationTaskWhereInput[]
    OR?: ConsultationTaskWhereInput[]
    NOT?: ConsultationTaskWhereInput | ConsultationTaskWhereInput[]
    id?: StringFilter<"ConsultationTask"> | string
    status?: StringFilter<"ConsultationTask"> | string
    scheduledTime?: DateTimeFilter<"ConsultationTask"> | Date | string
    patientName?: StringFilter<"ConsultationTask"> | string
    patientGender?: StringFilter<"ConsultationTask"> | string
    patientAge?: IntFilter<"ConsultationTask"> | number
    chiefComplaint?: StringFilter<"ConsultationTask"> | string
    createdAt?: DateTimeFilter<"ConsultationTask"> | Date | string
    updatedAt?: DateTimeFilter<"ConsultationTask"> | Date | string
    preDoc?: XOR<PreConsultationDocNullableRelationFilter, PreConsultationDocWhereInput> | null
    dialogs?: ConsultationDialogListRelationFilter
    postDoc?: XOR<PostConsultationDocNullableRelationFilter, PostConsultationDocWhereInput> | null
    opinions?: ExpertOpinionListRelationFilter
    report?: XOR<ConsultationReportNullableRelationFilter, ConsultationReportWhereInput> | null
    experts?: TaskExpertListRelationFilter
    logs?: TaskLogListRelationFilter
  }

  export type ConsultationTaskOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    scheduledTime?: SortOrder
    patientName?: SortOrder
    patientGender?: SortOrder
    patientAge?: SortOrder
    chiefComplaint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preDoc?: PreConsultationDocOrderByWithRelationInput
    dialogs?: ConsultationDialogOrderByRelationAggregateInput
    postDoc?: PostConsultationDocOrderByWithRelationInput
    opinions?: ExpertOpinionOrderByRelationAggregateInput
    report?: ConsultationReportOrderByWithRelationInput
    experts?: TaskExpertOrderByRelationAggregateInput
    logs?: TaskLogOrderByRelationAggregateInput
  }

  export type ConsultationTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConsultationTaskWhereInput | ConsultationTaskWhereInput[]
    OR?: ConsultationTaskWhereInput[]
    NOT?: ConsultationTaskWhereInput | ConsultationTaskWhereInput[]
    status?: StringFilter<"ConsultationTask"> | string
    scheduledTime?: DateTimeFilter<"ConsultationTask"> | Date | string
    patientName?: StringFilter<"ConsultationTask"> | string
    patientGender?: StringFilter<"ConsultationTask"> | string
    patientAge?: IntFilter<"ConsultationTask"> | number
    chiefComplaint?: StringFilter<"ConsultationTask"> | string
    createdAt?: DateTimeFilter<"ConsultationTask"> | Date | string
    updatedAt?: DateTimeFilter<"ConsultationTask"> | Date | string
    preDoc?: XOR<PreConsultationDocNullableRelationFilter, PreConsultationDocWhereInput> | null
    dialogs?: ConsultationDialogListRelationFilter
    postDoc?: XOR<PostConsultationDocNullableRelationFilter, PostConsultationDocWhereInput> | null
    opinions?: ExpertOpinionListRelationFilter
    report?: XOR<ConsultationReportNullableRelationFilter, ConsultationReportWhereInput> | null
    experts?: TaskExpertListRelationFilter
    logs?: TaskLogListRelationFilter
  }, "id">

  export type ConsultationTaskOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    scheduledTime?: SortOrder
    patientName?: SortOrder
    patientGender?: SortOrder
    patientAge?: SortOrder
    chiefComplaint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConsultationTaskCountOrderByAggregateInput
    _avg?: ConsultationTaskAvgOrderByAggregateInput
    _max?: ConsultationTaskMaxOrderByAggregateInput
    _min?: ConsultationTaskMinOrderByAggregateInput
    _sum?: ConsultationTaskSumOrderByAggregateInput
  }

  export type ConsultationTaskScalarWhereWithAggregatesInput = {
    AND?: ConsultationTaskScalarWhereWithAggregatesInput | ConsultationTaskScalarWhereWithAggregatesInput[]
    OR?: ConsultationTaskScalarWhereWithAggregatesInput[]
    NOT?: ConsultationTaskScalarWhereWithAggregatesInput | ConsultationTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConsultationTask"> | string
    status?: StringWithAggregatesFilter<"ConsultationTask"> | string
    scheduledTime?: DateTimeWithAggregatesFilter<"ConsultationTask"> | Date | string
    patientName?: StringWithAggregatesFilter<"ConsultationTask"> | string
    patientGender?: StringWithAggregatesFilter<"ConsultationTask"> | string
    patientAge?: IntWithAggregatesFilter<"ConsultationTask"> | number
    chiefComplaint?: StringWithAggregatesFilter<"ConsultationTask"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConsultationTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConsultationTask"> | Date | string
  }

  export type TaskExpertWhereInput = {
    AND?: TaskExpertWhereInput | TaskExpertWhereInput[]
    OR?: TaskExpertWhereInput[]
    NOT?: TaskExpertWhereInput | TaskExpertWhereInput[]
    id?: StringFilter<"TaskExpert"> | string
    taskId?: StringFilter<"TaskExpert"> | string
    expertId?: StringFilter<"TaskExpert"> | string
    status?: StringFilter<"TaskExpert"> | string
    isCore?: BoolFilter<"TaskExpert"> | boolean
    invitedAt?: DateTimeFilter<"TaskExpert"> | Date | string
    respondedAt?: DateTimeNullableFilter<"TaskExpert"> | Date | string | null
    task?: XOR<ConsultationTaskRelationFilter, ConsultationTaskWhereInput>
    expert?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TaskExpertOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    expertId?: SortOrder
    status?: SortOrder
    isCore?: SortOrder
    invitedAt?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    task?: ConsultationTaskOrderByWithRelationInput
    expert?: UserOrderByWithRelationInput
  }

  export type TaskExpertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    taskId_expertId?: TaskExpertTaskIdExpertIdCompoundUniqueInput
    AND?: TaskExpertWhereInput | TaskExpertWhereInput[]
    OR?: TaskExpertWhereInput[]
    NOT?: TaskExpertWhereInput | TaskExpertWhereInput[]
    taskId?: StringFilter<"TaskExpert"> | string
    expertId?: StringFilter<"TaskExpert"> | string
    status?: StringFilter<"TaskExpert"> | string
    isCore?: BoolFilter<"TaskExpert"> | boolean
    invitedAt?: DateTimeFilter<"TaskExpert"> | Date | string
    respondedAt?: DateTimeNullableFilter<"TaskExpert"> | Date | string | null
    task?: XOR<ConsultationTaskRelationFilter, ConsultationTaskWhereInput>
    expert?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "taskId_expertId">

  export type TaskExpertOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    expertId?: SortOrder
    status?: SortOrder
    isCore?: SortOrder
    invitedAt?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    _count?: TaskExpertCountOrderByAggregateInput
    _max?: TaskExpertMaxOrderByAggregateInput
    _min?: TaskExpertMinOrderByAggregateInput
  }

  export type TaskExpertScalarWhereWithAggregatesInput = {
    AND?: TaskExpertScalarWhereWithAggregatesInput | TaskExpertScalarWhereWithAggregatesInput[]
    OR?: TaskExpertScalarWhereWithAggregatesInput[]
    NOT?: TaskExpertScalarWhereWithAggregatesInput | TaskExpertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskExpert"> | string
    taskId?: StringWithAggregatesFilter<"TaskExpert"> | string
    expertId?: StringWithAggregatesFilter<"TaskExpert"> | string
    status?: StringWithAggregatesFilter<"TaskExpert"> | string
    isCore?: BoolWithAggregatesFilter<"TaskExpert"> | boolean
    invitedAt?: DateTimeWithAggregatesFilter<"TaskExpert"> | Date | string
    respondedAt?: DateTimeNullableWithAggregatesFilter<"TaskExpert"> | Date | string | null
  }

  export type PreConsultationDocWhereInput = {
    AND?: PreConsultationDocWhereInput | PreConsultationDocWhereInput[]
    OR?: PreConsultationDocWhereInput[]
    NOT?: PreConsultationDocWhereInput | PreConsultationDocWhereInput[]
    id?: StringFilter<"PreConsultationDoc"> | string
    taskId?: StringFilter<"PreConsultationDoc"> | string
    presentIllness?: StringFilter<"PreConsultationDoc"> | string
    pastHistory?: StringNullableFilter<"PreConsultationDoc"> | string | null
    familyHistory?: StringNullableFilter<"PreConsultationDoc"> | string | null
    extraInfo?: StringNullableFilter<"PreConsultationDoc"> | string | null
    task?: XOR<ConsultationTaskRelationFilter, ConsultationTaskWhereInput>
  }

  export type PreConsultationDocOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    presentIllness?: SortOrder
    pastHistory?: SortOrderInput | SortOrder
    familyHistory?: SortOrderInput | SortOrder
    extraInfo?: SortOrderInput | SortOrder
    task?: ConsultationTaskOrderByWithRelationInput
  }

  export type PreConsultationDocWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    taskId?: string
    AND?: PreConsultationDocWhereInput | PreConsultationDocWhereInput[]
    OR?: PreConsultationDocWhereInput[]
    NOT?: PreConsultationDocWhereInput | PreConsultationDocWhereInput[]
    presentIllness?: StringFilter<"PreConsultationDoc"> | string
    pastHistory?: StringNullableFilter<"PreConsultationDoc"> | string | null
    familyHistory?: StringNullableFilter<"PreConsultationDoc"> | string | null
    extraInfo?: StringNullableFilter<"PreConsultationDoc"> | string | null
    task?: XOR<ConsultationTaskRelationFilter, ConsultationTaskWhereInput>
  }, "id" | "taskId">

  export type PreConsultationDocOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    presentIllness?: SortOrder
    pastHistory?: SortOrderInput | SortOrder
    familyHistory?: SortOrderInput | SortOrder
    extraInfo?: SortOrderInput | SortOrder
    _count?: PreConsultationDocCountOrderByAggregateInput
    _max?: PreConsultationDocMaxOrderByAggregateInput
    _min?: PreConsultationDocMinOrderByAggregateInput
  }

  export type PreConsultationDocScalarWhereWithAggregatesInput = {
    AND?: PreConsultationDocScalarWhereWithAggregatesInput | PreConsultationDocScalarWhereWithAggregatesInput[]
    OR?: PreConsultationDocScalarWhereWithAggregatesInput[]
    NOT?: PreConsultationDocScalarWhereWithAggregatesInput | PreConsultationDocScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PreConsultationDoc"> | string
    taskId?: StringWithAggregatesFilter<"PreConsultationDoc"> | string
    presentIllness?: StringWithAggregatesFilter<"PreConsultationDoc"> | string
    pastHistory?: StringNullableWithAggregatesFilter<"PreConsultationDoc"> | string | null
    familyHistory?: StringNullableWithAggregatesFilter<"PreConsultationDoc"> | string | null
    extraInfo?: StringNullableWithAggregatesFilter<"PreConsultationDoc"> | string | null
  }

  export type ConsultationDialogWhereInput = {
    AND?: ConsultationDialogWhereInput | ConsultationDialogWhereInput[]
    OR?: ConsultationDialogWhereInput[]
    NOT?: ConsultationDialogWhereInput | ConsultationDialogWhereInput[]
    id?: StringFilter<"ConsultationDialog"> | string
    taskId?: StringFilter<"ConsultationDialog"> | string
    role?: StringFilter<"ConsultationDialog"> | string
    content?: StringFilter<"ConsultationDialog"> | string
    original?: StringNullableFilter<"ConsultationDialog"> | string | null
    startTime?: FloatNullableFilter<"ConsultationDialog"> | number | null
    createdAt?: DateTimeFilter<"ConsultationDialog"> | Date | string
    task?: XOR<ConsultationTaskRelationFilter, ConsultationTaskWhereInput>
  }

  export type ConsultationDialogOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    original?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    task?: ConsultationTaskOrderByWithRelationInput
  }

  export type ConsultationDialogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConsultationDialogWhereInput | ConsultationDialogWhereInput[]
    OR?: ConsultationDialogWhereInput[]
    NOT?: ConsultationDialogWhereInput | ConsultationDialogWhereInput[]
    taskId?: StringFilter<"ConsultationDialog"> | string
    role?: StringFilter<"ConsultationDialog"> | string
    content?: StringFilter<"ConsultationDialog"> | string
    original?: StringNullableFilter<"ConsultationDialog"> | string | null
    startTime?: FloatNullableFilter<"ConsultationDialog"> | number | null
    createdAt?: DateTimeFilter<"ConsultationDialog"> | Date | string
    task?: XOR<ConsultationTaskRelationFilter, ConsultationTaskWhereInput>
  }, "id">

  export type ConsultationDialogOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    original?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ConsultationDialogCountOrderByAggregateInput
    _avg?: ConsultationDialogAvgOrderByAggregateInput
    _max?: ConsultationDialogMaxOrderByAggregateInput
    _min?: ConsultationDialogMinOrderByAggregateInput
    _sum?: ConsultationDialogSumOrderByAggregateInput
  }

  export type ConsultationDialogScalarWhereWithAggregatesInput = {
    AND?: ConsultationDialogScalarWhereWithAggregatesInput | ConsultationDialogScalarWhereWithAggregatesInput[]
    OR?: ConsultationDialogScalarWhereWithAggregatesInput[]
    NOT?: ConsultationDialogScalarWhereWithAggregatesInput | ConsultationDialogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConsultationDialog"> | string
    taskId?: StringWithAggregatesFilter<"ConsultationDialog"> | string
    role?: StringWithAggregatesFilter<"ConsultationDialog"> | string
    content?: StringWithAggregatesFilter<"ConsultationDialog"> | string
    original?: StringNullableWithAggregatesFilter<"ConsultationDialog"> | string | null
    startTime?: FloatNullableWithAggregatesFilter<"ConsultationDialog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ConsultationDialog"> | Date | string
  }

  export type PostConsultationDocWhereInput = {
    AND?: PostConsultationDocWhereInput | PostConsultationDocWhereInput[]
    OR?: PostConsultationDocWhereInput[]
    NOT?: PostConsultationDocWhereInput | PostConsultationDocWhereInput[]
    id?: StringFilter<"PostConsultationDoc"> | string
    taskId?: StringFilter<"PostConsultationDoc"> | string
    aiContent?: StringNullableFilter<"PostConsultationDoc"> | string | null
    finalContent?: StringNullableFilter<"PostConsultationDoc"> | string | null
    isSubmitted?: BoolFilter<"PostConsultationDoc"> | boolean
    version?: IntFilter<"PostConsultationDoc"> | number
    updatedAt?: DateTimeFilter<"PostConsultationDoc"> | Date | string
    task?: XOR<ConsultationTaskRelationFilter, ConsultationTaskWhereInput>
  }

  export type PostConsultationDocOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    aiContent?: SortOrderInput | SortOrder
    finalContent?: SortOrderInput | SortOrder
    isSubmitted?: SortOrder
    version?: SortOrder
    updatedAt?: SortOrder
    task?: ConsultationTaskOrderByWithRelationInput
  }

  export type PostConsultationDocWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    taskId?: string
    AND?: PostConsultationDocWhereInput | PostConsultationDocWhereInput[]
    OR?: PostConsultationDocWhereInput[]
    NOT?: PostConsultationDocWhereInput | PostConsultationDocWhereInput[]
    aiContent?: StringNullableFilter<"PostConsultationDoc"> | string | null
    finalContent?: StringNullableFilter<"PostConsultationDoc"> | string | null
    isSubmitted?: BoolFilter<"PostConsultationDoc"> | boolean
    version?: IntFilter<"PostConsultationDoc"> | number
    updatedAt?: DateTimeFilter<"PostConsultationDoc"> | Date | string
    task?: XOR<ConsultationTaskRelationFilter, ConsultationTaskWhereInput>
  }, "id" | "taskId">

  export type PostConsultationDocOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    aiContent?: SortOrderInput | SortOrder
    finalContent?: SortOrderInput | SortOrder
    isSubmitted?: SortOrder
    version?: SortOrder
    updatedAt?: SortOrder
    _count?: PostConsultationDocCountOrderByAggregateInput
    _avg?: PostConsultationDocAvgOrderByAggregateInput
    _max?: PostConsultationDocMaxOrderByAggregateInput
    _min?: PostConsultationDocMinOrderByAggregateInput
    _sum?: PostConsultationDocSumOrderByAggregateInput
  }

  export type PostConsultationDocScalarWhereWithAggregatesInput = {
    AND?: PostConsultationDocScalarWhereWithAggregatesInput | PostConsultationDocScalarWhereWithAggregatesInput[]
    OR?: PostConsultationDocScalarWhereWithAggregatesInput[]
    NOT?: PostConsultationDocScalarWhereWithAggregatesInput | PostConsultationDocScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostConsultationDoc"> | string
    taskId?: StringWithAggregatesFilter<"PostConsultationDoc"> | string
    aiContent?: StringNullableWithAggregatesFilter<"PostConsultationDoc"> | string | null
    finalContent?: StringNullableWithAggregatesFilter<"PostConsultationDoc"> | string | null
    isSubmitted?: BoolWithAggregatesFilter<"PostConsultationDoc"> | boolean
    version?: IntWithAggregatesFilter<"PostConsultationDoc"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"PostConsultationDoc"> | Date | string
  }

  export type ExpertOpinionWhereInput = {
    AND?: ExpertOpinionWhereInput | ExpertOpinionWhereInput[]
    OR?: ExpertOpinionWhereInput[]
    NOT?: ExpertOpinionWhereInput | ExpertOpinionWhereInput[]
    id?: StringFilter<"ExpertOpinion"> | string
    taskId?: StringFilter<"ExpertOpinion"> | string
    expertProfileId?: StringFilter<"ExpertOpinion"> | string
    audioUrl?: StringNullableFilter<"ExpertOpinion"> | string | null
    asrText?: StringNullableFilter<"ExpertOpinion"> | string | null
    aiStructured?: StringNullableFilter<"ExpertOpinion"> | string | null
    isAiAdopted?: BoolFilter<"ExpertOpinion"> | boolean
    finalText?: StringNullableFilter<"ExpertOpinion"> | string | null
    isSubmitted?: BoolFilter<"ExpertOpinion"> | boolean
    createdAt?: DateTimeFilter<"ExpertOpinion"> | Date | string
    updatedAt?: DateTimeFilter<"ExpertOpinion"> | Date | string
    task?: XOR<ConsultationTaskRelationFilter, ConsultationTaskWhereInput>
    expert?: XOR<ExpertProfileRelationFilter, ExpertProfileWhereInput>
  }

  export type ExpertOpinionOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    expertProfileId?: SortOrder
    audioUrl?: SortOrderInput | SortOrder
    asrText?: SortOrderInput | SortOrder
    aiStructured?: SortOrderInput | SortOrder
    isAiAdopted?: SortOrder
    finalText?: SortOrderInput | SortOrder
    isSubmitted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    task?: ConsultationTaskOrderByWithRelationInput
    expert?: ExpertProfileOrderByWithRelationInput
  }

  export type ExpertOpinionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpertOpinionWhereInput | ExpertOpinionWhereInput[]
    OR?: ExpertOpinionWhereInput[]
    NOT?: ExpertOpinionWhereInput | ExpertOpinionWhereInput[]
    taskId?: StringFilter<"ExpertOpinion"> | string
    expertProfileId?: StringFilter<"ExpertOpinion"> | string
    audioUrl?: StringNullableFilter<"ExpertOpinion"> | string | null
    asrText?: StringNullableFilter<"ExpertOpinion"> | string | null
    aiStructured?: StringNullableFilter<"ExpertOpinion"> | string | null
    isAiAdopted?: BoolFilter<"ExpertOpinion"> | boolean
    finalText?: StringNullableFilter<"ExpertOpinion"> | string | null
    isSubmitted?: BoolFilter<"ExpertOpinion"> | boolean
    createdAt?: DateTimeFilter<"ExpertOpinion"> | Date | string
    updatedAt?: DateTimeFilter<"ExpertOpinion"> | Date | string
    task?: XOR<ConsultationTaskRelationFilter, ConsultationTaskWhereInput>
    expert?: XOR<ExpertProfileRelationFilter, ExpertProfileWhereInput>
  }, "id">

  export type ExpertOpinionOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    expertProfileId?: SortOrder
    audioUrl?: SortOrderInput | SortOrder
    asrText?: SortOrderInput | SortOrder
    aiStructured?: SortOrderInput | SortOrder
    isAiAdopted?: SortOrder
    finalText?: SortOrderInput | SortOrder
    isSubmitted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpertOpinionCountOrderByAggregateInput
    _max?: ExpertOpinionMaxOrderByAggregateInput
    _min?: ExpertOpinionMinOrderByAggregateInput
  }

  export type ExpertOpinionScalarWhereWithAggregatesInput = {
    AND?: ExpertOpinionScalarWhereWithAggregatesInput | ExpertOpinionScalarWhereWithAggregatesInput[]
    OR?: ExpertOpinionScalarWhereWithAggregatesInput[]
    NOT?: ExpertOpinionScalarWhereWithAggregatesInput | ExpertOpinionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExpertOpinion"> | string
    taskId?: StringWithAggregatesFilter<"ExpertOpinion"> | string
    expertProfileId?: StringWithAggregatesFilter<"ExpertOpinion"> | string
    audioUrl?: StringNullableWithAggregatesFilter<"ExpertOpinion"> | string | null
    asrText?: StringNullableWithAggregatesFilter<"ExpertOpinion"> | string | null
    aiStructured?: StringNullableWithAggregatesFilter<"ExpertOpinion"> | string | null
    isAiAdopted?: BoolWithAggregatesFilter<"ExpertOpinion"> | boolean
    finalText?: StringNullableWithAggregatesFilter<"ExpertOpinion"> | string | null
    isSubmitted?: BoolWithAggregatesFilter<"ExpertOpinion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ExpertOpinion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExpertOpinion"> | Date | string
  }

  export type ConsultationReportWhereInput = {
    AND?: ConsultationReportWhereInput | ConsultationReportWhereInput[]
    OR?: ConsultationReportWhereInput[]
    NOT?: ConsultationReportWhereInput | ConsultationReportWhereInput[]
    id?: StringFilter<"ConsultationReport"> | string
    taskId?: StringFilter<"ConsultationReport"> | string
    aiSummary?: StringNullableFilter<"ConsultationReport"> | string | null
    finalSummary?: StringFilter<"ConsultationReport"> | string
    aiEducation?: StringNullableFilter<"ConsultationReport"> | string | null
    finalEducation?: StringFilter<"ConsultationReport"> | string
    pdfUrl?: StringNullableFilter<"ConsultationReport"> | string | null
    isSigned?: BoolFilter<"ConsultationReport"> | boolean
    completedAt?: DateTimeFilter<"ConsultationReport"> | Date | string
    task?: XOR<ConsultationTaskRelationFilter, ConsultationTaskWhereInput>
  }

  export type ConsultationReportOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    aiSummary?: SortOrderInput | SortOrder
    finalSummary?: SortOrder
    aiEducation?: SortOrderInput | SortOrder
    finalEducation?: SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    isSigned?: SortOrder
    completedAt?: SortOrder
    task?: ConsultationTaskOrderByWithRelationInput
  }

  export type ConsultationReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    taskId?: string
    AND?: ConsultationReportWhereInput | ConsultationReportWhereInput[]
    OR?: ConsultationReportWhereInput[]
    NOT?: ConsultationReportWhereInput | ConsultationReportWhereInput[]
    aiSummary?: StringNullableFilter<"ConsultationReport"> | string | null
    finalSummary?: StringFilter<"ConsultationReport"> | string
    aiEducation?: StringNullableFilter<"ConsultationReport"> | string | null
    finalEducation?: StringFilter<"ConsultationReport"> | string
    pdfUrl?: StringNullableFilter<"ConsultationReport"> | string | null
    isSigned?: BoolFilter<"ConsultationReport"> | boolean
    completedAt?: DateTimeFilter<"ConsultationReport"> | Date | string
    task?: XOR<ConsultationTaskRelationFilter, ConsultationTaskWhereInput>
  }, "id" | "taskId">

  export type ConsultationReportOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    aiSummary?: SortOrderInput | SortOrder
    finalSummary?: SortOrder
    aiEducation?: SortOrderInput | SortOrder
    finalEducation?: SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    isSigned?: SortOrder
    completedAt?: SortOrder
    _count?: ConsultationReportCountOrderByAggregateInput
    _max?: ConsultationReportMaxOrderByAggregateInput
    _min?: ConsultationReportMinOrderByAggregateInput
  }

  export type ConsultationReportScalarWhereWithAggregatesInput = {
    AND?: ConsultationReportScalarWhereWithAggregatesInput | ConsultationReportScalarWhereWithAggregatesInput[]
    OR?: ConsultationReportScalarWhereWithAggregatesInput[]
    NOT?: ConsultationReportScalarWhereWithAggregatesInput | ConsultationReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConsultationReport"> | string
    taskId?: StringWithAggregatesFilter<"ConsultationReport"> | string
    aiSummary?: StringNullableWithAggregatesFilter<"ConsultationReport"> | string | null
    finalSummary?: StringWithAggregatesFilter<"ConsultationReport"> | string
    aiEducation?: StringNullableWithAggregatesFilter<"ConsultationReport"> | string | null
    finalEducation?: StringWithAggregatesFilter<"ConsultationReport"> | string
    pdfUrl?: StringNullableWithAggregatesFilter<"ConsultationReport"> | string | null
    isSigned?: BoolWithAggregatesFilter<"ConsultationReport"> | boolean
    completedAt?: DateTimeWithAggregatesFilter<"ConsultationReport"> | Date | string
  }

  export type TaskLogWhereInput = {
    AND?: TaskLogWhereInput | TaskLogWhereInput[]
    OR?: TaskLogWhereInput[]
    NOT?: TaskLogWhereInput | TaskLogWhereInput[]
    id?: StringFilter<"TaskLog"> | string
    taskId?: StringFilter<"TaskLog"> | string
    operatorId?: StringNullableFilter<"TaskLog"> | string | null
    action?: StringFilter<"TaskLog"> | string
    details?: StringNullableFilter<"TaskLog"> | string | null
    createdAt?: DateTimeFilter<"TaskLog"> | Date | string
    task?: XOR<ConsultationTaskRelationFilter, ConsultationTaskWhereInput>
    operator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type TaskLogOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    operatorId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    task?: ConsultationTaskOrderByWithRelationInput
    operator?: UserOrderByWithRelationInput
  }

  export type TaskLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskLogWhereInput | TaskLogWhereInput[]
    OR?: TaskLogWhereInput[]
    NOT?: TaskLogWhereInput | TaskLogWhereInput[]
    taskId?: StringFilter<"TaskLog"> | string
    operatorId?: StringNullableFilter<"TaskLog"> | string | null
    action?: StringFilter<"TaskLog"> | string
    details?: StringNullableFilter<"TaskLog"> | string | null
    createdAt?: DateTimeFilter<"TaskLog"> | Date | string
    task?: XOR<ConsultationTaskRelationFilter, ConsultationTaskWhereInput>
    operator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type TaskLogOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    operatorId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TaskLogCountOrderByAggregateInput
    _max?: TaskLogMaxOrderByAggregateInput
    _min?: TaskLogMinOrderByAggregateInput
  }

  export type TaskLogScalarWhereWithAggregatesInput = {
    AND?: TaskLogScalarWhereWithAggregatesInput | TaskLogScalarWhereWithAggregatesInput[]
    OR?: TaskLogScalarWhereWithAggregatesInput[]
    NOT?: TaskLogScalarWhereWithAggregatesInput | TaskLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskLog"> | string
    taskId?: StringWithAggregatesFilter<"TaskLog"> | string
    operatorId?: StringNullableWithAggregatesFilter<"TaskLog"> | string | null
    action?: StringWithAggregatesFilter<"TaskLog"> | string
    details?: StringNullableWithAggregatesFilter<"TaskLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TaskLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    password: string
    realName: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expertProfile?: ExpertProfileCreateNestedOneWithoutUserInput
    expertTasks?: TaskExpertCreateNestedManyWithoutExpertInput
    logs?: TaskLogCreateNestedManyWithoutOperatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    password: string
    realName: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expertProfile?: ExpertProfileUncheckedCreateNestedOneWithoutUserInput
    expertTasks?: TaskExpertUncheckedCreateNestedManyWithoutExpertInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    realName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expertProfile?: ExpertProfileUpdateOneWithoutUserNestedInput
    expertTasks?: TaskExpertUpdateManyWithoutExpertNestedInput
    logs?: TaskLogUpdateManyWithoutOperatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    realName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expertProfile?: ExpertProfileUncheckedUpdateOneWithoutUserNestedInput
    expertTasks?: TaskExpertUncheckedUpdateManyWithoutExpertNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    password: string
    realName: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    realName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    realName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpertProfileCreateInput = {
    id?: string
    department: string
    titles: string
    signatureUrl?: string | null
    user: UserCreateNestedOneWithoutExpertProfileInput
    opinions?: ExpertOpinionCreateNestedManyWithoutExpertInput
  }

  export type ExpertProfileUncheckedCreateInput = {
    id?: string
    userId: string
    department: string
    titles: string
    signatureUrl?: string | null
    opinions?: ExpertOpinionUncheckedCreateNestedManyWithoutExpertInput
  }

  export type ExpertProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    titles?: StringFieldUpdateOperationsInput | string
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutExpertProfileNestedInput
    opinions?: ExpertOpinionUpdateManyWithoutExpertNestedInput
  }

  export type ExpertProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    titles?: StringFieldUpdateOperationsInput | string
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    opinions?: ExpertOpinionUncheckedUpdateManyWithoutExpertNestedInput
  }

  export type ExpertProfileCreateManyInput = {
    id?: string
    userId: string
    department: string
    titles: string
    signatureUrl?: string | null
  }

  export type ExpertProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    titles?: StringFieldUpdateOperationsInput | string
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpertProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    titles?: StringFieldUpdateOperationsInput | string
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConsultationTaskCreateInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preDoc?: PreConsultationDocCreateNestedOneWithoutTaskInput
    dialogs?: ConsultationDialogCreateNestedManyWithoutTaskInput
    postDoc?: PostConsultationDocCreateNestedOneWithoutTaskInput
    opinions?: ExpertOpinionCreateNestedManyWithoutTaskInput
    report?: ConsultationReportCreateNestedOneWithoutTaskInput
    experts?: TaskExpertCreateNestedManyWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
  }

  export type ConsultationTaskUncheckedCreateInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preDoc?: PreConsultationDocUncheckedCreateNestedOneWithoutTaskInput
    dialogs?: ConsultationDialogUncheckedCreateNestedManyWithoutTaskInput
    postDoc?: PostConsultationDocUncheckedCreateNestedOneWithoutTaskInput
    opinions?: ExpertOpinionUncheckedCreateNestedManyWithoutTaskInput
    report?: ConsultationReportUncheckedCreateNestedOneWithoutTaskInput
    experts?: TaskExpertUncheckedCreateNestedManyWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type ConsultationTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preDoc?: PreConsultationDocUpdateOneWithoutTaskNestedInput
    dialogs?: ConsultationDialogUpdateManyWithoutTaskNestedInput
    postDoc?: PostConsultationDocUpdateOneWithoutTaskNestedInput
    opinions?: ExpertOpinionUpdateManyWithoutTaskNestedInput
    report?: ConsultationReportUpdateOneWithoutTaskNestedInput
    experts?: TaskExpertUpdateManyWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
  }

  export type ConsultationTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preDoc?: PreConsultationDocUncheckedUpdateOneWithoutTaskNestedInput
    dialogs?: ConsultationDialogUncheckedUpdateManyWithoutTaskNestedInput
    postDoc?: PostConsultationDocUncheckedUpdateOneWithoutTaskNestedInput
    opinions?: ExpertOpinionUncheckedUpdateManyWithoutTaskNestedInput
    report?: ConsultationReportUncheckedUpdateOneWithoutTaskNestedInput
    experts?: TaskExpertUncheckedUpdateManyWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type ConsultationTaskCreateManyInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsultationTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskExpertCreateInput = {
    id?: string
    status?: string
    isCore?: boolean
    invitedAt?: Date | string
    respondedAt?: Date | string | null
    task: ConsultationTaskCreateNestedOneWithoutExpertsInput
    expert: UserCreateNestedOneWithoutExpertTasksInput
  }

  export type TaskExpertUncheckedCreateInput = {
    id?: string
    taskId: string
    expertId: string
    status?: string
    isCore?: boolean
    invitedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type TaskExpertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task?: ConsultationTaskUpdateOneRequiredWithoutExpertsNestedInput
    expert?: UserUpdateOneRequiredWithoutExpertTasksNestedInput
  }

  export type TaskExpertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    expertId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskExpertCreateManyInput = {
    id?: string
    taskId: string
    expertId: string
    status?: string
    isCore?: boolean
    invitedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type TaskExpertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskExpertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    expertId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PreConsultationDocCreateInput = {
    id?: string
    presentIllness: string
    pastHistory?: string | null
    familyHistory?: string | null
    extraInfo?: string | null
    task: ConsultationTaskCreateNestedOneWithoutPreDocInput
  }

  export type PreConsultationDocUncheckedCreateInput = {
    id?: string
    taskId: string
    presentIllness: string
    pastHistory?: string | null
    familyHistory?: string | null
    extraInfo?: string | null
  }

  export type PreConsultationDocUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    presentIllness?: StringFieldUpdateOperationsInput | string
    pastHistory?: NullableStringFieldUpdateOperationsInput | string | null
    familyHistory?: NullableStringFieldUpdateOperationsInput | string | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    task?: ConsultationTaskUpdateOneRequiredWithoutPreDocNestedInput
  }

  export type PreConsultationDocUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    presentIllness?: StringFieldUpdateOperationsInput | string
    pastHistory?: NullableStringFieldUpdateOperationsInput | string | null
    familyHistory?: NullableStringFieldUpdateOperationsInput | string | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PreConsultationDocCreateManyInput = {
    id?: string
    taskId: string
    presentIllness: string
    pastHistory?: string | null
    familyHistory?: string | null
    extraInfo?: string | null
  }

  export type PreConsultationDocUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    presentIllness?: StringFieldUpdateOperationsInput | string
    pastHistory?: NullableStringFieldUpdateOperationsInput | string | null
    familyHistory?: NullableStringFieldUpdateOperationsInput | string | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PreConsultationDocUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    presentIllness?: StringFieldUpdateOperationsInput | string
    pastHistory?: NullableStringFieldUpdateOperationsInput | string | null
    familyHistory?: NullableStringFieldUpdateOperationsInput | string | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConsultationDialogCreateInput = {
    id?: string
    role: string
    content: string
    original?: string | null
    startTime?: number | null
    createdAt?: Date | string
    task: ConsultationTaskCreateNestedOneWithoutDialogsInput
  }

  export type ConsultationDialogUncheckedCreateInput = {
    id?: string
    taskId: string
    role: string
    content: string
    original?: string | null
    startTime?: number | null
    createdAt?: Date | string
  }

  export type ConsultationDialogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    original?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: ConsultationTaskUpdateOneRequiredWithoutDialogsNestedInput
  }

  export type ConsultationDialogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    original?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationDialogCreateManyInput = {
    id?: string
    taskId: string
    role: string
    content: string
    original?: string | null
    startTime?: number | null
    createdAt?: Date | string
  }

  export type ConsultationDialogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    original?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationDialogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    original?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostConsultationDocCreateInput = {
    id?: string
    aiContent?: string | null
    finalContent?: string | null
    isSubmitted?: boolean
    version?: number
    updatedAt?: Date | string
    task: ConsultationTaskCreateNestedOneWithoutPostDocInput
  }

  export type PostConsultationDocUncheckedCreateInput = {
    id?: string
    taskId: string
    aiContent?: string | null
    finalContent?: string | null
    isSubmitted?: boolean
    version?: number
    updatedAt?: Date | string
  }

  export type PostConsultationDocUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiContent?: NullableStringFieldUpdateOperationsInput | string | null
    finalContent?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: ConsultationTaskUpdateOneRequiredWithoutPostDocNestedInput
  }

  export type PostConsultationDocUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    aiContent?: NullableStringFieldUpdateOperationsInput | string | null
    finalContent?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostConsultationDocCreateManyInput = {
    id?: string
    taskId: string
    aiContent?: string | null
    finalContent?: string | null
    isSubmitted?: boolean
    version?: number
    updatedAt?: Date | string
  }

  export type PostConsultationDocUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiContent?: NullableStringFieldUpdateOperationsInput | string | null
    finalContent?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostConsultationDocUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    aiContent?: NullableStringFieldUpdateOperationsInput | string | null
    finalContent?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpertOpinionCreateInput = {
    id?: string
    audioUrl?: string | null
    asrText?: string | null
    aiStructured?: string | null
    isAiAdopted?: boolean
    finalText?: string | null
    isSubmitted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    task: ConsultationTaskCreateNestedOneWithoutOpinionsInput
    expert: ExpertProfileCreateNestedOneWithoutOpinionsInput
  }

  export type ExpertOpinionUncheckedCreateInput = {
    id?: string
    taskId: string
    expertProfileId: string
    audioUrl?: string | null
    asrText?: string | null
    aiStructured?: string | null
    isAiAdopted?: boolean
    finalText?: string | null
    isSubmitted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpertOpinionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    aiStructured?: NullableStringFieldUpdateOperationsInput | string | null
    isAiAdopted?: BoolFieldUpdateOperationsInput | boolean
    finalText?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: ConsultationTaskUpdateOneRequiredWithoutOpinionsNestedInput
    expert?: ExpertProfileUpdateOneRequiredWithoutOpinionsNestedInput
  }

  export type ExpertOpinionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    expertProfileId?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    aiStructured?: NullableStringFieldUpdateOperationsInput | string | null
    isAiAdopted?: BoolFieldUpdateOperationsInput | boolean
    finalText?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpertOpinionCreateManyInput = {
    id?: string
    taskId: string
    expertProfileId: string
    audioUrl?: string | null
    asrText?: string | null
    aiStructured?: string | null
    isAiAdopted?: boolean
    finalText?: string | null
    isSubmitted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpertOpinionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    aiStructured?: NullableStringFieldUpdateOperationsInput | string | null
    isAiAdopted?: BoolFieldUpdateOperationsInput | boolean
    finalText?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpertOpinionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    expertProfileId?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    aiStructured?: NullableStringFieldUpdateOperationsInput | string | null
    isAiAdopted?: BoolFieldUpdateOperationsInput | boolean
    finalText?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationReportCreateInput = {
    id?: string
    aiSummary?: string | null
    finalSummary: string
    aiEducation?: string | null
    finalEducation: string
    pdfUrl?: string | null
    isSigned?: boolean
    completedAt?: Date | string
    task: ConsultationTaskCreateNestedOneWithoutReportInput
  }

  export type ConsultationReportUncheckedCreateInput = {
    id?: string
    taskId: string
    aiSummary?: string | null
    finalSummary: string
    aiEducation?: string | null
    finalEducation: string
    pdfUrl?: string | null
    isSigned?: boolean
    completedAt?: Date | string
  }

  export type ConsultationReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    finalSummary?: StringFieldUpdateOperationsInput | string
    aiEducation?: NullableStringFieldUpdateOperationsInput | string | null
    finalEducation?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: ConsultationTaskUpdateOneRequiredWithoutReportNestedInput
  }

  export type ConsultationReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    finalSummary?: StringFieldUpdateOperationsInput | string
    aiEducation?: NullableStringFieldUpdateOperationsInput | string | null
    finalEducation?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationReportCreateManyInput = {
    id?: string
    taskId: string
    aiSummary?: string | null
    finalSummary: string
    aiEducation?: string | null
    finalEducation: string
    pdfUrl?: string | null
    isSigned?: boolean
    completedAt?: Date | string
  }

  export type ConsultationReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    finalSummary?: StringFieldUpdateOperationsInput | string
    aiEducation?: NullableStringFieldUpdateOperationsInput | string | null
    finalEducation?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    finalSummary?: StringFieldUpdateOperationsInput | string
    aiEducation?: NullableStringFieldUpdateOperationsInput | string | null
    finalEducation?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLogCreateInput = {
    id?: string
    action: string
    details?: string | null
    createdAt?: Date | string
    task: ConsultationTaskCreateNestedOneWithoutLogsInput
    operator?: UserCreateNestedOneWithoutLogsInput
  }

  export type TaskLogUncheckedCreateInput = {
    id?: string
    taskId: string
    operatorId?: string | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type TaskLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: ConsultationTaskUpdateOneRequiredWithoutLogsNestedInput
    operator?: UserUpdateOneWithoutLogsNestedInput
  }

  export type TaskLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLogCreateManyInput = {
    id?: string
    taskId: string
    operatorId?: string | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type TaskLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ExpertProfileNullableRelationFilter = {
    is?: ExpertProfileWhereInput | null
    isNot?: ExpertProfileWhereInput | null
  }

  export type TaskExpertListRelationFilter = {
    every?: TaskExpertWhereInput
    some?: TaskExpertWhereInput
    none?: TaskExpertWhereInput
  }

  export type TaskLogListRelationFilter = {
    every?: TaskLogWhereInput
    some?: TaskLogWhereInput
    none?: TaskLogWhereInput
  }

  export type TaskExpertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    realName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    realName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    realName?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ExpertOpinionListRelationFilter = {
    every?: ExpertOpinionWhereInput
    some?: ExpertOpinionWhereInput
    none?: ExpertOpinionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ExpertOpinionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpertProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    titles?: SortOrder
    signatureUrl?: SortOrder
  }

  export type ExpertProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    titles?: SortOrder
    signatureUrl?: SortOrder
  }

  export type ExpertProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    titles?: SortOrder
    signatureUrl?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PreConsultationDocNullableRelationFilter = {
    is?: PreConsultationDocWhereInput | null
    isNot?: PreConsultationDocWhereInput | null
  }

  export type ConsultationDialogListRelationFilter = {
    every?: ConsultationDialogWhereInput
    some?: ConsultationDialogWhereInput
    none?: ConsultationDialogWhereInput
  }

  export type PostConsultationDocNullableRelationFilter = {
    is?: PostConsultationDocWhereInput | null
    isNot?: PostConsultationDocWhereInput | null
  }

  export type ConsultationReportNullableRelationFilter = {
    is?: ConsultationReportWhereInput | null
    isNot?: ConsultationReportWhereInput | null
  }

  export type ConsultationDialogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConsultationTaskCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    scheduledTime?: SortOrder
    patientName?: SortOrder
    patientGender?: SortOrder
    patientAge?: SortOrder
    chiefComplaint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultationTaskAvgOrderByAggregateInput = {
    patientAge?: SortOrder
  }

  export type ConsultationTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    scheduledTime?: SortOrder
    patientName?: SortOrder
    patientGender?: SortOrder
    patientAge?: SortOrder
    chiefComplaint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultationTaskMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    scheduledTime?: SortOrder
    patientName?: SortOrder
    patientGender?: SortOrder
    patientAge?: SortOrder
    chiefComplaint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultationTaskSumOrderByAggregateInput = {
    patientAge?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ConsultationTaskRelationFilter = {
    is?: ConsultationTaskWhereInput
    isNot?: ConsultationTaskWhereInput
  }

  export type TaskExpertTaskIdExpertIdCompoundUniqueInput = {
    taskId: string
    expertId: string
  }

  export type TaskExpertCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    expertId?: SortOrder
    status?: SortOrder
    isCore?: SortOrder
    invitedAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type TaskExpertMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    expertId?: SortOrder
    status?: SortOrder
    isCore?: SortOrder
    invitedAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type TaskExpertMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    expertId?: SortOrder
    status?: SortOrder
    isCore?: SortOrder
    invitedAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PreConsultationDocCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    presentIllness?: SortOrder
    pastHistory?: SortOrder
    familyHistory?: SortOrder
    extraInfo?: SortOrder
  }

  export type PreConsultationDocMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    presentIllness?: SortOrder
    pastHistory?: SortOrder
    familyHistory?: SortOrder
    extraInfo?: SortOrder
  }

  export type PreConsultationDocMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    presentIllness?: SortOrder
    pastHistory?: SortOrder
    familyHistory?: SortOrder
    extraInfo?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ConsultationDialogCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    original?: SortOrder
    startTime?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsultationDialogAvgOrderByAggregateInput = {
    startTime?: SortOrder
  }

  export type ConsultationDialogMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    original?: SortOrder
    startTime?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsultationDialogMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    original?: SortOrder
    startTime?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsultationDialogSumOrderByAggregateInput = {
    startTime?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type PostConsultationDocCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    aiContent?: SortOrder
    finalContent?: SortOrder
    isSubmitted?: SortOrder
    version?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostConsultationDocAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type PostConsultationDocMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    aiContent?: SortOrder
    finalContent?: SortOrder
    isSubmitted?: SortOrder
    version?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostConsultationDocMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    aiContent?: SortOrder
    finalContent?: SortOrder
    isSubmitted?: SortOrder
    version?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostConsultationDocSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ExpertProfileRelationFilter = {
    is?: ExpertProfileWhereInput
    isNot?: ExpertProfileWhereInput
  }

  export type ExpertOpinionCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    expertProfileId?: SortOrder
    audioUrl?: SortOrder
    asrText?: SortOrder
    aiStructured?: SortOrder
    isAiAdopted?: SortOrder
    finalText?: SortOrder
    isSubmitted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpertOpinionMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    expertProfileId?: SortOrder
    audioUrl?: SortOrder
    asrText?: SortOrder
    aiStructured?: SortOrder
    isAiAdopted?: SortOrder
    finalText?: SortOrder
    isSubmitted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpertOpinionMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    expertProfileId?: SortOrder
    audioUrl?: SortOrder
    asrText?: SortOrder
    aiStructured?: SortOrder
    isAiAdopted?: SortOrder
    finalText?: SortOrder
    isSubmitted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultationReportCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    aiSummary?: SortOrder
    finalSummary?: SortOrder
    aiEducation?: SortOrder
    finalEducation?: SortOrder
    pdfUrl?: SortOrder
    isSigned?: SortOrder
    completedAt?: SortOrder
  }

  export type ConsultationReportMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    aiSummary?: SortOrder
    finalSummary?: SortOrder
    aiEducation?: SortOrder
    finalEducation?: SortOrder
    pdfUrl?: SortOrder
    isSigned?: SortOrder
    completedAt?: SortOrder
  }

  export type ConsultationReportMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    aiSummary?: SortOrder
    finalSummary?: SortOrder
    aiEducation?: SortOrder
    finalEducation?: SortOrder
    pdfUrl?: SortOrder
    isSigned?: SortOrder
    completedAt?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TaskLogCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    operatorId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskLogMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    operatorId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskLogMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    operatorId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type ExpertProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ExpertProfileCreateWithoutUserInput, ExpertProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ExpertProfileCreateOrConnectWithoutUserInput
    connect?: ExpertProfileWhereUniqueInput
  }

  export type TaskExpertCreateNestedManyWithoutExpertInput = {
    create?: XOR<TaskExpertCreateWithoutExpertInput, TaskExpertUncheckedCreateWithoutExpertInput> | TaskExpertCreateWithoutExpertInput[] | TaskExpertUncheckedCreateWithoutExpertInput[]
    connectOrCreate?: TaskExpertCreateOrConnectWithoutExpertInput | TaskExpertCreateOrConnectWithoutExpertInput[]
    createMany?: TaskExpertCreateManyExpertInputEnvelope
    connect?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
  }

  export type TaskLogCreateNestedManyWithoutOperatorInput = {
    create?: XOR<TaskLogCreateWithoutOperatorInput, TaskLogUncheckedCreateWithoutOperatorInput> | TaskLogCreateWithoutOperatorInput[] | TaskLogUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: TaskLogCreateOrConnectWithoutOperatorInput | TaskLogCreateOrConnectWithoutOperatorInput[]
    createMany?: TaskLogCreateManyOperatorInputEnvelope
    connect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
  }

  export type ExpertProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ExpertProfileCreateWithoutUserInput, ExpertProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ExpertProfileCreateOrConnectWithoutUserInput
    connect?: ExpertProfileWhereUniqueInput
  }

  export type TaskExpertUncheckedCreateNestedManyWithoutExpertInput = {
    create?: XOR<TaskExpertCreateWithoutExpertInput, TaskExpertUncheckedCreateWithoutExpertInput> | TaskExpertCreateWithoutExpertInput[] | TaskExpertUncheckedCreateWithoutExpertInput[]
    connectOrCreate?: TaskExpertCreateOrConnectWithoutExpertInput | TaskExpertCreateOrConnectWithoutExpertInput[]
    createMany?: TaskExpertCreateManyExpertInputEnvelope
    connect?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
  }

  export type TaskLogUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<TaskLogCreateWithoutOperatorInput, TaskLogUncheckedCreateWithoutOperatorInput> | TaskLogCreateWithoutOperatorInput[] | TaskLogUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: TaskLogCreateOrConnectWithoutOperatorInput | TaskLogCreateOrConnectWithoutOperatorInput[]
    createMany?: TaskLogCreateManyOperatorInputEnvelope
    connect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ExpertProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ExpertProfileCreateWithoutUserInput, ExpertProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ExpertProfileCreateOrConnectWithoutUserInput
    upsert?: ExpertProfileUpsertWithoutUserInput
    disconnect?: ExpertProfileWhereInput | boolean
    delete?: ExpertProfileWhereInput | boolean
    connect?: ExpertProfileWhereUniqueInput
    update?: XOR<XOR<ExpertProfileUpdateToOneWithWhereWithoutUserInput, ExpertProfileUpdateWithoutUserInput>, ExpertProfileUncheckedUpdateWithoutUserInput>
  }

  export type TaskExpertUpdateManyWithoutExpertNestedInput = {
    create?: XOR<TaskExpertCreateWithoutExpertInput, TaskExpertUncheckedCreateWithoutExpertInput> | TaskExpertCreateWithoutExpertInput[] | TaskExpertUncheckedCreateWithoutExpertInput[]
    connectOrCreate?: TaskExpertCreateOrConnectWithoutExpertInput | TaskExpertCreateOrConnectWithoutExpertInput[]
    upsert?: TaskExpertUpsertWithWhereUniqueWithoutExpertInput | TaskExpertUpsertWithWhereUniqueWithoutExpertInput[]
    createMany?: TaskExpertCreateManyExpertInputEnvelope
    set?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
    disconnect?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
    delete?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
    connect?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
    update?: TaskExpertUpdateWithWhereUniqueWithoutExpertInput | TaskExpertUpdateWithWhereUniqueWithoutExpertInput[]
    updateMany?: TaskExpertUpdateManyWithWhereWithoutExpertInput | TaskExpertUpdateManyWithWhereWithoutExpertInput[]
    deleteMany?: TaskExpertScalarWhereInput | TaskExpertScalarWhereInput[]
  }

  export type TaskLogUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<TaskLogCreateWithoutOperatorInput, TaskLogUncheckedCreateWithoutOperatorInput> | TaskLogCreateWithoutOperatorInput[] | TaskLogUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: TaskLogCreateOrConnectWithoutOperatorInput | TaskLogCreateOrConnectWithoutOperatorInput[]
    upsert?: TaskLogUpsertWithWhereUniqueWithoutOperatorInput | TaskLogUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: TaskLogCreateManyOperatorInputEnvelope
    set?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    disconnect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    delete?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    connect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    update?: TaskLogUpdateWithWhereUniqueWithoutOperatorInput | TaskLogUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: TaskLogUpdateManyWithWhereWithoutOperatorInput | TaskLogUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: TaskLogScalarWhereInput | TaskLogScalarWhereInput[]
  }

  export type ExpertProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ExpertProfileCreateWithoutUserInput, ExpertProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ExpertProfileCreateOrConnectWithoutUserInput
    upsert?: ExpertProfileUpsertWithoutUserInput
    disconnect?: ExpertProfileWhereInput | boolean
    delete?: ExpertProfileWhereInput | boolean
    connect?: ExpertProfileWhereUniqueInput
    update?: XOR<XOR<ExpertProfileUpdateToOneWithWhereWithoutUserInput, ExpertProfileUpdateWithoutUserInput>, ExpertProfileUncheckedUpdateWithoutUserInput>
  }

  export type TaskExpertUncheckedUpdateManyWithoutExpertNestedInput = {
    create?: XOR<TaskExpertCreateWithoutExpertInput, TaskExpertUncheckedCreateWithoutExpertInput> | TaskExpertCreateWithoutExpertInput[] | TaskExpertUncheckedCreateWithoutExpertInput[]
    connectOrCreate?: TaskExpertCreateOrConnectWithoutExpertInput | TaskExpertCreateOrConnectWithoutExpertInput[]
    upsert?: TaskExpertUpsertWithWhereUniqueWithoutExpertInput | TaskExpertUpsertWithWhereUniqueWithoutExpertInput[]
    createMany?: TaskExpertCreateManyExpertInputEnvelope
    set?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
    disconnect?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
    delete?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
    connect?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
    update?: TaskExpertUpdateWithWhereUniqueWithoutExpertInput | TaskExpertUpdateWithWhereUniqueWithoutExpertInput[]
    updateMany?: TaskExpertUpdateManyWithWhereWithoutExpertInput | TaskExpertUpdateManyWithWhereWithoutExpertInput[]
    deleteMany?: TaskExpertScalarWhereInput | TaskExpertScalarWhereInput[]
  }

  export type TaskLogUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<TaskLogCreateWithoutOperatorInput, TaskLogUncheckedCreateWithoutOperatorInput> | TaskLogCreateWithoutOperatorInput[] | TaskLogUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: TaskLogCreateOrConnectWithoutOperatorInput | TaskLogCreateOrConnectWithoutOperatorInput[]
    upsert?: TaskLogUpsertWithWhereUniqueWithoutOperatorInput | TaskLogUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: TaskLogCreateManyOperatorInputEnvelope
    set?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    disconnect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    delete?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    connect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    update?: TaskLogUpdateWithWhereUniqueWithoutOperatorInput | TaskLogUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: TaskLogUpdateManyWithWhereWithoutOperatorInput | TaskLogUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: TaskLogScalarWhereInput | TaskLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutExpertProfileInput = {
    create?: XOR<UserCreateWithoutExpertProfileInput, UserUncheckedCreateWithoutExpertProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpertProfileInput
    connect?: UserWhereUniqueInput
  }

  export type ExpertOpinionCreateNestedManyWithoutExpertInput = {
    create?: XOR<ExpertOpinionCreateWithoutExpertInput, ExpertOpinionUncheckedCreateWithoutExpertInput> | ExpertOpinionCreateWithoutExpertInput[] | ExpertOpinionUncheckedCreateWithoutExpertInput[]
    connectOrCreate?: ExpertOpinionCreateOrConnectWithoutExpertInput | ExpertOpinionCreateOrConnectWithoutExpertInput[]
    createMany?: ExpertOpinionCreateManyExpertInputEnvelope
    connect?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
  }

  export type ExpertOpinionUncheckedCreateNestedManyWithoutExpertInput = {
    create?: XOR<ExpertOpinionCreateWithoutExpertInput, ExpertOpinionUncheckedCreateWithoutExpertInput> | ExpertOpinionCreateWithoutExpertInput[] | ExpertOpinionUncheckedCreateWithoutExpertInput[]
    connectOrCreate?: ExpertOpinionCreateOrConnectWithoutExpertInput | ExpertOpinionCreateOrConnectWithoutExpertInput[]
    createMany?: ExpertOpinionCreateManyExpertInputEnvelope
    connect?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneRequiredWithoutExpertProfileNestedInput = {
    create?: XOR<UserCreateWithoutExpertProfileInput, UserUncheckedCreateWithoutExpertProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpertProfileInput
    upsert?: UserUpsertWithoutExpertProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpertProfileInput, UserUpdateWithoutExpertProfileInput>, UserUncheckedUpdateWithoutExpertProfileInput>
  }

  export type ExpertOpinionUpdateManyWithoutExpertNestedInput = {
    create?: XOR<ExpertOpinionCreateWithoutExpertInput, ExpertOpinionUncheckedCreateWithoutExpertInput> | ExpertOpinionCreateWithoutExpertInput[] | ExpertOpinionUncheckedCreateWithoutExpertInput[]
    connectOrCreate?: ExpertOpinionCreateOrConnectWithoutExpertInput | ExpertOpinionCreateOrConnectWithoutExpertInput[]
    upsert?: ExpertOpinionUpsertWithWhereUniqueWithoutExpertInput | ExpertOpinionUpsertWithWhereUniqueWithoutExpertInput[]
    createMany?: ExpertOpinionCreateManyExpertInputEnvelope
    set?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
    disconnect?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
    delete?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
    connect?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
    update?: ExpertOpinionUpdateWithWhereUniqueWithoutExpertInput | ExpertOpinionUpdateWithWhereUniqueWithoutExpertInput[]
    updateMany?: ExpertOpinionUpdateManyWithWhereWithoutExpertInput | ExpertOpinionUpdateManyWithWhereWithoutExpertInput[]
    deleteMany?: ExpertOpinionScalarWhereInput | ExpertOpinionScalarWhereInput[]
  }

  export type ExpertOpinionUncheckedUpdateManyWithoutExpertNestedInput = {
    create?: XOR<ExpertOpinionCreateWithoutExpertInput, ExpertOpinionUncheckedCreateWithoutExpertInput> | ExpertOpinionCreateWithoutExpertInput[] | ExpertOpinionUncheckedCreateWithoutExpertInput[]
    connectOrCreate?: ExpertOpinionCreateOrConnectWithoutExpertInput | ExpertOpinionCreateOrConnectWithoutExpertInput[]
    upsert?: ExpertOpinionUpsertWithWhereUniqueWithoutExpertInput | ExpertOpinionUpsertWithWhereUniqueWithoutExpertInput[]
    createMany?: ExpertOpinionCreateManyExpertInputEnvelope
    set?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
    disconnect?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
    delete?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
    connect?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
    update?: ExpertOpinionUpdateWithWhereUniqueWithoutExpertInput | ExpertOpinionUpdateWithWhereUniqueWithoutExpertInput[]
    updateMany?: ExpertOpinionUpdateManyWithWhereWithoutExpertInput | ExpertOpinionUpdateManyWithWhereWithoutExpertInput[]
    deleteMany?: ExpertOpinionScalarWhereInput | ExpertOpinionScalarWhereInput[]
  }

  export type PreConsultationDocCreateNestedOneWithoutTaskInput = {
    create?: XOR<PreConsultationDocCreateWithoutTaskInput, PreConsultationDocUncheckedCreateWithoutTaskInput>
    connectOrCreate?: PreConsultationDocCreateOrConnectWithoutTaskInput
    connect?: PreConsultationDocWhereUniqueInput
  }

  export type ConsultationDialogCreateNestedManyWithoutTaskInput = {
    create?: XOR<ConsultationDialogCreateWithoutTaskInput, ConsultationDialogUncheckedCreateWithoutTaskInput> | ConsultationDialogCreateWithoutTaskInput[] | ConsultationDialogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: ConsultationDialogCreateOrConnectWithoutTaskInput | ConsultationDialogCreateOrConnectWithoutTaskInput[]
    createMany?: ConsultationDialogCreateManyTaskInputEnvelope
    connect?: ConsultationDialogWhereUniqueInput | ConsultationDialogWhereUniqueInput[]
  }

  export type PostConsultationDocCreateNestedOneWithoutTaskInput = {
    create?: XOR<PostConsultationDocCreateWithoutTaskInput, PostConsultationDocUncheckedCreateWithoutTaskInput>
    connectOrCreate?: PostConsultationDocCreateOrConnectWithoutTaskInput
    connect?: PostConsultationDocWhereUniqueInput
  }

  export type ExpertOpinionCreateNestedManyWithoutTaskInput = {
    create?: XOR<ExpertOpinionCreateWithoutTaskInput, ExpertOpinionUncheckedCreateWithoutTaskInput> | ExpertOpinionCreateWithoutTaskInput[] | ExpertOpinionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: ExpertOpinionCreateOrConnectWithoutTaskInput | ExpertOpinionCreateOrConnectWithoutTaskInput[]
    createMany?: ExpertOpinionCreateManyTaskInputEnvelope
    connect?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
  }

  export type ConsultationReportCreateNestedOneWithoutTaskInput = {
    create?: XOR<ConsultationReportCreateWithoutTaskInput, ConsultationReportUncheckedCreateWithoutTaskInput>
    connectOrCreate?: ConsultationReportCreateOrConnectWithoutTaskInput
    connect?: ConsultationReportWhereUniqueInput
  }

  export type TaskExpertCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskExpertCreateWithoutTaskInput, TaskExpertUncheckedCreateWithoutTaskInput> | TaskExpertCreateWithoutTaskInput[] | TaskExpertUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskExpertCreateOrConnectWithoutTaskInput | TaskExpertCreateOrConnectWithoutTaskInput[]
    createMany?: TaskExpertCreateManyTaskInputEnvelope
    connect?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
  }

  export type TaskLogCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskLogCreateWithoutTaskInput, TaskLogUncheckedCreateWithoutTaskInput> | TaskLogCreateWithoutTaskInput[] | TaskLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLogCreateOrConnectWithoutTaskInput | TaskLogCreateOrConnectWithoutTaskInput[]
    createMany?: TaskLogCreateManyTaskInputEnvelope
    connect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
  }

  export type PreConsultationDocUncheckedCreateNestedOneWithoutTaskInput = {
    create?: XOR<PreConsultationDocCreateWithoutTaskInput, PreConsultationDocUncheckedCreateWithoutTaskInput>
    connectOrCreate?: PreConsultationDocCreateOrConnectWithoutTaskInput
    connect?: PreConsultationDocWhereUniqueInput
  }

  export type ConsultationDialogUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<ConsultationDialogCreateWithoutTaskInput, ConsultationDialogUncheckedCreateWithoutTaskInput> | ConsultationDialogCreateWithoutTaskInput[] | ConsultationDialogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: ConsultationDialogCreateOrConnectWithoutTaskInput | ConsultationDialogCreateOrConnectWithoutTaskInput[]
    createMany?: ConsultationDialogCreateManyTaskInputEnvelope
    connect?: ConsultationDialogWhereUniqueInput | ConsultationDialogWhereUniqueInput[]
  }

  export type PostConsultationDocUncheckedCreateNestedOneWithoutTaskInput = {
    create?: XOR<PostConsultationDocCreateWithoutTaskInput, PostConsultationDocUncheckedCreateWithoutTaskInput>
    connectOrCreate?: PostConsultationDocCreateOrConnectWithoutTaskInput
    connect?: PostConsultationDocWhereUniqueInput
  }

  export type ExpertOpinionUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<ExpertOpinionCreateWithoutTaskInput, ExpertOpinionUncheckedCreateWithoutTaskInput> | ExpertOpinionCreateWithoutTaskInput[] | ExpertOpinionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: ExpertOpinionCreateOrConnectWithoutTaskInput | ExpertOpinionCreateOrConnectWithoutTaskInput[]
    createMany?: ExpertOpinionCreateManyTaskInputEnvelope
    connect?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
  }

  export type ConsultationReportUncheckedCreateNestedOneWithoutTaskInput = {
    create?: XOR<ConsultationReportCreateWithoutTaskInput, ConsultationReportUncheckedCreateWithoutTaskInput>
    connectOrCreate?: ConsultationReportCreateOrConnectWithoutTaskInput
    connect?: ConsultationReportWhereUniqueInput
  }

  export type TaskExpertUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskExpertCreateWithoutTaskInput, TaskExpertUncheckedCreateWithoutTaskInput> | TaskExpertCreateWithoutTaskInput[] | TaskExpertUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskExpertCreateOrConnectWithoutTaskInput | TaskExpertCreateOrConnectWithoutTaskInput[]
    createMany?: TaskExpertCreateManyTaskInputEnvelope
    connect?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
  }

  export type TaskLogUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskLogCreateWithoutTaskInput, TaskLogUncheckedCreateWithoutTaskInput> | TaskLogCreateWithoutTaskInput[] | TaskLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLogCreateOrConnectWithoutTaskInput | TaskLogCreateOrConnectWithoutTaskInput[]
    createMany?: TaskLogCreateManyTaskInputEnvelope
    connect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PreConsultationDocUpdateOneWithoutTaskNestedInput = {
    create?: XOR<PreConsultationDocCreateWithoutTaskInput, PreConsultationDocUncheckedCreateWithoutTaskInput>
    connectOrCreate?: PreConsultationDocCreateOrConnectWithoutTaskInput
    upsert?: PreConsultationDocUpsertWithoutTaskInput
    disconnect?: PreConsultationDocWhereInput | boolean
    delete?: PreConsultationDocWhereInput | boolean
    connect?: PreConsultationDocWhereUniqueInput
    update?: XOR<XOR<PreConsultationDocUpdateToOneWithWhereWithoutTaskInput, PreConsultationDocUpdateWithoutTaskInput>, PreConsultationDocUncheckedUpdateWithoutTaskInput>
  }

  export type ConsultationDialogUpdateManyWithoutTaskNestedInput = {
    create?: XOR<ConsultationDialogCreateWithoutTaskInput, ConsultationDialogUncheckedCreateWithoutTaskInput> | ConsultationDialogCreateWithoutTaskInput[] | ConsultationDialogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: ConsultationDialogCreateOrConnectWithoutTaskInput | ConsultationDialogCreateOrConnectWithoutTaskInput[]
    upsert?: ConsultationDialogUpsertWithWhereUniqueWithoutTaskInput | ConsultationDialogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: ConsultationDialogCreateManyTaskInputEnvelope
    set?: ConsultationDialogWhereUniqueInput | ConsultationDialogWhereUniqueInput[]
    disconnect?: ConsultationDialogWhereUniqueInput | ConsultationDialogWhereUniqueInput[]
    delete?: ConsultationDialogWhereUniqueInput | ConsultationDialogWhereUniqueInput[]
    connect?: ConsultationDialogWhereUniqueInput | ConsultationDialogWhereUniqueInput[]
    update?: ConsultationDialogUpdateWithWhereUniqueWithoutTaskInput | ConsultationDialogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: ConsultationDialogUpdateManyWithWhereWithoutTaskInput | ConsultationDialogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: ConsultationDialogScalarWhereInput | ConsultationDialogScalarWhereInput[]
  }

  export type PostConsultationDocUpdateOneWithoutTaskNestedInput = {
    create?: XOR<PostConsultationDocCreateWithoutTaskInput, PostConsultationDocUncheckedCreateWithoutTaskInput>
    connectOrCreate?: PostConsultationDocCreateOrConnectWithoutTaskInput
    upsert?: PostConsultationDocUpsertWithoutTaskInput
    disconnect?: PostConsultationDocWhereInput | boolean
    delete?: PostConsultationDocWhereInput | boolean
    connect?: PostConsultationDocWhereUniqueInput
    update?: XOR<XOR<PostConsultationDocUpdateToOneWithWhereWithoutTaskInput, PostConsultationDocUpdateWithoutTaskInput>, PostConsultationDocUncheckedUpdateWithoutTaskInput>
  }

  export type ExpertOpinionUpdateManyWithoutTaskNestedInput = {
    create?: XOR<ExpertOpinionCreateWithoutTaskInput, ExpertOpinionUncheckedCreateWithoutTaskInput> | ExpertOpinionCreateWithoutTaskInput[] | ExpertOpinionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: ExpertOpinionCreateOrConnectWithoutTaskInput | ExpertOpinionCreateOrConnectWithoutTaskInput[]
    upsert?: ExpertOpinionUpsertWithWhereUniqueWithoutTaskInput | ExpertOpinionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: ExpertOpinionCreateManyTaskInputEnvelope
    set?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
    disconnect?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
    delete?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
    connect?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
    update?: ExpertOpinionUpdateWithWhereUniqueWithoutTaskInput | ExpertOpinionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: ExpertOpinionUpdateManyWithWhereWithoutTaskInput | ExpertOpinionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: ExpertOpinionScalarWhereInput | ExpertOpinionScalarWhereInput[]
  }

  export type ConsultationReportUpdateOneWithoutTaskNestedInput = {
    create?: XOR<ConsultationReportCreateWithoutTaskInput, ConsultationReportUncheckedCreateWithoutTaskInput>
    connectOrCreate?: ConsultationReportCreateOrConnectWithoutTaskInput
    upsert?: ConsultationReportUpsertWithoutTaskInput
    disconnect?: ConsultationReportWhereInput | boolean
    delete?: ConsultationReportWhereInput | boolean
    connect?: ConsultationReportWhereUniqueInput
    update?: XOR<XOR<ConsultationReportUpdateToOneWithWhereWithoutTaskInput, ConsultationReportUpdateWithoutTaskInput>, ConsultationReportUncheckedUpdateWithoutTaskInput>
  }

  export type TaskExpertUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskExpertCreateWithoutTaskInput, TaskExpertUncheckedCreateWithoutTaskInput> | TaskExpertCreateWithoutTaskInput[] | TaskExpertUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskExpertCreateOrConnectWithoutTaskInput | TaskExpertCreateOrConnectWithoutTaskInput[]
    upsert?: TaskExpertUpsertWithWhereUniqueWithoutTaskInput | TaskExpertUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskExpertCreateManyTaskInputEnvelope
    set?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
    disconnect?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
    delete?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
    connect?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
    update?: TaskExpertUpdateWithWhereUniqueWithoutTaskInput | TaskExpertUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskExpertUpdateManyWithWhereWithoutTaskInput | TaskExpertUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskExpertScalarWhereInput | TaskExpertScalarWhereInput[]
  }

  export type TaskLogUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskLogCreateWithoutTaskInput, TaskLogUncheckedCreateWithoutTaskInput> | TaskLogCreateWithoutTaskInput[] | TaskLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLogCreateOrConnectWithoutTaskInput | TaskLogCreateOrConnectWithoutTaskInput[]
    upsert?: TaskLogUpsertWithWhereUniqueWithoutTaskInput | TaskLogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskLogCreateManyTaskInputEnvelope
    set?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    disconnect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    delete?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    connect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    update?: TaskLogUpdateWithWhereUniqueWithoutTaskInput | TaskLogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskLogUpdateManyWithWhereWithoutTaskInput | TaskLogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskLogScalarWhereInput | TaskLogScalarWhereInput[]
  }

  export type PreConsultationDocUncheckedUpdateOneWithoutTaskNestedInput = {
    create?: XOR<PreConsultationDocCreateWithoutTaskInput, PreConsultationDocUncheckedCreateWithoutTaskInput>
    connectOrCreate?: PreConsultationDocCreateOrConnectWithoutTaskInput
    upsert?: PreConsultationDocUpsertWithoutTaskInput
    disconnect?: PreConsultationDocWhereInput | boolean
    delete?: PreConsultationDocWhereInput | boolean
    connect?: PreConsultationDocWhereUniqueInput
    update?: XOR<XOR<PreConsultationDocUpdateToOneWithWhereWithoutTaskInput, PreConsultationDocUpdateWithoutTaskInput>, PreConsultationDocUncheckedUpdateWithoutTaskInput>
  }

  export type ConsultationDialogUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<ConsultationDialogCreateWithoutTaskInput, ConsultationDialogUncheckedCreateWithoutTaskInput> | ConsultationDialogCreateWithoutTaskInput[] | ConsultationDialogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: ConsultationDialogCreateOrConnectWithoutTaskInput | ConsultationDialogCreateOrConnectWithoutTaskInput[]
    upsert?: ConsultationDialogUpsertWithWhereUniqueWithoutTaskInput | ConsultationDialogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: ConsultationDialogCreateManyTaskInputEnvelope
    set?: ConsultationDialogWhereUniqueInput | ConsultationDialogWhereUniqueInput[]
    disconnect?: ConsultationDialogWhereUniqueInput | ConsultationDialogWhereUniqueInput[]
    delete?: ConsultationDialogWhereUniqueInput | ConsultationDialogWhereUniqueInput[]
    connect?: ConsultationDialogWhereUniqueInput | ConsultationDialogWhereUniqueInput[]
    update?: ConsultationDialogUpdateWithWhereUniqueWithoutTaskInput | ConsultationDialogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: ConsultationDialogUpdateManyWithWhereWithoutTaskInput | ConsultationDialogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: ConsultationDialogScalarWhereInput | ConsultationDialogScalarWhereInput[]
  }

  export type PostConsultationDocUncheckedUpdateOneWithoutTaskNestedInput = {
    create?: XOR<PostConsultationDocCreateWithoutTaskInput, PostConsultationDocUncheckedCreateWithoutTaskInput>
    connectOrCreate?: PostConsultationDocCreateOrConnectWithoutTaskInput
    upsert?: PostConsultationDocUpsertWithoutTaskInput
    disconnect?: PostConsultationDocWhereInput | boolean
    delete?: PostConsultationDocWhereInput | boolean
    connect?: PostConsultationDocWhereUniqueInput
    update?: XOR<XOR<PostConsultationDocUpdateToOneWithWhereWithoutTaskInput, PostConsultationDocUpdateWithoutTaskInput>, PostConsultationDocUncheckedUpdateWithoutTaskInput>
  }

  export type ExpertOpinionUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<ExpertOpinionCreateWithoutTaskInput, ExpertOpinionUncheckedCreateWithoutTaskInput> | ExpertOpinionCreateWithoutTaskInput[] | ExpertOpinionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: ExpertOpinionCreateOrConnectWithoutTaskInput | ExpertOpinionCreateOrConnectWithoutTaskInput[]
    upsert?: ExpertOpinionUpsertWithWhereUniqueWithoutTaskInput | ExpertOpinionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: ExpertOpinionCreateManyTaskInputEnvelope
    set?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
    disconnect?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
    delete?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
    connect?: ExpertOpinionWhereUniqueInput | ExpertOpinionWhereUniqueInput[]
    update?: ExpertOpinionUpdateWithWhereUniqueWithoutTaskInput | ExpertOpinionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: ExpertOpinionUpdateManyWithWhereWithoutTaskInput | ExpertOpinionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: ExpertOpinionScalarWhereInput | ExpertOpinionScalarWhereInput[]
  }

  export type ConsultationReportUncheckedUpdateOneWithoutTaskNestedInput = {
    create?: XOR<ConsultationReportCreateWithoutTaskInput, ConsultationReportUncheckedCreateWithoutTaskInput>
    connectOrCreate?: ConsultationReportCreateOrConnectWithoutTaskInput
    upsert?: ConsultationReportUpsertWithoutTaskInput
    disconnect?: ConsultationReportWhereInput | boolean
    delete?: ConsultationReportWhereInput | boolean
    connect?: ConsultationReportWhereUniqueInput
    update?: XOR<XOR<ConsultationReportUpdateToOneWithWhereWithoutTaskInput, ConsultationReportUpdateWithoutTaskInput>, ConsultationReportUncheckedUpdateWithoutTaskInput>
  }

  export type TaskExpertUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskExpertCreateWithoutTaskInput, TaskExpertUncheckedCreateWithoutTaskInput> | TaskExpertCreateWithoutTaskInput[] | TaskExpertUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskExpertCreateOrConnectWithoutTaskInput | TaskExpertCreateOrConnectWithoutTaskInput[]
    upsert?: TaskExpertUpsertWithWhereUniqueWithoutTaskInput | TaskExpertUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskExpertCreateManyTaskInputEnvelope
    set?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
    disconnect?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
    delete?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
    connect?: TaskExpertWhereUniqueInput | TaskExpertWhereUniqueInput[]
    update?: TaskExpertUpdateWithWhereUniqueWithoutTaskInput | TaskExpertUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskExpertUpdateManyWithWhereWithoutTaskInput | TaskExpertUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskExpertScalarWhereInput | TaskExpertScalarWhereInput[]
  }

  export type TaskLogUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskLogCreateWithoutTaskInput, TaskLogUncheckedCreateWithoutTaskInput> | TaskLogCreateWithoutTaskInput[] | TaskLogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskLogCreateOrConnectWithoutTaskInput | TaskLogCreateOrConnectWithoutTaskInput[]
    upsert?: TaskLogUpsertWithWhereUniqueWithoutTaskInput | TaskLogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskLogCreateManyTaskInputEnvelope
    set?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    disconnect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    delete?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    connect?: TaskLogWhereUniqueInput | TaskLogWhereUniqueInput[]
    update?: TaskLogUpdateWithWhereUniqueWithoutTaskInput | TaskLogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskLogUpdateManyWithWhereWithoutTaskInput | TaskLogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskLogScalarWhereInput | TaskLogScalarWhereInput[]
  }

  export type ConsultationTaskCreateNestedOneWithoutExpertsInput = {
    create?: XOR<ConsultationTaskCreateWithoutExpertsInput, ConsultationTaskUncheckedCreateWithoutExpertsInput>
    connectOrCreate?: ConsultationTaskCreateOrConnectWithoutExpertsInput
    connect?: ConsultationTaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExpertTasksInput = {
    create?: XOR<UserCreateWithoutExpertTasksInput, UserUncheckedCreateWithoutExpertTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpertTasksInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ConsultationTaskUpdateOneRequiredWithoutExpertsNestedInput = {
    create?: XOR<ConsultationTaskCreateWithoutExpertsInput, ConsultationTaskUncheckedCreateWithoutExpertsInput>
    connectOrCreate?: ConsultationTaskCreateOrConnectWithoutExpertsInput
    upsert?: ConsultationTaskUpsertWithoutExpertsInput
    connect?: ConsultationTaskWhereUniqueInput
    update?: XOR<XOR<ConsultationTaskUpdateToOneWithWhereWithoutExpertsInput, ConsultationTaskUpdateWithoutExpertsInput>, ConsultationTaskUncheckedUpdateWithoutExpertsInput>
  }

  export type UserUpdateOneRequiredWithoutExpertTasksNestedInput = {
    create?: XOR<UserCreateWithoutExpertTasksInput, UserUncheckedCreateWithoutExpertTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpertTasksInput
    upsert?: UserUpsertWithoutExpertTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpertTasksInput, UserUpdateWithoutExpertTasksInput>, UserUncheckedUpdateWithoutExpertTasksInput>
  }

  export type ConsultationTaskCreateNestedOneWithoutPreDocInput = {
    create?: XOR<ConsultationTaskCreateWithoutPreDocInput, ConsultationTaskUncheckedCreateWithoutPreDocInput>
    connectOrCreate?: ConsultationTaskCreateOrConnectWithoutPreDocInput
    connect?: ConsultationTaskWhereUniqueInput
  }

  export type ConsultationTaskUpdateOneRequiredWithoutPreDocNestedInput = {
    create?: XOR<ConsultationTaskCreateWithoutPreDocInput, ConsultationTaskUncheckedCreateWithoutPreDocInput>
    connectOrCreate?: ConsultationTaskCreateOrConnectWithoutPreDocInput
    upsert?: ConsultationTaskUpsertWithoutPreDocInput
    connect?: ConsultationTaskWhereUniqueInput
    update?: XOR<XOR<ConsultationTaskUpdateToOneWithWhereWithoutPreDocInput, ConsultationTaskUpdateWithoutPreDocInput>, ConsultationTaskUncheckedUpdateWithoutPreDocInput>
  }

  export type ConsultationTaskCreateNestedOneWithoutDialogsInput = {
    create?: XOR<ConsultationTaskCreateWithoutDialogsInput, ConsultationTaskUncheckedCreateWithoutDialogsInput>
    connectOrCreate?: ConsultationTaskCreateOrConnectWithoutDialogsInput
    connect?: ConsultationTaskWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConsultationTaskUpdateOneRequiredWithoutDialogsNestedInput = {
    create?: XOR<ConsultationTaskCreateWithoutDialogsInput, ConsultationTaskUncheckedCreateWithoutDialogsInput>
    connectOrCreate?: ConsultationTaskCreateOrConnectWithoutDialogsInput
    upsert?: ConsultationTaskUpsertWithoutDialogsInput
    connect?: ConsultationTaskWhereUniqueInput
    update?: XOR<XOR<ConsultationTaskUpdateToOneWithWhereWithoutDialogsInput, ConsultationTaskUpdateWithoutDialogsInput>, ConsultationTaskUncheckedUpdateWithoutDialogsInput>
  }

  export type ConsultationTaskCreateNestedOneWithoutPostDocInput = {
    create?: XOR<ConsultationTaskCreateWithoutPostDocInput, ConsultationTaskUncheckedCreateWithoutPostDocInput>
    connectOrCreate?: ConsultationTaskCreateOrConnectWithoutPostDocInput
    connect?: ConsultationTaskWhereUniqueInput
  }

  export type ConsultationTaskUpdateOneRequiredWithoutPostDocNestedInput = {
    create?: XOR<ConsultationTaskCreateWithoutPostDocInput, ConsultationTaskUncheckedCreateWithoutPostDocInput>
    connectOrCreate?: ConsultationTaskCreateOrConnectWithoutPostDocInput
    upsert?: ConsultationTaskUpsertWithoutPostDocInput
    connect?: ConsultationTaskWhereUniqueInput
    update?: XOR<XOR<ConsultationTaskUpdateToOneWithWhereWithoutPostDocInput, ConsultationTaskUpdateWithoutPostDocInput>, ConsultationTaskUncheckedUpdateWithoutPostDocInput>
  }

  export type ConsultationTaskCreateNestedOneWithoutOpinionsInput = {
    create?: XOR<ConsultationTaskCreateWithoutOpinionsInput, ConsultationTaskUncheckedCreateWithoutOpinionsInput>
    connectOrCreate?: ConsultationTaskCreateOrConnectWithoutOpinionsInput
    connect?: ConsultationTaskWhereUniqueInput
  }

  export type ExpertProfileCreateNestedOneWithoutOpinionsInput = {
    create?: XOR<ExpertProfileCreateWithoutOpinionsInput, ExpertProfileUncheckedCreateWithoutOpinionsInput>
    connectOrCreate?: ExpertProfileCreateOrConnectWithoutOpinionsInput
    connect?: ExpertProfileWhereUniqueInput
  }

  export type ConsultationTaskUpdateOneRequiredWithoutOpinionsNestedInput = {
    create?: XOR<ConsultationTaskCreateWithoutOpinionsInput, ConsultationTaskUncheckedCreateWithoutOpinionsInput>
    connectOrCreate?: ConsultationTaskCreateOrConnectWithoutOpinionsInput
    upsert?: ConsultationTaskUpsertWithoutOpinionsInput
    connect?: ConsultationTaskWhereUniqueInput
    update?: XOR<XOR<ConsultationTaskUpdateToOneWithWhereWithoutOpinionsInput, ConsultationTaskUpdateWithoutOpinionsInput>, ConsultationTaskUncheckedUpdateWithoutOpinionsInput>
  }

  export type ExpertProfileUpdateOneRequiredWithoutOpinionsNestedInput = {
    create?: XOR<ExpertProfileCreateWithoutOpinionsInput, ExpertProfileUncheckedCreateWithoutOpinionsInput>
    connectOrCreate?: ExpertProfileCreateOrConnectWithoutOpinionsInput
    upsert?: ExpertProfileUpsertWithoutOpinionsInput
    connect?: ExpertProfileWhereUniqueInput
    update?: XOR<XOR<ExpertProfileUpdateToOneWithWhereWithoutOpinionsInput, ExpertProfileUpdateWithoutOpinionsInput>, ExpertProfileUncheckedUpdateWithoutOpinionsInput>
  }

  export type ConsultationTaskCreateNestedOneWithoutReportInput = {
    create?: XOR<ConsultationTaskCreateWithoutReportInput, ConsultationTaskUncheckedCreateWithoutReportInput>
    connectOrCreate?: ConsultationTaskCreateOrConnectWithoutReportInput
    connect?: ConsultationTaskWhereUniqueInput
  }

  export type ConsultationTaskUpdateOneRequiredWithoutReportNestedInput = {
    create?: XOR<ConsultationTaskCreateWithoutReportInput, ConsultationTaskUncheckedCreateWithoutReportInput>
    connectOrCreate?: ConsultationTaskCreateOrConnectWithoutReportInput
    upsert?: ConsultationTaskUpsertWithoutReportInput
    connect?: ConsultationTaskWhereUniqueInput
    update?: XOR<XOR<ConsultationTaskUpdateToOneWithWhereWithoutReportInput, ConsultationTaskUpdateWithoutReportInput>, ConsultationTaskUncheckedUpdateWithoutReportInput>
  }

  export type ConsultationTaskCreateNestedOneWithoutLogsInput = {
    create?: XOR<ConsultationTaskCreateWithoutLogsInput, ConsultationTaskUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ConsultationTaskCreateOrConnectWithoutLogsInput
    connect?: ConsultationTaskWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type ConsultationTaskUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<ConsultationTaskCreateWithoutLogsInput, ConsultationTaskUncheckedCreateWithoutLogsInput>
    connectOrCreate?: ConsultationTaskCreateOrConnectWithoutLogsInput
    upsert?: ConsultationTaskUpsertWithoutLogsInput
    connect?: ConsultationTaskWhereUniqueInput
    update?: XOR<XOR<ConsultationTaskUpdateToOneWithWhereWithoutLogsInput, ConsultationTaskUpdateWithoutLogsInput>, ConsultationTaskUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateOneWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ExpertProfileCreateWithoutUserInput = {
    id?: string
    department: string
    titles: string
    signatureUrl?: string | null
    opinions?: ExpertOpinionCreateNestedManyWithoutExpertInput
  }

  export type ExpertProfileUncheckedCreateWithoutUserInput = {
    id?: string
    department: string
    titles: string
    signatureUrl?: string | null
    opinions?: ExpertOpinionUncheckedCreateNestedManyWithoutExpertInput
  }

  export type ExpertProfileCreateOrConnectWithoutUserInput = {
    where: ExpertProfileWhereUniqueInput
    create: XOR<ExpertProfileCreateWithoutUserInput, ExpertProfileUncheckedCreateWithoutUserInput>
  }

  export type TaskExpertCreateWithoutExpertInput = {
    id?: string
    status?: string
    isCore?: boolean
    invitedAt?: Date | string
    respondedAt?: Date | string | null
    task: ConsultationTaskCreateNestedOneWithoutExpertsInput
  }

  export type TaskExpertUncheckedCreateWithoutExpertInput = {
    id?: string
    taskId: string
    status?: string
    isCore?: boolean
    invitedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type TaskExpertCreateOrConnectWithoutExpertInput = {
    where: TaskExpertWhereUniqueInput
    create: XOR<TaskExpertCreateWithoutExpertInput, TaskExpertUncheckedCreateWithoutExpertInput>
  }

  export type TaskExpertCreateManyExpertInputEnvelope = {
    data: TaskExpertCreateManyExpertInput | TaskExpertCreateManyExpertInput[]
  }

  export type TaskLogCreateWithoutOperatorInput = {
    id?: string
    action: string
    details?: string | null
    createdAt?: Date | string
    task: ConsultationTaskCreateNestedOneWithoutLogsInput
  }

  export type TaskLogUncheckedCreateWithoutOperatorInput = {
    id?: string
    taskId: string
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type TaskLogCreateOrConnectWithoutOperatorInput = {
    where: TaskLogWhereUniqueInput
    create: XOR<TaskLogCreateWithoutOperatorInput, TaskLogUncheckedCreateWithoutOperatorInput>
  }

  export type TaskLogCreateManyOperatorInputEnvelope = {
    data: TaskLogCreateManyOperatorInput | TaskLogCreateManyOperatorInput[]
  }

  export type ExpertProfileUpsertWithoutUserInput = {
    update: XOR<ExpertProfileUpdateWithoutUserInput, ExpertProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ExpertProfileCreateWithoutUserInput, ExpertProfileUncheckedCreateWithoutUserInput>
    where?: ExpertProfileWhereInput
  }

  export type ExpertProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ExpertProfileWhereInput
    data: XOR<ExpertProfileUpdateWithoutUserInput, ExpertProfileUncheckedUpdateWithoutUserInput>
  }

  export type ExpertProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    titles?: StringFieldUpdateOperationsInput | string
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    opinions?: ExpertOpinionUpdateManyWithoutExpertNestedInput
  }

  export type ExpertProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    titles?: StringFieldUpdateOperationsInput | string
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    opinions?: ExpertOpinionUncheckedUpdateManyWithoutExpertNestedInput
  }

  export type TaskExpertUpsertWithWhereUniqueWithoutExpertInput = {
    where: TaskExpertWhereUniqueInput
    update: XOR<TaskExpertUpdateWithoutExpertInput, TaskExpertUncheckedUpdateWithoutExpertInput>
    create: XOR<TaskExpertCreateWithoutExpertInput, TaskExpertUncheckedCreateWithoutExpertInput>
  }

  export type TaskExpertUpdateWithWhereUniqueWithoutExpertInput = {
    where: TaskExpertWhereUniqueInput
    data: XOR<TaskExpertUpdateWithoutExpertInput, TaskExpertUncheckedUpdateWithoutExpertInput>
  }

  export type TaskExpertUpdateManyWithWhereWithoutExpertInput = {
    where: TaskExpertScalarWhereInput
    data: XOR<TaskExpertUpdateManyMutationInput, TaskExpertUncheckedUpdateManyWithoutExpertInput>
  }

  export type TaskExpertScalarWhereInput = {
    AND?: TaskExpertScalarWhereInput | TaskExpertScalarWhereInput[]
    OR?: TaskExpertScalarWhereInput[]
    NOT?: TaskExpertScalarWhereInput | TaskExpertScalarWhereInput[]
    id?: StringFilter<"TaskExpert"> | string
    taskId?: StringFilter<"TaskExpert"> | string
    expertId?: StringFilter<"TaskExpert"> | string
    status?: StringFilter<"TaskExpert"> | string
    isCore?: BoolFilter<"TaskExpert"> | boolean
    invitedAt?: DateTimeFilter<"TaskExpert"> | Date | string
    respondedAt?: DateTimeNullableFilter<"TaskExpert"> | Date | string | null
  }

  export type TaskLogUpsertWithWhereUniqueWithoutOperatorInput = {
    where: TaskLogWhereUniqueInput
    update: XOR<TaskLogUpdateWithoutOperatorInput, TaskLogUncheckedUpdateWithoutOperatorInput>
    create: XOR<TaskLogCreateWithoutOperatorInput, TaskLogUncheckedCreateWithoutOperatorInput>
  }

  export type TaskLogUpdateWithWhereUniqueWithoutOperatorInput = {
    where: TaskLogWhereUniqueInput
    data: XOR<TaskLogUpdateWithoutOperatorInput, TaskLogUncheckedUpdateWithoutOperatorInput>
  }

  export type TaskLogUpdateManyWithWhereWithoutOperatorInput = {
    where: TaskLogScalarWhereInput
    data: XOR<TaskLogUpdateManyMutationInput, TaskLogUncheckedUpdateManyWithoutOperatorInput>
  }

  export type TaskLogScalarWhereInput = {
    AND?: TaskLogScalarWhereInput | TaskLogScalarWhereInput[]
    OR?: TaskLogScalarWhereInput[]
    NOT?: TaskLogScalarWhereInput | TaskLogScalarWhereInput[]
    id?: StringFilter<"TaskLog"> | string
    taskId?: StringFilter<"TaskLog"> | string
    operatorId?: StringNullableFilter<"TaskLog"> | string | null
    action?: StringFilter<"TaskLog"> | string
    details?: StringNullableFilter<"TaskLog"> | string | null
    createdAt?: DateTimeFilter<"TaskLog"> | Date | string
  }

  export type UserCreateWithoutExpertProfileInput = {
    id?: string
    username: string
    password: string
    realName: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expertTasks?: TaskExpertCreateNestedManyWithoutExpertInput
    logs?: TaskLogCreateNestedManyWithoutOperatorInput
  }

  export type UserUncheckedCreateWithoutExpertProfileInput = {
    id?: string
    username: string
    password: string
    realName: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expertTasks?: TaskExpertUncheckedCreateNestedManyWithoutExpertInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type UserCreateOrConnectWithoutExpertProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpertProfileInput, UserUncheckedCreateWithoutExpertProfileInput>
  }

  export type ExpertOpinionCreateWithoutExpertInput = {
    id?: string
    audioUrl?: string | null
    asrText?: string | null
    aiStructured?: string | null
    isAiAdopted?: boolean
    finalText?: string | null
    isSubmitted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    task: ConsultationTaskCreateNestedOneWithoutOpinionsInput
  }

  export type ExpertOpinionUncheckedCreateWithoutExpertInput = {
    id?: string
    taskId: string
    audioUrl?: string | null
    asrText?: string | null
    aiStructured?: string | null
    isAiAdopted?: boolean
    finalText?: string | null
    isSubmitted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpertOpinionCreateOrConnectWithoutExpertInput = {
    where: ExpertOpinionWhereUniqueInput
    create: XOR<ExpertOpinionCreateWithoutExpertInput, ExpertOpinionUncheckedCreateWithoutExpertInput>
  }

  export type ExpertOpinionCreateManyExpertInputEnvelope = {
    data: ExpertOpinionCreateManyExpertInput | ExpertOpinionCreateManyExpertInput[]
  }

  export type UserUpsertWithoutExpertProfileInput = {
    update: XOR<UserUpdateWithoutExpertProfileInput, UserUncheckedUpdateWithoutExpertProfileInput>
    create: XOR<UserCreateWithoutExpertProfileInput, UserUncheckedCreateWithoutExpertProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpertProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpertProfileInput, UserUncheckedUpdateWithoutExpertProfileInput>
  }

  export type UserUpdateWithoutExpertProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    realName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expertTasks?: TaskExpertUpdateManyWithoutExpertNestedInput
    logs?: TaskLogUpdateManyWithoutOperatorNestedInput
  }

  export type UserUncheckedUpdateWithoutExpertProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    realName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expertTasks?: TaskExpertUncheckedUpdateManyWithoutExpertNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type ExpertOpinionUpsertWithWhereUniqueWithoutExpertInput = {
    where: ExpertOpinionWhereUniqueInput
    update: XOR<ExpertOpinionUpdateWithoutExpertInput, ExpertOpinionUncheckedUpdateWithoutExpertInput>
    create: XOR<ExpertOpinionCreateWithoutExpertInput, ExpertOpinionUncheckedCreateWithoutExpertInput>
  }

  export type ExpertOpinionUpdateWithWhereUniqueWithoutExpertInput = {
    where: ExpertOpinionWhereUniqueInput
    data: XOR<ExpertOpinionUpdateWithoutExpertInput, ExpertOpinionUncheckedUpdateWithoutExpertInput>
  }

  export type ExpertOpinionUpdateManyWithWhereWithoutExpertInput = {
    where: ExpertOpinionScalarWhereInput
    data: XOR<ExpertOpinionUpdateManyMutationInput, ExpertOpinionUncheckedUpdateManyWithoutExpertInput>
  }

  export type ExpertOpinionScalarWhereInput = {
    AND?: ExpertOpinionScalarWhereInput | ExpertOpinionScalarWhereInput[]
    OR?: ExpertOpinionScalarWhereInput[]
    NOT?: ExpertOpinionScalarWhereInput | ExpertOpinionScalarWhereInput[]
    id?: StringFilter<"ExpertOpinion"> | string
    taskId?: StringFilter<"ExpertOpinion"> | string
    expertProfileId?: StringFilter<"ExpertOpinion"> | string
    audioUrl?: StringNullableFilter<"ExpertOpinion"> | string | null
    asrText?: StringNullableFilter<"ExpertOpinion"> | string | null
    aiStructured?: StringNullableFilter<"ExpertOpinion"> | string | null
    isAiAdopted?: BoolFilter<"ExpertOpinion"> | boolean
    finalText?: StringNullableFilter<"ExpertOpinion"> | string | null
    isSubmitted?: BoolFilter<"ExpertOpinion"> | boolean
    createdAt?: DateTimeFilter<"ExpertOpinion"> | Date | string
    updatedAt?: DateTimeFilter<"ExpertOpinion"> | Date | string
  }

  export type PreConsultationDocCreateWithoutTaskInput = {
    id?: string
    presentIllness: string
    pastHistory?: string | null
    familyHistory?: string | null
    extraInfo?: string | null
  }

  export type PreConsultationDocUncheckedCreateWithoutTaskInput = {
    id?: string
    presentIllness: string
    pastHistory?: string | null
    familyHistory?: string | null
    extraInfo?: string | null
  }

  export type PreConsultationDocCreateOrConnectWithoutTaskInput = {
    where: PreConsultationDocWhereUniqueInput
    create: XOR<PreConsultationDocCreateWithoutTaskInput, PreConsultationDocUncheckedCreateWithoutTaskInput>
  }

  export type ConsultationDialogCreateWithoutTaskInput = {
    id?: string
    role: string
    content: string
    original?: string | null
    startTime?: number | null
    createdAt?: Date | string
  }

  export type ConsultationDialogUncheckedCreateWithoutTaskInput = {
    id?: string
    role: string
    content: string
    original?: string | null
    startTime?: number | null
    createdAt?: Date | string
  }

  export type ConsultationDialogCreateOrConnectWithoutTaskInput = {
    where: ConsultationDialogWhereUniqueInput
    create: XOR<ConsultationDialogCreateWithoutTaskInput, ConsultationDialogUncheckedCreateWithoutTaskInput>
  }

  export type ConsultationDialogCreateManyTaskInputEnvelope = {
    data: ConsultationDialogCreateManyTaskInput | ConsultationDialogCreateManyTaskInput[]
  }

  export type PostConsultationDocCreateWithoutTaskInput = {
    id?: string
    aiContent?: string | null
    finalContent?: string | null
    isSubmitted?: boolean
    version?: number
    updatedAt?: Date | string
  }

  export type PostConsultationDocUncheckedCreateWithoutTaskInput = {
    id?: string
    aiContent?: string | null
    finalContent?: string | null
    isSubmitted?: boolean
    version?: number
    updatedAt?: Date | string
  }

  export type PostConsultationDocCreateOrConnectWithoutTaskInput = {
    where: PostConsultationDocWhereUniqueInput
    create: XOR<PostConsultationDocCreateWithoutTaskInput, PostConsultationDocUncheckedCreateWithoutTaskInput>
  }

  export type ExpertOpinionCreateWithoutTaskInput = {
    id?: string
    audioUrl?: string | null
    asrText?: string | null
    aiStructured?: string | null
    isAiAdopted?: boolean
    finalText?: string | null
    isSubmitted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    expert: ExpertProfileCreateNestedOneWithoutOpinionsInput
  }

  export type ExpertOpinionUncheckedCreateWithoutTaskInput = {
    id?: string
    expertProfileId: string
    audioUrl?: string | null
    asrText?: string | null
    aiStructured?: string | null
    isAiAdopted?: boolean
    finalText?: string | null
    isSubmitted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpertOpinionCreateOrConnectWithoutTaskInput = {
    where: ExpertOpinionWhereUniqueInput
    create: XOR<ExpertOpinionCreateWithoutTaskInput, ExpertOpinionUncheckedCreateWithoutTaskInput>
  }

  export type ExpertOpinionCreateManyTaskInputEnvelope = {
    data: ExpertOpinionCreateManyTaskInput | ExpertOpinionCreateManyTaskInput[]
  }

  export type ConsultationReportCreateWithoutTaskInput = {
    id?: string
    aiSummary?: string | null
    finalSummary: string
    aiEducation?: string | null
    finalEducation: string
    pdfUrl?: string | null
    isSigned?: boolean
    completedAt?: Date | string
  }

  export type ConsultationReportUncheckedCreateWithoutTaskInput = {
    id?: string
    aiSummary?: string | null
    finalSummary: string
    aiEducation?: string | null
    finalEducation: string
    pdfUrl?: string | null
    isSigned?: boolean
    completedAt?: Date | string
  }

  export type ConsultationReportCreateOrConnectWithoutTaskInput = {
    where: ConsultationReportWhereUniqueInput
    create: XOR<ConsultationReportCreateWithoutTaskInput, ConsultationReportUncheckedCreateWithoutTaskInput>
  }

  export type TaskExpertCreateWithoutTaskInput = {
    id?: string
    status?: string
    isCore?: boolean
    invitedAt?: Date | string
    respondedAt?: Date | string | null
    expert: UserCreateNestedOneWithoutExpertTasksInput
  }

  export type TaskExpertUncheckedCreateWithoutTaskInput = {
    id?: string
    expertId: string
    status?: string
    isCore?: boolean
    invitedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type TaskExpertCreateOrConnectWithoutTaskInput = {
    where: TaskExpertWhereUniqueInput
    create: XOR<TaskExpertCreateWithoutTaskInput, TaskExpertUncheckedCreateWithoutTaskInput>
  }

  export type TaskExpertCreateManyTaskInputEnvelope = {
    data: TaskExpertCreateManyTaskInput | TaskExpertCreateManyTaskInput[]
  }

  export type TaskLogCreateWithoutTaskInput = {
    id?: string
    action: string
    details?: string | null
    createdAt?: Date | string
    operator?: UserCreateNestedOneWithoutLogsInput
  }

  export type TaskLogUncheckedCreateWithoutTaskInput = {
    id?: string
    operatorId?: string | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type TaskLogCreateOrConnectWithoutTaskInput = {
    where: TaskLogWhereUniqueInput
    create: XOR<TaskLogCreateWithoutTaskInput, TaskLogUncheckedCreateWithoutTaskInput>
  }

  export type TaskLogCreateManyTaskInputEnvelope = {
    data: TaskLogCreateManyTaskInput | TaskLogCreateManyTaskInput[]
  }

  export type PreConsultationDocUpsertWithoutTaskInput = {
    update: XOR<PreConsultationDocUpdateWithoutTaskInput, PreConsultationDocUncheckedUpdateWithoutTaskInput>
    create: XOR<PreConsultationDocCreateWithoutTaskInput, PreConsultationDocUncheckedCreateWithoutTaskInput>
    where?: PreConsultationDocWhereInput
  }

  export type PreConsultationDocUpdateToOneWithWhereWithoutTaskInput = {
    where?: PreConsultationDocWhereInput
    data: XOR<PreConsultationDocUpdateWithoutTaskInput, PreConsultationDocUncheckedUpdateWithoutTaskInput>
  }

  export type PreConsultationDocUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    presentIllness?: StringFieldUpdateOperationsInput | string
    pastHistory?: NullableStringFieldUpdateOperationsInput | string | null
    familyHistory?: NullableStringFieldUpdateOperationsInput | string | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PreConsultationDocUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    presentIllness?: StringFieldUpdateOperationsInput | string
    pastHistory?: NullableStringFieldUpdateOperationsInput | string | null
    familyHistory?: NullableStringFieldUpdateOperationsInput | string | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConsultationDialogUpsertWithWhereUniqueWithoutTaskInput = {
    where: ConsultationDialogWhereUniqueInput
    update: XOR<ConsultationDialogUpdateWithoutTaskInput, ConsultationDialogUncheckedUpdateWithoutTaskInput>
    create: XOR<ConsultationDialogCreateWithoutTaskInput, ConsultationDialogUncheckedCreateWithoutTaskInput>
  }

  export type ConsultationDialogUpdateWithWhereUniqueWithoutTaskInput = {
    where: ConsultationDialogWhereUniqueInput
    data: XOR<ConsultationDialogUpdateWithoutTaskInput, ConsultationDialogUncheckedUpdateWithoutTaskInput>
  }

  export type ConsultationDialogUpdateManyWithWhereWithoutTaskInput = {
    where: ConsultationDialogScalarWhereInput
    data: XOR<ConsultationDialogUpdateManyMutationInput, ConsultationDialogUncheckedUpdateManyWithoutTaskInput>
  }

  export type ConsultationDialogScalarWhereInput = {
    AND?: ConsultationDialogScalarWhereInput | ConsultationDialogScalarWhereInput[]
    OR?: ConsultationDialogScalarWhereInput[]
    NOT?: ConsultationDialogScalarWhereInput | ConsultationDialogScalarWhereInput[]
    id?: StringFilter<"ConsultationDialog"> | string
    taskId?: StringFilter<"ConsultationDialog"> | string
    role?: StringFilter<"ConsultationDialog"> | string
    content?: StringFilter<"ConsultationDialog"> | string
    original?: StringNullableFilter<"ConsultationDialog"> | string | null
    startTime?: FloatNullableFilter<"ConsultationDialog"> | number | null
    createdAt?: DateTimeFilter<"ConsultationDialog"> | Date | string
  }

  export type PostConsultationDocUpsertWithoutTaskInput = {
    update: XOR<PostConsultationDocUpdateWithoutTaskInput, PostConsultationDocUncheckedUpdateWithoutTaskInput>
    create: XOR<PostConsultationDocCreateWithoutTaskInput, PostConsultationDocUncheckedCreateWithoutTaskInput>
    where?: PostConsultationDocWhereInput
  }

  export type PostConsultationDocUpdateToOneWithWhereWithoutTaskInput = {
    where?: PostConsultationDocWhereInput
    data: XOR<PostConsultationDocUpdateWithoutTaskInput, PostConsultationDocUncheckedUpdateWithoutTaskInput>
  }

  export type PostConsultationDocUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiContent?: NullableStringFieldUpdateOperationsInput | string | null
    finalContent?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostConsultationDocUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiContent?: NullableStringFieldUpdateOperationsInput | string | null
    finalContent?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpertOpinionUpsertWithWhereUniqueWithoutTaskInput = {
    where: ExpertOpinionWhereUniqueInput
    update: XOR<ExpertOpinionUpdateWithoutTaskInput, ExpertOpinionUncheckedUpdateWithoutTaskInput>
    create: XOR<ExpertOpinionCreateWithoutTaskInput, ExpertOpinionUncheckedCreateWithoutTaskInput>
  }

  export type ExpertOpinionUpdateWithWhereUniqueWithoutTaskInput = {
    where: ExpertOpinionWhereUniqueInput
    data: XOR<ExpertOpinionUpdateWithoutTaskInput, ExpertOpinionUncheckedUpdateWithoutTaskInput>
  }

  export type ExpertOpinionUpdateManyWithWhereWithoutTaskInput = {
    where: ExpertOpinionScalarWhereInput
    data: XOR<ExpertOpinionUpdateManyMutationInput, ExpertOpinionUncheckedUpdateManyWithoutTaskInput>
  }

  export type ConsultationReportUpsertWithoutTaskInput = {
    update: XOR<ConsultationReportUpdateWithoutTaskInput, ConsultationReportUncheckedUpdateWithoutTaskInput>
    create: XOR<ConsultationReportCreateWithoutTaskInput, ConsultationReportUncheckedCreateWithoutTaskInput>
    where?: ConsultationReportWhereInput
  }

  export type ConsultationReportUpdateToOneWithWhereWithoutTaskInput = {
    where?: ConsultationReportWhereInput
    data: XOR<ConsultationReportUpdateWithoutTaskInput, ConsultationReportUncheckedUpdateWithoutTaskInput>
  }

  export type ConsultationReportUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    finalSummary?: StringFieldUpdateOperationsInput | string
    aiEducation?: NullableStringFieldUpdateOperationsInput | string | null
    finalEducation?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationReportUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    finalSummary?: StringFieldUpdateOperationsInput | string
    aiEducation?: NullableStringFieldUpdateOperationsInput | string | null
    finalEducation?: StringFieldUpdateOperationsInput | string
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSigned?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskExpertUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskExpertWhereUniqueInput
    update: XOR<TaskExpertUpdateWithoutTaskInput, TaskExpertUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskExpertCreateWithoutTaskInput, TaskExpertUncheckedCreateWithoutTaskInput>
  }

  export type TaskExpertUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskExpertWhereUniqueInput
    data: XOR<TaskExpertUpdateWithoutTaskInput, TaskExpertUncheckedUpdateWithoutTaskInput>
  }

  export type TaskExpertUpdateManyWithWhereWithoutTaskInput = {
    where: TaskExpertScalarWhereInput
    data: XOR<TaskExpertUpdateManyMutationInput, TaskExpertUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskLogUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskLogWhereUniqueInput
    update: XOR<TaskLogUpdateWithoutTaskInput, TaskLogUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskLogCreateWithoutTaskInput, TaskLogUncheckedCreateWithoutTaskInput>
  }

  export type TaskLogUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskLogWhereUniqueInput
    data: XOR<TaskLogUpdateWithoutTaskInput, TaskLogUncheckedUpdateWithoutTaskInput>
  }

  export type TaskLogUpdateManyWithWhereWithoutTaskInput = {
    where: TaskLogScalarWhereInput
    data: XOR<TaskLogUpdateManyMutationInput, TaskLogUncheckedUpdateManyWithoutTaskInput>
  }

  export type ConsultationTaskCreateWithoutExpertsInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preDoc?: PreConsultationDocCreateNestedOneWithoutTaskInput
    dialogs?: ConsultationDialogCreateNestedManyWithoutTaskInput
    postDoc?: PostConsultationDocCreateNestedOneWithoutTaskInput
    opinions?: ExpertOpinionCreateNestedManyWithoutTaskInput
    report?: ConsultationReportCreateNestedOneWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
  }

  export type ConsultationTaskUncheckedCreateWithoutExpertsInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preDoc?: PreConsultationDocUncheckedCreateNestedOneWithoutTaskInput
    dialogs?: ConsultationDialogUncheckedCreateNestedManyWithoutTaskInput
    postDoc?: PostConsultationDocUncheckedCreateNestedOneWithoutTaskInput
    opinions?: ExpertOpinionUncheckedCreateNestedManyWithoutTaskInput
    report?: ConsultationReportUncheckedCreateNestedOneWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type ConsultationTaskCreateOrConnectWithoutExpertsInput = {
    where: ConsultationTaskWhereUniqueInput
    create: XOR<ConsultationTaskCreateWithoutExpertsInput, ConsultationTaskUncheckedCreateWithoutExpertsInput>
  }

  export type UserCreateWithoutExpertTasksInput = {
    id?: string
    username: string
    password: string
    realName: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expertProfile?: ExpertProfileCreateNestedOneWithoutUserInput
    logs?: TaskLogCreateNestedManyWithoutOperatorInput
  }

  export type UserUncheckedCreateWithoutExpertTasksInput = {
    id?: string
    username: string
    password: string
    realName: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expertProfile?: ExpertProfileUncheckedCreateNestedOneWithoutUserInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type UserCreateOrConnectWithoutExpertTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpertTasksInput, UserUncheckedCreateWithoutExpertTasksInput>
  }

  export type ConsultationTaskUpsertWithoutExpertsInput = {
    update: XOR<ConsultationTaskUpdateWithoutExpertsInput, ConsultationTaskUncheckedUpdateWithoutExpertsInput>
    create: XOR<ConsultationTaskCreateWithoutExpertsInput, ConsultationTaskUncheckedCreateWithoutExpertsInput>
    where?: ConsultationTaskWhereInput
  }

  export type ConsultationTaskUpdateToOneWithWhereWithoutExpertsInput = {
    where?: ConsultationTaskWhereInput
    data: XOR<ConsultationTaskUpdateWithoutExpertsInput, ConsultationTaskUncheckedUpdateWithoutExpertsInput>
  }

  export type ConsultationTaskUpdateWithoutExpertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preDoc?: PreConsultationDocUpdateOneWithoutTaskNestedInput
    dialogs?: ConsultationDialogUpdateManyWithoutTaskNestedInput
    postDoc?: PostConsultationDocUpdateOneWithoutTaskNestedInput
    opinions?: ExpertOpinionUpdateManyWithoutTaskNestedInput
    report?: ConsultationReportUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
  }

  export type ConsultationTaskUncheckedUpdateWithoutExpertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preDoc?: PreConsultationDocUncheckedUpdateOneWithoutTaskNestedInput
    dialogs?: ConsultationDialogUncheckedUpdateManyWithoutTaskNestedInput
    postDoc?: PostConsultationDocUncheckedUpdateOneWithoutTaskNestedInput
    opinions?: ExpertOpinionUncheckedUpdateManyWithoutTaskNestedInput
    report?: ConsultationReportUncheckedUpdateOneWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutExpertTasksInput = {
    update: XOR<UserUpdateWithoutExpertTasksInput, UserUncheckedUpdateWithoutExpertTasksInput>
    create: XOR<UserCreateWithoutExpertTasksInput, UserUncheckedCreateWithoutExpertTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpertTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpertTasksInput, UserUncheckedUpdateWithoutExpertTasksInput>
  }

  export type UserUpdateWithoutExpertTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    realName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expertProfile?: ExpertProfileUpdateOneWithoutUserNestedInput
    logs?: TaskLogUpdateManyWithoutOperatorNestedInput
  }

  export type UserUncheckedUpdateWithoutExpertTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    realName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expertProfile?: ExpertProfileUncheckedUpdateOneWithoutUserNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type ConsultationTaskCreateWithoutPreDocInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dialogs?: ConsultationDialogCreateNestedManyWithoutTaskInput
    postDoc?: PostConsultationDocCreateNestedOneWithoutTaskInput
    opinions?: ExpertOpinionCreateNestedManyWithoutTaskInput
    report?: ConsultationReportCreateNestedOneWithoutTaskInput
    experts?: TaskExpertCreateNestedManyWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
  }

  export type ConsultationTaskUncheckedCreateWithoutPreDocInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
    dialogs?: ConsultationDialogUncheckedCreateNestedManyWithoutTaskInput
    postDoc?: PostConsultationDocUncheckedCreateNestedOneWithoutTaskInput
    opinions?: ExpertOpinionUncheckedCreateNestedManyWithoutTaskInput
    report?: ConsultationReportUncheckedCreateNestedOneWithoutTaskInput
    experts?: TaskExpertUncheckedCreateNestedManyWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type ConsultationTaskCreateOrConnectWithoutPreDocInput = {
    where: ConsultationTaskWhereUniqueInput
    create: XOR<ConsultationTaskCreateWithoutPreDocInput, ConsultationTaskUncheckedCreateWithoutPreDocInput>
  }

  export type ConsultationTaskUpsertWithoutPreDocInput = {
    update: XOR<ConsultationTaskUpdateWithoutPreDocInput, ConsultationTaskUncheckedUpdateWithoutPreDocInput>
    create: XOR<ConsultationTaskCreateWithoutPreDocInput, ConsultationTaskUncheckedCreateWithoutPreDocInput>
    where?: ConsultationTaskWhereInput
  }

  export type ConsultationTaskUpdateToOneWithWhereWithoutPreDocInput = {
    where?: ConsultationTaskWhereInput
    data: XOR<ConsultationTaskUpdateWithoutPreDocInput, ConsultationTaskUncheckedUpdateWithoutPreDocInput>
  }

  export type ConsultationTaskUpdateWithoutPreDocInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dialogs?: ConsultationDialogUpdateManyWithoutTaskNestedInput
    postDoc?: PostConsultationDocUpdateOneWithoutTaskNestedInput
    opinions?: ExpertOpinionUpdateManyWithoutTaskNestedInput
    report?: ConsultationReportUpdateOneWithoutTaskNestedInput
    experts?: TaskExpertUpdateManyWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
  }

  export type ConsultationTaskUncheckedUpdateWithoutPreDocInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dialogs?: ConsultationDialogUncheckedUpdateManyWithoutTaskNestedInput
    postDoc?: PostConsultationDocUncheckedUpdateOneWithoutTaskNestedInput
    opinions?: ExpertOpinionUncheckedUpdateManyWithoutTaskNestedInput
    report?: ConsultationReportUncheckedUpdateOneWithoutTaskNestedInput
    experts?: TaskExpertUncheckedUpdateManyWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type ConsultationTaskCreateWithoutDialogsInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preDoc?: PreConsultationDocCreateNestedOneWithoutTaskInput
    postDoc?: PostConsultationDocCreateNestedOneWithoutTaskInput
    opinions?: ExpertOpinionCreateNestedManyWithoutTaskInput
    report?: ConsultationReportCreateNestedOneWithoutTaskInput
    experts?: TaskExpertCreateNestedManyWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
  }

  export type ConsultationTaskUncheckedCreateWithoutDialogsInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preDoc?: PreConsultationDocUncheckedCreateNestedOneWithoutTaskInput
    postDoc?: PostConsultationDocUncheckedCreateNestedOneWithoutTaskInput
    opinions?: ExpertOpinionUncheckedCreateNestedManyWithoutTaskInput
    report?: ConsultationReportUncheckedCreateNestedOneWithoutTaskInput
    experts?: TaskExpertUncheckedCreateNestedManyWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type ConsultationTaskCreateOrConnectWithoutDialogsInput = {
    where: ConsultationTaskWhereUniqueInput
    create: XOR<ConsultationTaskCreateWithoutDialogsInput, ConsultationTaskUncheckedCreateWithoutDialogsInput>
  }

  export type ConsultationTaskUpsertWithoutDialogsInput = {
    update: XOR<ConsultationTaskUpdateWithoutDialogsInput, ConsultationTaskUncheckedUpdateWithoutDialogsInput>
    create: XOR<ConsultationTaskCreateWithoutDialogsInput, ConsultationTaskUncheckedCreateWithoutDialogsInput>
    where?: ConsultationTaskWhereInput
  }

  export type ConsultationTaskUpdateToOneWithWhereWithoutDialogsInput = {
    where?: ConsultationTaskWhereInput
    data: XOR<ConsultationTaskUpdateWithoutDialogsInput, ConsultationTaskUncheckedUpdateWithoutDialogsInput>
  }

  export type ConsultationTaskUpdateWithoutDialogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preDoc?: PreConsultationDocUpdateOneWithoutTaskNestedInput
    postDoc?: PostConsultationDocUpdateOneWithoutTaskNestedInput
    opinions?: ExpertOpinionUpdateManyWithoutTaskNestedInput
    report?: ConsultationReportUpdateOneWithoutTaskNestedInput
    experts?: TaskExpertUpdateManyWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
  }

  export type ConsultationTaskUncheckedUpdateWithoutDialogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preDoc?: PreConsultationDocUncheckedUpdateOneWithoutTaskNestedInput
    postDoc?: PostConsultationDocUncheckedUpdateOneWithoutTaskNestedInput
    opinions?: ExpertOpinionUncheckedUpdateManyWithoutTaskNestedInput
    report?: ConsultationReportUncheckedUpdateOneWithoutTaskNestedInput
    experts?: TaskExpertUncheckedUpdateManyWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type ConsultationTaskCreateWithoutPostDocInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preDoc?: PreConsultationDocCreateNestedOneWithoutTaskInput
    dialogs?: ConsultationDialogCreateNestedManyWithoutTaskInput
    opinions?: ExpertOpinionCreateNestedManyWithoutTaskInput
    report?: ConsultationReportCreateNestedOneWithoutTaskInput
    experts?: TaskExpertCreateNestedManyWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
  }

  export type ConsultationTaskUncheckedCreateWithoutPostDocInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preDoc?: PreConsultationDocUncheckedCreateNestedOneWithoutTaskInput
    dialogs?: ConsultationDialogUncheckedCreateNestedManyWithoutTaskInput
    opinions?: ExpertOpinionUncheckedCreateNestedManyWithoutTaskInput
    report?: ConsultationReportUncheckedCreateNestedOneWithoutTaskInput
    experts?: TaskExpertUncheckedCreateNestedManyWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type ConsultationTaskCreateOrConnectWithoutPostDocInput = {
    where: ConsultationTaskWhereUniqueInput
    create: XOR<ConsultationTaskCreateWithoutPostDocInput, ConsultationTaskUncheckedCreateWithoutPostDocInput>
  }

  export type ConsultationTaskUpsertWithoutPostDocInput = {
    update: XOR<ConsultationTaskUpdateWithoutPostDocInput, ConsultationTaskUncheckedUpdateWithoutPostDocInput>
    create: XOR<ConsultationTaskCreateWithoutPostDocInput, ConsultationTaskUncheckedCreateWithoutPostDocInput>
    where?: ConsultationTaskWhereInput
  }

  export type ConsultationTaskUpdateToOneWithWhereWithoutPostDocInput = {
    where?: ConsultationTaskWhereInput
    data: XOR<ConsultationTaskUpdateWithoutPostDocInput, ConsultationTaskUncheckedUpdateWithoutPostDocInput>
  }

  export type ConsultationTaskUpdateWithoutPostDocInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preDoc?: PreConsultationDocUpdateOneWithoutTaskNestedInput
    dialogs?: ConsultationDialogUpdateManyWithoutTaskNestedInput
    opinions?: ExpertOpinionUpdateManyWithoutTaskNestedInput
    report?: ConsultationReportUpdateOneWithoutTaskNestedInput
    experts?: TaskExpertUpdateManyWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
  }

  export type ConsultationTaskUncheckedUpdateWithoutPostDocInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preDoc?: PreConsultationDocUncheckedUpdateOneWithoutTaskNestedInput
    dialogs?: ConsultationDialogUncheckedUpdateManyWithoutTaskNestedInput
    opinions?: ExpertOpinionUncheckedUpdateManyWithoutTaskNestedInput
    report?: ConsultationReportUncheckedUpdateOneWithoutTaskNestedInput
    experts?: TaskExpertUncheckedUpdateManyWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type ConsultationTaskCreateWithoutOpinionsInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preDoc?: PreConsultationDocCreateNestedOneWithoutTaskInput
    dialogs?: ConsultationDialogCreateNestedManyWithoutTaskInput
    postDoc?: PostConsultationDocCreateNestedOneWithoutTaskInput
    report?: ConsultationReportCreateNestedOneWithoutTaskInput
    experts?: TaskExpertCreateNestedManyWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
  }

  export type ConsultationTaskUncheckedCreateWithoutOpinionsInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preDoc?: PreConsultationDocUncheckedCreateNestedOneWithoutTaskInput
    dialogs?: ConsultationDialogUncheckedCreateNestedManyWithoutTaskInput
    postDoc?: PostConsultationDocUncheckedCreateNestedOneWithoutTaskInput
    report?: ConsultationReportUncheckedCreateNestedOneWithoutTaskInput
    experts?: TaskExpertUncheckedCreateNestedManyWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type ConsultationTaskCreateOrConnectWithoutOpinionsInput = {
    where: ConsultationTaskWhereUniqueInput
    create: XOR<ConsultationTaskCreateWithoutOpinionsInput, ConsultationTaskUncheckedCreateWithoutOpinionsInput>
  }

  export type ExpertProfileCreateWithoutOpinionsInput = {
    id?: string
    department: string
    titles: string
    signatureUrl?: string | null
    user: UserCreateNestedOneWithoutExpertProfileInput
  }

  export type ExpertProfileUncheckedCreateWithoutOpinionsInput = {
    id?: string
    userId: string
    department: string
    titles: string
    signatureUrl?: string | null
  }

  export type ExpertProfileCreateOrConnectWithoutOpinionsInput = {
    where: ExpertProfileWhereUniqueInput
    create: XOR<ExpertProfileCreateWithoutOpinionsInput, ExpertProfileUncheckedCreateWithoutOpinionsInput>
  }

  export type ConsultationTaskUpsertWithoutOpinionsInput = {
    update: XOR<ConsultationTaskUpdateWithoutOpinionsInput, ConsultationTaskUncheckedUpdateWithoutOpinionsInput>
    create: XOR<ConsultationTaskCreateWithoutOpinionsInput, ConsultationTaskUncheckedCreateWithoutOpinionsInput>
    where?: ConsultationTaskWhereInput
  }

  export type ConsultationTaskUpdateToOneWithWhereWithoutOpinionsInput = {
    where?: ConsultationTaskWhereInput
    data: XOR<ConsultationTaskUpdateWithoutOpinionsInput, ConsultationTaskUncheckedUpdateWithoutOpinionsInput>
  }

  export type ConsultationTaskUpdateWithoutOpinionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preDoc?: PreConsultationDocUpdateOneWithoutTaskNestedInput
    dialogs?: ConsultationDialogUpdateManyWithoutTaskNestedInput
    postDoc?: PostConsultationDocUpdateOneWithoutTaskNestedInput
    report?: ConsultationReportUpdateOneWithoutTaskNestedInput
    experts?: TaskExpertUpdateManyWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
  }

  export type ConsultationTaskUncheckedUpdateWithoutOpinionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preDoc?: PreConsultationDocUncheckedUpdateOneWithoutTaskNestedInput
    dialogs?: ConsultationDialogUncheckedUpdateManyWithoutTaskNestedInput
    postDoc?: PostConsultationDocUncheckedUpdateOneWithoutTaskNestedInput
    report?: ConsultationReportUncheckedUpdateOneWithoutTaskNestedInput
    experts?: TaskExpertUncheckedUpdateManyWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type ExpertProfileUpsertWithoutOpinionsInput = {
    update: XOR<ExpertProfileUpdateWithoutOpinionsInput, ExpertProfileUncheckedUpdateWithoutOpinionsInput>
    create: XOR<ExpertProfileCreateWithoutOpinionsInput, ExpertProfileUncheckedCreateWithoutOpinionsInput>
    where?: ExpertProfileWhereInput
  }

  export type ExpertProfileUpdateToOneWithWhereWithoutOpinionsInput = {
    where?: ExpertProfileWhereInput
    data: XOR<ExpertProfileUpdateWithoutOpinionsInput, ExpertProfileUncheckedUpdateWithoutOpinionsInput>
  }

  export type ExpertProfileUpdateWithoutOpinionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    titles?: StringFieldUpdateOperationsInput | string
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutExpertProfileNestedInput
  }

  export type ExpertProfileUncheckedUpdateWithoutOpinionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    titles?: StringFieldUpdateOperationsInput | string
    signatureUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConsultationTaskCreateWithoutReportInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preDoc?: PreConsultationDocCreateNestedOneWithoutTaskInput
    dialogs?: ConsultationDialogCreateNestedManyWithoutTaskInput
    postDoc?: PostConsultationDocCreateNestedOneWithoutTaskInput
    opinions?: ExpertOpinionCreateNestedManyWithoutTaskInput
    experts?: TaskExpertCreateNestedManyWithoutTaskInput
    logs?: TaskLogCreateNestedManyWithoutTaskInput
  }

  export type ConsultationTaskUncheckedCreateWithoutReportInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preDoc?: PreConsultationDocUncheckedCreateNestedOneWithoutTaskInput
    dialogs?: ConsultationDialogUncheckedCreateNestedManyWithoutTaskInput
    postDoc?: PostConsultationDocUncheckedCreateNestedOneWithoutTaskInput
    opinions?: ExpertOpinionUncheckedCreateNestedManyWithoutTaskInput
    experts?: TaskExpertUncheckedCreateNestedManyWithoutTaskInput
    logs?: TaskLogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type ConsultationTaskCreateOrConnectWithoutReportInput = {
    where: ConsultationTaskWhereUniqueInput
    create: XOR<ConsultationTaskCreateWithoutReportInput, ConsultationTaskUncheckedCreateWithoutReportInput>
  }

  export type ConsultationTaskUpsertWithoutReportInput = {
    update: XOR<ConsultationTaskUpdateWithoutReportInput, ConsultationTaskUncheckedUpdateWithoutReportInput>
    create: XOR<ConsultationTaskCreateWithoutReportInput, ConsultationTaskUncheckedCreateWithoutReportInput>
    where?: ConsultationTaskWhereInput
  }

  export type ConsultationTaskUpdateToOneWithWhereWithoutReportInput = {
    where?: ConsultationTaskWhereInput
    data: XOR<ConsultationTaskUpdateWithoutReportInput, ConsultationTaskUncheckedUpdateWithoutReportInput>
  }

  export type ConsultationTaskUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preDoc?: PreConsultationDocUpdateOneWithoutTaskNestedInput
    dialogs?: ConsultationDialogUpdateManyWithoutTaskNestedInput
    postDoc?: PostConsultationDocUpdateOneWithoutTaskNestedInput
    opinions?: ExpertOpinionUpdateManyWithoutTaskNestedInput
    experts?: TaskExpertUpdateManyWithoutTaskNestedInput
    logs?: TaskLogUpdateManyWithoutTaskNestedInput
  }

  export type ConsultationTaskUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preDoc?: PreConsultationDocUncheckedUpdateOneWithoutTaskNestedInput
    dialogs?: ConsultationDialogUncheckedUpdateManyWithoutTaskNestedInput
    postDoc?: PostConsultationDocUncheckedUpdateOneWithoutTaskNestedInput
    opinions?: ExpertOpinionUncheckedUpdateManyWithoutTaskNestedInput
    experts?: TaskExpertUncheckedUpdateManyWithoutTaskNestedInput
    logs?: TaskLogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type ConsultationTaskCreateWithoutLogsInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preDoc?: PreConsultationDocCreateNestedOneWithoutTaskInput
    dialogs?: ConsultationDialogCreateNestedManyWithoutTaskInput
    postDoc?: PostConsultationDocCreateNestedOneWithoutTaskInput
    opinions?: ExpertOpinionCreateNestedManyWithoutTaskInput
    report?: ConsultationReportCreateNestedOneWithoutTaskInput
    experts?: TaskExpertCreateNestedManyWithoutTaskInput
  }

  export type ConsultationTaskUncheckedCreateWithoutLogsInput = {
    id?: string
    status?: string
    scheduledTime: Date | string
    patientName: string
    patientGender: string
    patientAge: number
    chiefComplaint: string
    createdAt?: Date | string
    updatedAt?: Date | string
    preDoc?: PreConsultationDocUncheckedCreateNestedOneWithoutTaskInput
    dialogs?: ConsultationDialogUncheckedCreateNestedManyWithoutTaskInput
    postDoc?: PostConsultationDocUncheckedCreateNestedOneWithoutTaskInput
    opinions?: ExpertOpinionUncheckedCreateNestedManyWithoutTaskInput
    report?: ConsultationReportUncheckedCreateNestedOneWithoutTaskInput
    experts?: TaskExpertUncheckedCreateNestedManyWithoutTaskInput
  }

  export type ConsultationTaskCreateOrConnectWithoutLogsInput = {
    where: ConsultationTaskWhereUniqueInput
    create: XOR<ConsultationTaskCreateWithoutLogsInput, ConsultationTaskUncheckedCreateWithoutLogsInput>
  }

  export type UserCreateWithoutLogsInput = {
    id?: string
    username: string
    password: string
    realName: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expertProfile?: ExpertProfileCreateNestedOneWithoutUserInput
    expertTasks?: TaskExpertCreateNestedManyWithoutExpertInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: string
    username: string
    password: string
    realName: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expertProfile?: ExpertProfileUncheckedCreateNestedOneWithoutUserInput
    expertTasks?: TaskExpertUncheckedCreateNestedManyWithoutExpertInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type ConsultationTaskUpsertWithoutLogsInput = {
    update: XOR<ConsultationTaskUpdateWithoutLogsInput, ConsultationTaskUncheckedUpdateWithoutLogsInput>
    create: XOR<ConsultationTaskCreateWithoutLogsInput, ConsultationTaskUncheckedCreateWithoutLogsInput>
    where?: ConsultationTaskWhereInput
  }

  export type ConsultationTaskUpdateToOneWithWhereWithoutLogsInput = {
    where?: ConsultationTaskWhereInput
    data: XOR<ConsultationTaskUpdateWithoutLogsInput, ConsultationTaskUncheckedUpdateWithoutLogsInput>
  }

  export type ConsultationTaskUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preDoc?: PreConsultationDocUpdateOneWithoutTaskNestedInput
    dialogs?: ConsultationDialogUpdateManyWithoutTaskNestedInput
    postDoc?: PostConsultationDocUpdateOneWithoutTaskNestedInput
    opinions?: ExpertOpinionUpdateManyWithoutTaskNestedInput
    report?: ConsultationReportUpdateOneWithoutTaskNestedInput
    experts?: TaskExpertUpdateManyWithoutTaskNestedInput
  }

  export type ConsultationTaskUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    patientName?: StringFieldUpdateOperationsInput | string
    patientGender?: StringFieldUpdateOperationsInput | string
    patientAge?: IntFieldUpdateOperationsInput | number
    chiefComplaint?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preDoc?: PreConsultationDocUncheckedUpdateOneWithoutTaskNestedInput
    dialogs?: ConsultationDialogUncheckedUpdateManyWithoutTaskNestedInput
    postDoc?: PostConsultationDocUncheckedUpdateOneWithoutTaskNestedInput
    opinions?: ExpertOpinionUncheckedUpdateManyWithoutTaskNestedInput
    report?: ConsultationReportUncheckedUpdateOneWithoutTaskNestedInput
    experts?: TaskExpertUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    realName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expertProfile?: ExpertProfileUpdateOneWithoutUserNestedInput
    expertTasks?: TaskExpertUpdateManyWithoutExpertNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    realName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expertProfile?: ExpertProfileUncheckedUpdateOneWithoutUserNestedInput
    expertTasks?: TaskExpertUncheckedUpdateManyWithoutExpertNestedInput
  }

  export type TaskExpertCreateManyExpertInput = {
    id?: string
    taskId: string
    status?: string
    isCore?: boolean
    invitedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type TaskLogCreateManyOperatorInput = {
    id?: string
    taskId: string
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type TaskExpertUpdateWithoutExpertInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task?: ConsultationTaskUpdateOneRequiredWithoutExpertsNestedInput
  }

  export type TaskExpertUncheckedUpdateWithoutExpertInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskExpertUncheckedUpdateManyWithoutExpertInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskLogUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: ConsultationTaskUpdateOneRequiredWithoutLogsNestedInput
  }

  export type TaskLogUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLogUncheckedUpdateManyWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpertOpinionCreateManyExpertInput = {
    id?: string
    taskId: string
    audioUrl?: string | null
    asrText?: string | null
    aiStructured?: string | null
    isAiAdopted?: boolean
    finalText?: string | null
    isSubmitted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpertOpinionUpdateWithoutExpertInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    aiStructured?: NullableStringFieldUpdateOperationsInput | string | null
    isAiAdopted?: BoolFieldUpdateOperationsInput | boolean
    finalText?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: ConsultationTaskUpdateOneRequiredWithoutOpinionsNestedInput
  }

  export type ExpertOpinionUncheckedUpdateWithoutExpertInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    aiStructured?: NullableStringFieldUpdateOperationsInput | string | null
    isAiAdopted?: BoolFieldUpdateOperationsInput | boolean
    finalText?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpertOpinionUncheckedUpdateManyWithoutExpertInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    aiStructured?: NullableStringFieldUpdateOperationsInput | string | null
    isAiAdopted?: BoolFieldUpdateOperationsInput | boolean
    finalText?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationDialogCreateManyTaskInput = {
    id?: string
    role: string
    content: string
    original?: string | null
    startTime?: number | null
    createdAt?: Date | string
  }

  export type ExpertOpinionCreateManyTaskInput = {
    id?: string
    expertProfileId: string
    audioUrl?: string | null
    asrText?: string | null
    aiStructured?: string | null
    isAiAdopted?: boolean
    finalText?: string | null
    isSubmitted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskExpertCreateManyTaskInput = {
    id?: string
    expertId: string
    status?: string
    isCore?: boolean
    invitedAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type TaskLogCreateManyTaskInput = {
    id?: string
    operatorId?: string | null
    action: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ConsultationDialogUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    original?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationDialogUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    original?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationDialogUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    original?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpertOpinionUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    aiStructured?: NullableStringFieldUpdateOperationsInput | string | null
    isAiAdopted?: BoolFieldUpdateOperationsInput | boolean
    finalText?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expert?: ExpertProfileUpdateOneRequiredWithoutOpinionsNestedInput
  }

  export type ExpertOpinionUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertProfileId?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    aiStructured?: NullableStringFieldUpdateOperationsInput | string | null
    isAiAdopted?: BoolFieldUpdateOperationsInput | boolean
    finalText?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpertOpinionUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertProfileId?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    asrText?: NullableStringFieldUpdateOperationsInput | string | null
    aiStructured?: NullableStringFieldUpdateOperationsInput | string | null
    isAiAdopted?: BoolFieldUpdateOperationsInput | boolean
    finalText?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskExpertUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expert?: UserUpdateOneRequiredWithoutExpertTasksNestedInput
  }

  export type TaskExpertUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskExpertUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isCore?: BoolFieldUpdateOperationsInput | boolean
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskLogUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operator?: UserUpdateOneWithoutLogsNestedInput
  }

  export type TaskLogUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskLogUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    operatorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpertProfileCountOutputTypeDefaultArgs instead
     */
    export type ExpertProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpertProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsultationTaskCountOutputTypeDefaultArgs instead
     */
    export type ConsultationTaskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsultationTaskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpertProfileDefaultArgs instead
     */
    export type ExpertProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpertProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsultationTaskDefaultArgs instead
     */
    export type ConsultationTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsultationTaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskExpertDefaultArgs instead
     */
    export type TaskExpertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskExpertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PreConsultationDocDefaultArgs instead
     */
    export type PreConsultationDocArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PreConsultationDocDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsultationDialogDefaultArgs instead
     */
    export type ConsultationDialogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsultationDialogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostConsultationDocDefaultArgs instead
     */
    export type PostConsultationDocArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostConsultationDocDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpertOpinionDefaultArgs instead
     */
    export type ExpertOpinionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpertOpinionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsultationReportDefaultArgs instead
     */
    export type ConsultationReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsultationReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskLogDefaultArgs instead
     */
    export type TaskLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}